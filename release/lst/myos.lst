ca65 V2.17 - Git 59ab140
Main file   : ..\src\myos.a65
Current file: ..\src\myos.a65

000000r 1               	.IF PLATFORM = 2
000000r 1               		.include "atarixl.inc"
000000r 1               	.ENDIF
000000r 1               
000000r 1               		.include "homebrew.inc"
000000r 2               ;
000000r 2               ; PLATFORM = 0 : Homebrew - FPGA
000000r 2               ; PLATFORM = 1 : Homebrew - Hardware
000000r 2               ; PLATFORM = 2 : Atari XL/XE
000000r 2               ;
000000r 2               IO		= $FFFF00
000000r 2               ROMSTART	= $E000		;$8000 = Test, $E000 = Prod
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Kernel jumptable
000000r 2               ;--------------------------------------------------------------
000000r 2               jkernel		= ROMSTART
000000r 2               jchrin		= ROMSTART + $3
000000r 2               jchrout		= ROMSTART + $6
000000r 2               jprint		= ROMSTART + $9
000000r 2               jprinthex	= ROMSTART + $C
000000r 2               jgetupper	= ROMSTART + $F
000000r 2               jgethex		= ROMSTART + $12
000000r 2               jgetadr		= ROMSTART + $15
000000r 2               jnewline	= ROMSTART + $18
000000r 2               jspace		= ROMSTART + $1B
000000r 2               jhexdownload	= ROMSTART + $1E
000000r 2               jmemdump	= ROMSTART + $21
000000r 2               jinputhex	= ROMSTART + $24
000000r 2               jchangemem	= ROMSTART + $27
000000r 2               jfillmem	= ROMSTART + $2A
000000r 2               jfill		= ROMSTART + $2D
000000r 2               jnmin		= ROMSTART + $30
000000r 2               jirqn		= ROMSTART + $33
000000r 2               jbrk		= ROMSTART + $36
000000r 2               jtime		= ROMSTART + $39
000000r 2               jmenu		= ROMSTART + $3C
000000r 2               jdisass		= ROMSTART + $3F
000000r 2               jdisone		= ROMSTART + $42
000000r 2               jrs232v		= ROMSTART + $45
000000r 2               jsetaddress	= ROMSTART + $48
000000r 2               jmemdump16	= ROMSTART + $4B
000000r 2               jkgbirq		= ROMSTART + $4E	;(4-bytes !!)
000000r 2               jdisass24	= ROMSTART + $52
000000r 2               jcopn		= ROMSTART + $55
000000r 2               
000000r 2               ;
000000r 2               ; Dummy vectors
000000r 2               ;
000000r 2               jcope		= ROMSTART + $30
000000r 2               jaborte		= ROMSTART + $30
000000r 2               jabortn		= ROMSTART + $30
000000r 2               jirqe		= ROMSTART + $30
000000r 2               jnmie		= ROMSTART + $30
000000r 2               
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; SD CARD constants
000000r 2               ;--------------------------------------------------------------
000000r 2               CMD0		= $40 +  0	;GO_IDLE_STATE	0x40, 64
000000r 2               CMD1		= $40 +  1	;reset
000000r 2               CMD8		= $40 +  8	;SEND_IF_COND	0x48, 72
000000r 2               CMD9		= $40 +  9	;SEND_CSD	0x49, 73
000000r 2               CMD13		= $40 + 13	;get_status	0x4D, 77
000000r 2               CMD17		= $40 + 17	;read  sector 	0x51, 81
000000r 2               CMD24		= $40 + 24	;write sector 	0x58, 88
000000r 2               CMD41		= $40 + 41	;SEND_OP_COND	0x69, 105 (leave idle state)
000000r 2               CMD55		= $40 + 55	;ACMD 		0x77, 119
000000r 2               CMD58		= $40 + 58	;READ_OCR	0x7A, 122
000000r 2               
000000r 2               DATA_START_BLOCK	= $FE
000000r 2               DATA_RES_MASK		= $1F
000000r 2               DATA_RES_ACCEPTED	= $05
000000r 2               
000000r 2               CMD0CHK		= $95
000000r 2               CMD1CHK		= $F9
000000r 2               CMD8CHK		= $87
000000r 2               
000000r 2               R1_IDLE_STATE	= 1
000000r 2               R1_ILLEGAL_COMMAND = 4
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; MISC constants
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               NEGATIVE	= $80
000000r 2               OVERFLOW	= $40		;
000000r 2               M		= $20		; Accu 8/16-bit
000000r 2               IX		= $10		; Index 8/16-bit
000000r 2               DECIMAL_FLAG	= $08		; Decimal Flag
000000r 2               ID		= $04		; IRQ disable
000000r 2               ZERO		= $02		; zero flag
000000r 2               CARRY		= $01		; Carry
000000r 2               
000000r 2               CHARS40		= 40
000000r 2               CHARS80		= 80
000000r 2               NUMROWS		= 25
000000r 2               
000000r 2               ;	special key scan-codes
000000r 2               ALTGR		= $11	;extended!
000000r 2               ALR		= $11
000000r 2               CLSHIFT		= $12
000000r 2               CLSTRG		= $14
000000r 2               CRSHIFT		= $59
000000r 2               CCAPS		= $58
000000r 2               
000000r 2               CCHARLINE	= 80	;80 chars per line
000000r 2               
000000r 2               	.if PLATFORM = 0
000000r 2               SCRSTRT		= $F000
000000r 2               SCRBANK		= $7F
000000r 2               	.else
000000r 2               SCRSTRT		= $C000
000000r 2               	.endif
000000r 2               charset		= $F800
000000r 2               
000000r 2               jusermenu	= $0400
000000r 2               juserkeys	= $0403
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; ATARI constants
000000r 2               ;--------------------------------------------------------------
000000r 2               LEDGE	= 	0	;left edge
000000r 2               
000000r 2               MAXDEV	=	33	;offset to last possible entry of HATABS
000000r 2               
000000r 2               IOCBSZ	=	16	;length of IOCB
000000r 2               IOCFRE	=	$FF	;IOCB free indicator
000000r 2               
000000r 2               SEIOCB	=	0*IOCBSZ	;screen editor IOCB index
000000r 2               MAXIOC	=	8*IOCBSZ	;first invalid IOCB index
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Device Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               CASSET	=	'C'	;cassette
000000r 2               DISK	=	'D'	;disk
000000r 2               SCREDT	=	'E'	;screen editor
000000r 2               KBD	=	'K'	;keyboard
000000r 2               PRINTR	=	'P'	;printer
000000r 2               DISPLY	=	'S'	;screen display
000000r 2               RS232D	=	'R'	;RS232 serial interface
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	IOCB Command Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               OPEN	=	$03	;open
000000r 2               GETREC	=	$05	;get record
000000r 2               GETCHR	=	$07	;get character(s) (binary)
000000r 2               PUTREC	=	$09	;put record
000000r 2               PUTCHR	=	$0B	;put character(s)
000000r 2               CLOSE	=	$0C	;close
000000r 2               STATUS	=	$0D	;status
000000r 2               SPECIL	=	$0E	;special
000000r 2               
000000r 2               CXIO36	= 	36
000000r 2               CXIO38	=	38
000000r 2               CXIO40	=	40
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Character and Key Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               			;SUPERF <>  0
000000r 2               
000000r 2               CCHM	=	$1C	;move cursor home
000000r 2               CCBT	=	$1D	;move cursor to bottom
000000r 2               CCLM	=	$1E	;move cursor to left margin
000000r 2               CCRM	=	$1F	;move cursor to right margin
000000r 2               
000000r 2               			;SUPERF = 0
000000r 2               
000000r 2               CLS	=	$01	;clear screen
000000r 2               BACK	=	$08	;backspace
000000r 2               EOL	=	$0A	;$9B	;end of line (RETURN)
000000r 2               ESC	=	$1B	;escape key
000000r 2               CCUP	=	$1C	;cursor up
000000r 2               CCDN	=	$1D	;cursor down
000000r 2               CCLF	=	$1E	;cursor left
000000r 2               CCRT	=	$1F	;cursor right
000000r 2               CSPACE	=	$20	;space
000000r 2               TABU	=	$7F	;tabulator
000000r 2               CILN	=	$9D	;insert line
000000r 2               CDCH	=	$FE	;delete character
000000r 2               CICH	=	$FF	;insert character
000000r 2               
000000r 2               HELP	=	$11	;key code for HELP
000000r 2               CNTLF1	=	$83	;key code for CTRL-F1
000000r 2               CNTLF2	=	$84	;key code for CTRL-F2
000000r 2               CNTLF3	=	$93	;key code for CTRL-F3
000000r 2               CNTLF4	=	$94	;key code for CTRL-F4
000000r 2               CNTL1	=	$9F	;key code for CTRL-1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Status Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               SUCCES	=	1	;successful operation
000000r 2               
000000r 2               BRKABT	=	128	;BREAK key abort
000000r 2               PRVOPN	=	129	;IOCB already open error
000000r 2               NONDEV	=	130	;nonexistent device error
000000r 2               WRONLY	=	131	;IOCB opened for write only error
000000r 2               NVALID	=	132	;invalid command error
000000r 2               NOTOPN	=	133	;device/file not open error
000000r 2               BADIOC	=	134	;invalid IOCB index error
000000r 2               RDONLY	=	135	;IOCB opened for read only error
000000r 2               EOFERR	=	136	;end of file error
000000r 2               TRNRCD	=	137	;truncated record error
000000r 2               TIMOUT	=	138	;peripheral device timeout error
000000r 2               DNACK	=	139	;device does not acknowledge command error
000000r 2               FRMERR	=	140	;serial bus framing error
000000r 2               CRSROR	=	141	;cursor overrange error
000000r 2               OVRRUN	=	142	;serial bus data overrun error
000000r 2               CHKERR	=	143	;serial bus checksum error
000000r 2               DERROR	=	144	;device done (operation incomplete) error
000000r 2               BADMOD	=	145	;bad screen mode number error
000000r 2               FNCNOT	=	146	;function not implemented in handler error
000000r 2               SCRMEM	=	147	;insufficient memory for screen mode error
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew variables Zero page
000000r 2               ;--------------------------------------------------------------
000000r 2               ptr		= $00	;2-byte misc. pointer
000000r 2               memptr		= $02	;3-byte pointer
000000r 2               
000000r 2               PCREG		= $02   ;3-byte redefine for disassembler
000000r 2               PCREGH		= PCREG+1
000000r 2               PCREGB		= PCREGH+1
000000r 2               
000000r 2               chksum		= $05	;1-byte checksum
000000r 2               
000000r 2               FATPTRS_	= $06	;2-byte FAT source pointer
000000r 2               FATPTRD_	= $08	;2-byte FAT destination pointer
000000r 2               PTRDUP		= $0A	;2-byte misc. pointer DUP
000000r 2               SECPTR		= $0C	;2-byte sector pointer
000000r 2               CHRPTR		= $0E	;2-byte sector pointer hi-res char handling
000000r 2               DEVICNO		= $10	;1-byte stdout device (0=RS232, 1=CRT)
000000r 2               TEMP		= $11	;3-byte pointer for debug16
000000r 2               TEMPH		= $12
000000r 2               TEMPB		= $13
000000r 2               PREG		= $14	;1-byte P STATUS REGISTER
000000r 2               gethex_A	= $15	;1-byte save accu
000000r 2               
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; ATARI zeropage
000000r 2               ;--------------------------------------------------------------
000000r 2               ZIOCB	=	$0020	;address of page zero IOCB
000000r 2               IOCBAS	=	$0020	;16-byte page zero IOCB
000000r 2               ICHIDZ	=	$0020	;1-byte handler ID ($FF = IOCB free)
000000r 2               ICDNOZ	=	$0021	;1-byte device number
000000r 2               ICCOMZ	=	$0022	;1-byte command code
000000r 2               ICSTAZ	=	$0023	;1-byte status of last action
000000r 2               ICBALZ	=	$0024	;1-byte buffer address low
000000r 2               ICBAHZ	=	$0025	;1-byte buffer address high
000000r 2               ICBABZ	=	$0026	;1-byte buffer address bank
000000r 2               ICBLLZ	=	$0027	;1-byte buffer length low
000000r 2               ICBLHZ	=	$0028	;1-byte buffer length high
000000r 2               ICBLBZ	=	$0029	;1-byte buffer length bank
000000r 2               ICAX1Z	=	$002A	;1-byte first auxiliary information
000000r 2               ICAX2Z	=	$002B	;1-byte second auxiliary information
000000r 2               ICSPRZ	=	$002C	;4-byte spares
000000r 2               ;ENTVEC	=	$002C	;2-byte (not used)
000000r 2               ICIDNO	=	$002E	;1-byte IOCB index (IOCB number times IOCBSZ)
000000r 2               CIOCHR	=	$002F	;1-byte character for current CIO operation
000000r 2               ;ICPTLZ	=	$0026	;1-byte low PUT-BYTE routine address-1
000000r 2               ;ICPTHZ	=	$0027	;1-byte high PUT-BYTE routine address-1
000000r 2               
000000r 2               BRKKEY	=	$0030	;1-byte BREAK key flag (0 = no BREAK)
000000r 2               ICCOMT	=	$0031	;1-byte CIO command table index
000000r 2               DSTAT	=	$0032	;1-byte display status
000000r 2               TMPCHR	=	$0033	;1-byte	temporary character
000000r 2               HOLD1	=	$0034	;1-byte	temporary
000000r 2               LMARGN	=	$0035	;1-byte text column left margin
000000r 2               RMARGN	=	$0036	;1-byte text column right margin
000000r 2               ROWCRS	=	$0037	;1-byte cursor row
000000r 2               COLCRS	=	$0038	;2-byte cursor column
000000r 2               ALTACT	=	$003A	;1-byte ALRGR active --display mode
000000r 2               SAVMSC	=	$003B	;2-byte saved memory scan counter
000000r 2               OLDROW	=	$003D	;1-byte prior row
000000r 2               OLDCOL	=	$003E	;2-byte prior column
000000r 2               OLDCHR	=	$0040	;1-byte saved character under cursor
000000r 2               OLDADR	=	$0041	;3-byte saved cursor memory address
000000r 2               
000000r 2               LOGCOL	=	$0044	;1-byte logical line cursor column
000000r 2               
000000r 2               ;DUMMY	=	$0044	;2-byte temporary address
000000r 2               
000000r 2               ;MLTTMP	=	$0046	;1-byte temporary
000000r 2               ;OPNTMP	=	$0046	;1-byte open temporary
000000r 2               TOADR	=	$0045	;3-byte destination address
000000r 2               
000000r 2               SAVADR	=	$0048	;3-byte saved address
000000r 2               FRMADR	=	$0048	;3-byte source address
000000r 2               
000000r 2               RAMTOP	=	$004B	;1-byte RAM size
000000r 2               BUFCNT	=	$004C	;1-byte buffer count (logical line size)
000000r 2               BUFSTR	=	$004D	;2-byte buffer start pointer
000000r 2               BITMSK	=	$004F	;1-byte bit mask for bit map operation
000000r 2               ;SHFAMT	=	$004F	;1-byte shift amount for pixel justification
000000r 2               ROWAC	=	$0050	;2-byte draw working row
000000r 2               COLAC	=	$0052	;2-byte draw working column
000000r 2               ENDPT	=	$0054	;2-byte end point
000000r 2               DELTAR	=	$0056	;1-byte row difference
000000r 2               DELTAC	=	$0057	;2-byte column difference
000000r 2               SWPFLG	=	$0059	;1-byte split screen swap flag (0 = not swapped)
000000r 2               INSDAT	=	$005A	;1-byte temporary
000000r 2               COUNTR	=	$005B	;2-byte draw iteration count
000000r 2               ADRESS	=	$005D	;3-byte temporary address
000000r 2               
000000r 2               
000000r 2               
000000r 2               XREG	= ADRESS+3       ; X REGISTER
000000r 2               XREGH 	= XREG+1
000000r 2               
000000r 2               YREG	= XREGH+1        ; Y REGISTER
000000r 2               YREGH	= YREG+1
000000r 2               
000000r 2               AREG	= YREGH+1        ; ACCUMULATOR
000000r 2               AREGH	= AREG+1
000000r 2               
000000r 2               STACK	= AREGH+1        ; STACK POINTER
000000r 2               STACKH	= STACK+1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 2
000000r 2               ;--------------------------------------------------------------
000000r 2               TXTROW	=	$0200	;1-byte split screen text cursor row
000000r 2               TXTCOL	=	$0201	;2-byte split screen text cursor column
000000r 2               TINDEX	=	$0203	;1-byte split scree text mode
000000r 2               TXTMSC	=	$0204	;2-byte split screen memory scan counter
000000r 2               TXTOLD	=	$0206	;6-byte OLDROW, OLDCOL, OLDCHR, OLDADR for text
000000r 2               HOLD3	=	$020C	;1-byte temporary
000000r 2               SUBTMP	=	$020D	;1-byte temporary
000000r 2               HOLD2	=	$020E	;1-byte (not used)
000000r 2               ;DMASK	=	$020F	;1-byte display (pixel location) mask
000000r 2               ;TMPLBT	=	$0210	;1-byte (not used)
000000r 2               RASVEC	=	$020F	;raster interrupt vector
000000r 2               ESCFLG	=	$0211	;1-byte escape flag ($80 = ESC detected)
000000r 2               TABMAP	=	$0212	;15-byte (120-bit) tab stop bit map
000000r 2               LOGMAP	=	$0221	;8-byte (32-bit) logical line bit map
000000r 2               CLSFLG	=	$0229	;1-byte clear screen flag
000000r 2               FILFLG	=	$022A	;1-byte right fill flag (0 = no fill)
000000r 2               TMPROW	=	$022B	;1-byte temporary row
000000r 2               TMPCOL	=	$022C	;2-byte temporary column
000000r 2               SCRFLG	=	$022E	;1-byte scroll occurence flag (0 = not occurred)
000000r 2               HOLD4	=	$022F	;1-byte temporary
000000r 2               DRETRY	=	$0230	;1-byte number of device retries
000000r 2               SHFLOK	=	$0231	;1-byte shift/control lock flags
000000r 2               BOTSCR	=	$0232	;1-byte screen bottom (24 = normal, 4 = split)
000000r 2               
000000r 2               DVSTAT	=	$0233	;4-byte device status buffer
000000r 2               CRSINH	=	$0237	;1-byte cursor inhibit (0 = cursor on)
000000r 2               DUMMY00	=	$0238	;1-byte key debounce delay timer
000000r 2               CH1	=	$0239	;1-byte prior keyboard character
000000r 2               
000000r 2               NEWROW	=	$023A	;1-byte draw destination row
000000r 2               NEWCOL	=	$023B	;2-byte draw destination column
000000r 2               ROWINC	=	$023D	;1-byte draw row increment
000000r 2               COLINC	=	$023E	;1-byte	draw column increment
000000r 2               
000000r 2               CHAR	=	$023F	;1-byte internal character
000000r 2               ATACHR	=	$0240	;1-byte ATASCII character or plot point
000000r 2               FILDAT	=	$0241	;1-byte right fill data
000000r 2               DSPFLG	=	$0242	;1-byte control character display flag (0 = no)
000000r 2               SSFLAG	=	$0243	;1-byte start/stop flag (0 = not stopped)
000000r 2               
000000r 2               SUPERF	=	$0244	;1-byte editor super function flag :
000000r 2               ;DERRF	=	$0245	;1-byte screen OPEN error flag (0 = not)
000000r 2               
000000r 2               skipone	=	$0246	;1-byte
000000r 2               extended=	$0247	;1-byte
000000r 2               ADRCNT	=	$0248	;1-byte counter for setaddress
000000r 2               
000000r 2               IRQVEC	=	$0249	;2-byte
000000r 2               NMIVEC	=	$024B	;2-byte
000000r 2               jmpind	=	$024D	;1-byte $4C = JMP
000000r 2               jmpptr	=	$024E	;2-byte
000000r 2               DBUFLO	=	$0250	;2-byte ;2-byte adr of 512-byte buffer for SD CARD read/Write
000000r 2               sdcmd	=	$0252	;1-byte SD card command
000000r 2               sdadr	=	$0253	;4-byte SD card address
000000r 2               sdchk	=	$0257	;1-byte SD card checksum
000000r 2               sdres	=	$0258	;1-byte SD card R1 result
000000r 2               sddebug =	$0259	;1-byte SD card debug flag
000000r 2               FVEC	=	$025A	;2-byte executable file start vector
000000r 2               FINIT	=	$025C	;2-byte executable file init vector
000000r 2               JSLOP	=	$025E	;1-byte JSL-opcode
000000r 2               JSLADR	=	$025F	;3-byte JSL address
000000r 2               JSLRTS	=	$0262	;1-byte RTS-opcode
000000r 2               JMLOP	=	$0263	;1-byte JML-opcode
000000r 2               JMLADR	=	$0264	;3-byte JML address
000000r 2               DEVSTAT	=	$0269	;4-byte device status
000000r 2               SERCNT0	= 	$026D	;1-byte RS232 0 control bits
000000r 2               SERCNT1	= 	$026E	;1-byte RS232 1 control bits
000000r 2               CONST5MS=	$026F	;2-byte timer const
000000r 2               MSTATE	=	$0270	;1-byte state of mouse protocol (0,1,2)
000000r 2               MPOSX	=	$0271	;2-byte mouse x-pos
000000r 2               MPOSY	=	$0273	;2-byte mouse y-pos
000000r 2               MDXDY	=	$0275	;1-byte mouse 1st byte of protocol
000000r 2               MONACT	=	$027B	;4-byte break-monitor active flags
000000r 2               
000000r 2               IOCBSTRT=	$0280		;start of IOCB
000000r 2               IOCB	=	IOCBSTRT + $0	;128-byte I/O control blocks area
000000r 2               ICHID	=	IOCBSTRT + $0	;1-byte handler ID ($FF = free)
000000r 2               ICDNO	=	IOCBSTRT + $1	;1-byte device number
000000r 2               ICCOM	=	IOCBSTRT + $2	;1-byte command code
000000r 2               ICSTA	=	IOCBSTRT + $3	;1-byte status of last action
000000r 2               ICBAL	=	IOCBSTRT + $4	;1-byte low buffer address
000000r 2               ICBAH	=	IOCBSTRT + $5	;1-byte high buffer address
000000r 2               ICBAB	=	IOCBSTRT + $6	;1-byte bank buffer address
000000r 2               ICBLL	=	IOCBSTRT + $7	;1-byte low buffer length
000000r 2               ICBLH	=	IOCBSTRT + $8	;1-byte high buffer length
000000r 2               ICBLB	=	IOCBSTRT + $9	;1-byte bank buffer length
000000r 2               ICAX1	=	IOCBSTRT + $A	;1-byte first auxiliary information
000000r 2               ICAX2	=	IOCBSTRT + $B	;1-byte second auxiliary information
000000r 2               ICSPR	=	IOCBSTRT + $C	;4-byte work area
000000r 2               ;ICPTL	=	IOCBSTRT + $6	;1-byte low PUT-BYTE routine address-1
000000r 2               ;ICPTH	=	IOCBSTRT + $7	;1-byte high PUT-BYTE routine address-1
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 3
000000r 2               ;--------------------------------------------------------------
000000r 2               HATABS	=	$0300	;12 * 3-byte entries for HATABS
000000r 2               ;MONTAB	=	$0324	;8-byte break-monitor pointer
000000r 2               flags	=	$032C	;1-byte processor flags during IRQ
000000r 2               IRQPS2S	=	$032D	;1-byte PS2-status from IRQ
000000r 2               IRQPS2D =	$032E	;1-byte PS2-data from IRQ
000000r 2               DEVICS	=	$032F	;1-byte DEVICENO SAVE
000000r 2               BRKBRA	=	$0330	;1-byte branch opcode
000000r 2               BRKOFF	=	$0331	;1-byte branch offset (always 3)
000000r 2               BRKNOT	=	$0332	;1-byte jmp branch not taken (always $4c)
000000r 2               BRKJMP0	=	$0333	;2-byte jmp address branch not taken
000000r 2               BRKTAK	=	$0335	;1-byte jmp branch taken (always $4c)
000000r 2               BRKJMP1	=	$0336	;2-byte jmp address branch taken
000000r 2               BRKVEC	=	$0338	;2-byte BRK vector (65816)
000000r 2               WARMFLAG=	$033A	;1-byte Warmstart = $CA
000000r 2               ARGC	=	$033B	;2-byte number of args
000000r 2               ARGV	=	$033D	;8*2-bytes pointer to arg strings
000000r 2               NCODE	= 	$034D	;1-byte NEXT CODE TO BE TRACED
000000r 2               OPCREG	=	$034E	;3-byte OLD PROGRAM COUNTER VALUE
000000r 2               OPCREGH	=	$034F
000000r 2               OPCREGB	=	$0350
000000r 2               CODE	=	$0351	;1-byte CURRENT CODE TO BE TRACED
000000r 2               OPRNDL	=	$0352	;3-byte OPERANDS OF CURRENT INSTRUCTION
000000r 2               OPRNDH	=	$0353
000000r 2               OPRNDB	=	$0354
000000r 2               ADDRMODE=	$0355	; ADDRESS MODE OF CURRENT OPCODE
000000r 2               
000000r 2               MNX	=	$0356 	;2-byte MNEMONIC INDEX
000000r 2                                       ; FROM ATTRIBUTE TABLE
000000r 2               OPLEN 	=	$0358   ;1-byte LENGTH OF OPERATION,
000000r 2                                       ; INCLUDING INSTRUCTION
000000r 2               MOVENEG	=	$0359	;4-byte MVP + operands + RTS
000000r 2               MOVEBNK	=	$035A
000000r 2               MOVERTS	=	$035C	;RTS
000000r 2               
000000r 2               MODBASE	=	$035D	;2-byte base for next module to be loaded
000000r 2               
000000r 2               MONTAB	=	$0360	;4*4-byte break-monitor pointer
000000r 2               
000000r 2               COLCNT	=	$0370	;
000000r 2               COPVEC	=	$0371	;2-byte COP vector
000000r 2               
000000r 2               MOUSEX	=	$0373	;2-byte Mouse-X
000000r 2               MOUSEY	=	$0375	;2-byte Mouse-Y
000000r 2               MOUBUT	=	$0377	;Mouse-Button Bit7:links, Bit6:rechts
000000r 2               
000000r 2               NEXTFRE	=	$0378	;
000000r 2               
000000r 2               FNAME	= 	$0380	;128-byte buffer for line
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 4
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MC6845 graphics
000000r 2               ;--------------------------------------------------------------
000000r 2               crtadr		= $B800
000000r 2               crtdata		= $B801
000000r 2               
000000r 2               crtcol0		= $B880
000000r 2               crtcol1		= $B881
000000r 2               crtcol2		= $B882
000000r 2               crtcol3		= $B883
000000r 2               crtcolb		= crtcol3
000000r 2               
000000r 2               crtcntl		= $B8C0
000000r 2               crtirq		= $B8C1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MOS6551 serial card
000000r 2               ;--------------------------------------------------------------
000000r 2               ;data6551	= $DB00
000000r 2               ;status6551	= $DB01
000000r 2               ;command6551	= $DB02
000000r 2               ;control6551	= $DB03
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew YM2612 registers
000000r 2               ;--------------------------------------------------------------
000000r 2               YMADR0		= $BFB0
000000r 2               YMDAT0		= $BFB1
000000r 2               YMADR1		= $BFB2
000000r 2               YMDAT1		= $BFB3
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew	Memory Control
000000r 2               ;--------------------------------------------------------------
000000r 2               MEMCNTL		= $BFC0
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew PS2-keyboard and SD-Card
000000r 2               ;--------------------------------------------------------------
000000r 2               PS2		= IO + $D0
000000r 2               PS2DATA		= PS2 + 0	; keyboard scancode
000000r 2               PS2STATUS	= PS2 + 1	; read: Bit0 = 0 scancode available
000000r 2               SPIDATA		= PS2 + 2	; read: Bit0 serial data in, write: Bit7 serial data out
000000r 2               SPIMOSI		= PS2 + 3	; write: Bit0: 1 = Mosi always 1, Bit1: write: CS of SDCard
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew Centronics 8-bit latch
000000r 2               ;--------------------------------------------------------------
000000r 2               CENTRONICS	= $BFE0
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MC68681 double serial card
000000r 2               ;--------------------------------------------------------------
000000r 2               SB		= $BFF0
000000r 2               
000000r 2               MODEA		= 0
000000r 2               STATA		= 1
000000r 2               CLOCKA		= 1
000000r 2               COMMA		= 2
000000r 2               RECA		= 3
000000r 2               TRANSA		= 3
000000r 2               IPCHANGE	= 4
000000r 2               AUXCTRL		= 4
000000r 2               ISR		= 5
000000r 2               IMR		= 5
000000r 2               CNTMSB		= 6
000000r 2               CNTLSB		= 7
000000r 2               MODEB		= 8
000000r 2               STATB		= 9
000000r 2               CLOCKB		= 9
000000r 2               COMMB		= 10
000000r 2               RECB		= 11
000000r 2               TRANSB		= 11
000000r 2               IVR		= 12
000000r 2               INPORT		= 13
000000r 2               OPCTRL		= 13
000000r 2               STRTCNT		= 14
000000r 2               OPSET		= 14
000000r 2               STOPCNT		= 15
000000r 2               OPRES		= 15
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 6502 CPU vectors
000000r 2               ;--------------------------------------------------------------
000000r 2               NMI		= $FFFA
000000r 2               RESET		= $FFFC
000000r 2               IRQ		= $FFFE
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; FPGA misc. stuff
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; RESET, TIMER, HARDWARE MULT.
000000r 2               ;--------------------------------------------------------------
000000r 2               SOFTRESET	= IO + $80
000000r 2               TIMERLO 	= IO + $81
000000r 2               TIMERHI		= IO + $82
000000r 2               TIMERST		= IO + $83
000000r 2               WORDLO		= IO + $84
000000r 2               WORDHI		= IO + $85
000000r 2               DOTS		= IO + $86
000000r 2               
000000r 2               CCONST5MS	= 62400-1
000000r 2               ;--------------------------------------------------------------
000000r 2               ; SPI SD-card interface
000000r 2               ;--------------------------------------------------------------
000000r 2               SPI		= IO + $90
000000r 2               SPICNTL		= SPI
000000r 2               SPISS		= SPI + 1
000000r 2               SPIDAT		= SPI + 2
000000r 2               SPISTAT		= SPI + 3
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 16450 ACIA registers (Uart1, Mouse)
000000r 2               ;--------------------------------------------------------------
000000r 2               ACIA1		= IO + $A0
000000r 2               RBR1		= ACIA1
000000r 2               THR1		= ACIA1
000000r 2               IER1		= ACIA1 + 1
000000r 2               IIR1		= ACIA1 + 2
000000r 2               LCR1		= ACIA1 + 3
000000r 2               MCR1		= ACIA1 + 4
000000r 2               LSR1		= ACIA1 + 5
000000r 2               MSR1		= ACIA1 + 6
000000r 2               SCR1		= ACIA1 + 7
000000r 2               DLL1		= ACIA1
000000r 2               DLM1		= ACIA1 + 1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; graphics system
000000r 2               ;--------------------------------------------------------------
000000r 2               DISP			= $FFFE00
000000r 2               colorBorderLo		= DISP + 0
000000r 2               colorBorderHi		= DISP + 1
000000r 2               colorBackgroundLo	= DISP + 2
000000r 2               colorBackgroundHi	= DISP + 3
000000r 2               color00Lo		= DISP + 4
000000r 2               color00Hi		= DISP + 5
000000r 2               screenBaseLo		= DISP + 6
000000r 2               screenBaseHi		= DISP + 7
000000r 2               screenBaseBank		= DISP + 8
000000r 2               control			= DISP + 9
000000r 2               cursorLo		= DISP + 10
000000r 2               cursorHi		= DISP + 11
000000r 2               rasterLo		= DISP + 12
000000r 2               rasterHi		= DISP + 13
000000r 2               dispStatus		= DISP + 14
000000r 2               vcountLo		= DISP + 15
000000r 2               vcountHi		= DISP + 16
000000r 2               ;spriteBaseLo		= DISP + 17
000000r 2               ;spriteBaseHi		= DISP + 18
000000r 2               spriteBaseBank		= DISP + 19
000000r 2               spriteCntl		= DISP + 20
000000r 2               sprite0addr		= DISP + 21
000000r 2               sprite1addr             = DISP + 22
000000r 2               sprite2addr             = DISP + 23
000000r 2               sprite3addr             = DISP + 24
000000r 2               sprite4addr             = DISP + 25
000000r 2               sprite5addr             = DISP + 26
000000r 2               sprite6addr             = DISP + 27
000000r 2               sprite7addr             = DISP + 28
000000r 2               xpos0			= DISP + 32
000000r 2               xpos1			= DISP + 33
000000r 2               xpos2			= DISP + 34
000000r 2               xpos3			= DISP + 35
000000r 2               xpos4			= DISP + 36
000000r 2               xpos5			= DISP + 37
000000r 2               xpos6			= DISP + 38
000000r 2               xpos7			= DISP + 39
000000r 2               xposHi			= DISP + 40
000000r 2               
000000r 2               palette 		= $FFFC00
000000r 2               spritePalette		= $FFFE40
000000r 2               sprite0			= $7E0000
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 16450 ACIA registers (Uart0)
000000r 2               ;--------------------------------------------------------------
000000r 2               ACIA0		= IO + $E0
000000r 2               RBR0		= ACIA0
000000r 2               THR0		= ACIA0
000000r 2               IER0		= ACIA0 + 1
000000r 2               IIR0		= ACIA0 + 2
000000r 2               LCR0		= ACIA0 + 3
000000r 2               MCR0		= ACIA0 + 4
000000r 2               LSR0		= ACIA0 + 5
000000r 2               MSR0		= ACIA0 + 6
000000r 2               SCR0		= ACIA0 + 7
000000r 2               DLL0		= ACIA0
000000r 2               DLM0		= ACIA0 + 1
000000r 2               
000000r 2               SECPTRLO	= ACIA0 + 8
000000r 2               SECPTRHI	= ACIA0 + 9
000000r 2               READWRITE	= ACIA0 + 10
000000r 2               BUFPTRLO	= ACIA0 + 11
000000r 2               BUFPTRHI	= ACIA0 + 12
000000r 2               
000000r 2               
000000r 1               		.include "fat16.inc"
000000r 2               ;
000000r 2               ; PLATFORM = 0 : Homebrew FPGA
000000r 2               ; PLATFORM = 1 : Homebrew Hardware
000000r 2               ; PLATFORM = 2 : Atari XL/XE
000000r 2               ; PLATFORM = 3 : my65816 FPGA
000000r 2               ;
000000r 2               ;
000000r 2               ; FAT-16 defines
000000r 2               ;
000000r 2               DRVCHAR		= 'D'
000000r 2               
000000r 2               	.IF PLATFORM <= 1
000000r 2               FATPTRS		= $0006
000000r 2               FATPTRD		= $0008
000000r 2               	.ELSE
000000r 2               FATPTRS		= $0000
000000r 2               FATPTRD		= $0002
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Memory Setup
000000r 2               ;--------------------------------------------------------------
000000r 2               	.IF PLATFORM <= 1
000000r 2               VBASE		= $400
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;	.IF PLATFORM = 3
000000r 2               ;VBASE		= $400
000000r 2               ;	.ENDIF
000000r 2               
000000r 2               	.IF PLATFORM = 2
000000r 2               VBASE		= $700
000000r 2               FATCODE		= VBASE+$600
000000r 2               DUPCODE		= $1C00
000000r 2               
000000r 2               JSTARTUP	= FATCODE
000000r 2               JPRINT		= FATCODE+3
000000r 2               JPUTHEX		= FATCODE+6
000000r 2               JPRINTSTR	= FATCODE+9
000000r 2               JINITFAT	= FATCODE+12
000000r 2               	.ENDIF
000000r 2               
000000r 2               V		= VBASE
000000r 2               BUFFER		= VBASE+$200
000000r 2               FATBUF		= VBASE+$400
000000r 2               
000000r 2               CRENAME		= 32
000000r 2               CDELETE		= 33
000000r 2               CCREDIR		= 34
000000r 2               CFSTAT		= 40
000000r 2               CCHADIR		= 41
000000r 2               
000000r 2               DEL		= $E5
000000r 2               EOF		= $88
000000r 2               
000000r 2               SECCLUS		= V+0		;1
000000r 2               RESSEC		= V+1		;2
000000r 2               NUMFATS		= V+3		;1
000000r 2               NUMDIR		= V+4		;2
000000r 2               NUMSECS		= V+6		;2
000000r 2               MEDIA		= V+8		;1
000000r 2               SECSFAT		= V+9		;2
000000r 2               FCBCODE		= V+11 		;1
000000r 2               
000000r 2               SECTOR		= V+12		;4
000000r 2               FATBASE		= V+16		;4
000000r 2               DIRBASE		= V+20		;4
000000r 2               DATBASE		= V+24		;4
000000r 2               LASTSEC		= V+28		;4
000000r 2               LASTFAT		= V+32		;4
000000r 2               BYTCLUS		= V+36 		;4
000000r 2               
000000r 2               BIN		= V+40 		;4
000000r 2               BCD		= V+44 		;5
000000r 2               DECIMAL		= V+49 		;10
000000r 2               
000000r 2               NEWCLUS		= V+59		;2
000000r 2               DDIRTY		= V+61 		;1
000000r 2               FDIRTY		= V+62 		;1
000000r 2               BUFADRL		= V+63 		;1
000000r 2               BUFADRH		= V+64 		;1
000000r 2               
000000r 2               DIRCLUS		= V+65		;2
000000r 2               DIRRENA		= V+67 		;11
000000r 2               
000000r 2               NODISPL		= V+78 		;1
000000r 2               WILD		= V+79 		;1
000000r 2               DIRLINE		= V+80 		;13
000000r 2               DIRLENG		= V+93 		;10
000000r 2               DIREOF		= V+103 	;1
000000r 2               SAVEY		= V+104		;1
000000r 2               VALIDS		= V+105		;1-byte number of specials chars to check for
000000r 2               HILF		= V+106		;1-byte aux usage
000000r 2               ASTART		= V+107		;2-byte file load start vector
000000r 2               AEND		= V+109		;2-byte file load end vector
000000r 2               CNT		= V+111		;1-byte adress enter counter DUP
000000r 2               FHEADER		= V+112		;2-byte save file header ($FF)
000000r 2               FSTART		= V+114		;2-byte file load start vector save
000000r 2               FEND		= V+116		;2-byte file load end vector save
000000r 2               FSTARTS		= V+118		;2-byte file load start vector save
000000r 2               FENDS		= V+120		;2-byte file load end vector save
000000r 2               FDIFF		= V+122		;2-byte "into" difference save
000000r 2               JMPIND		= V+124		;1-byte holding $4C for JMP
000000r 2               JMPPTR		= V+125		;2-byte jmp address
000000r 2               
000000r 2               F		= V+127
000000r 2               
000000r 2               FIOCBNR		= F		;1-byte FCB is assigned to this IOCB
000000r 2               FFCBOFF		= F+1		;1-byte Offset of this FCB from FCB0
000000r 2               FSTRTCL		= F+2		;2-byte Start cluster of file
000000r 2               FILELEN		= F+4		;4-byte length of file
000000r 2               FWBURST		= F+8		;1-byte write burst 0=OFF, other=ON
000000r 2               FBURST		= F+9		;1-byte flag indicating burst read ($FF = slow)
000000r 2               FRPOS		= F+10		;4-byte bytes already read
000000r 2               FVAR32		= F+14		;4-byte 32-bit general var
000000r 2               FCURCLUS	= F+18		;4-byte current cluster
000000r 2               FCURSEC		= F+22		;1-byte current sector
000000r 2               FCURPTR		= F+23 		;2-byte current pointer into sector buffer
000000r 2               FSECTOR		= F+25 		;4-byte last sector read
000000r 2               
000000r 2               DIRTEXT		= F+29		;11-byte directory text 8 + 3
000000r 2               DIRPTR		= F+40		;2-byte pointer into directory sector
000000r 2               DIRSEC		= F+42		;4-byte directory sector
000000r 2               DIRFILE		= F+46		;1-byte dir or file to search for
000000r 2               FBLKEND		= F+46
000000r 2               
000000r 2               FCB0		= V+256
000000r 2               FCB1		= FCB0+64
000000r 2               FCB2		= FCB1+64
000000r 2               FCB3		= FCB2+64
000000r 2               
000000r 2               DNAME		= 0
000000r 2               DEXT		= 8
000000r 2               DATTRIB		= 11
000000r 2               DCLUS		= $1A
000000r 2               DLEN		= $1C
000000r 2               PART1		= $1C6
000000r 2               
000000r 1               		.include "myos.inc"
000000r 2               MYOS		= $C000
000000r 2               JMYOSSTART	= MYOS + $00
000000r 2               JREADSECTOR	= MYOS + $03
000000r 2               JSETSECTOR	= MYOS + $06
000000r 2               JWRITESECTOR	= MYOS + $09
000000r 2               JSDINIT		= MYOS + $0C
000000r 2               CIOV		= MYOS + $0F
000000r 2               JSTARTUP	= MYOS + $12
000000r 2               JPRINT		= MYOS + $15
000000r 2               JPUTHEX		= MYOS + $18
000000r 2               JPRINTSTR	= MYOS + $1B
000000r 2               JINITFAT	= MYOS + $1E
000000r 2               CIOV24		= MYOS + $21
000000r 2               
000000r 1               
000000r 1               		.org MYOS
00C000  1               		.smart
00C000  1               		.A8
00C000  1               		.I8
00C000  1               
00C000  1  4C 24 C0     		jmp myosstart	;xx00
00C003  1  4C 23 C1     		jmp readSector	;xx03
00C006  1  4C FA C0     		jmp setSector	;xx06
00C009  1  4C 33 C1     		jmp writeSector	;xx09
00C00C  1  4C F9 C0     		jmp sdInit	;xx0C
00C00F  1  4C 6E C1     		jmp CIO		;xx0F
00C012  1               
00C012  1  4C 26 CC     		JMP STARTUP	;xx12
00C015  1  4C 79 D9     		JMP PRINT	;xx15
00C018  1  4C 53 D9     		JMP PUTHEX	;xx18
00C01B  1  4C 91 D9     		JMP PRINTSTR	;xx1B
00C01E  1  4C BD D5     		JMP INITFAT	;xx1E
00C021  1               
00C021  1  4C 6A C1     		jmp CIO24	;xx21
00C024  1               
00C024  1               
00C024  1  A2 23        myosstart:	ldx #3*12 - 1
00C026  1  A9 00        		lda #0
00C028  1  9D 00 03     clrHATABS:	sta HATABS,x
00C02B  1  CA           		dex
00C02C  1  10 FA        		bpl clrHATABS
00C02E  1               
00C02E  1  A2 0E        		ldx #HATABSROM_end-HATABSROM-1
00C030  1  BD E7 CB     copyHATABS:	lda HATABSROM,x
00C033  1  9D 00 03     		sta HATABS,x
00C036  1  CA           		dex
00C037  1  10 F7        		bpl copyHATABS
00C039  1               
00C039  1               ;		lda #<SSDV
00C039  1               ;		sta SSDVEC
00C039  1               ;		lda #>SSDV
00C039  1               ;		sta SSDVEC+1
00C039  1               
00C039  1  20 56 C1     		jsr ICIO
00C03C  1  20 D0 C3     		jsr SIN
00C03F  1               
00C03F  1  AD 46 E0     		lda jrs232v+1
00C042  1  8D 0A 03     		sta HATABS+$A
00C045  1  AD 47 E0     		lda jrs232v+2
00C048  1  8D 0B 03     		sta HATABS+$B
00C04B  1               
00C04B  1  A2 00        		ldx #0		;open channel 00
00C04D  1  A9 03        		lda #OPEN	;with EDITOR
00C04F  1  9D 82 02     		sta ICCOM,x
00C052  1  A9 E1        		lda #<EDITOR
00C054  1  9D 84 02     		sta ICBAL,x
00C057  1  A9 CB        		lda #>EDITOR
00C059  1  9D 85 02     		sta ICBAH,x
00C05C  1  A9 0C        		lda #12
00C05E  1  9D 88 02     		sta ICBLH,x
00C061  1  9D 8A 02     		sta ICAX1,x
00C064  1  A9 00        		lda #0
00C066  1  9D 8B 02     		sta ICAX2,x
00C069  1  9D 87 02     		sta ICBLL,x
00C06C  1  20 6E C1     		jsr CIO
00C06F  1               
00C06F  1               start1:
00C06F  1               	.IF PLATFORM <= 1
00C06F  1  20 F9 C0     		jsr sdInit
00C072  1  20 26 CC     		jsr STARTUP
00C075  1  B0 F8        		bcs start1
00C077  1               	.ENDIF
00C077  1  60           		rts
00C078  1               
00C078  1               	.IF PLATFORM=99
00C078  1               		lda #<IRQPROC
00C078  1               		sta irqvec
00C078  1               		lda #>IRQPROC
00C078  1               		sta irqvec+1
00C078  1               		cli
00C078  1               		rts
00C078  1               
00C078  1               
00C078  1               IRQPROC:	pha
00C078  1               		lda #$03
00C078  1               		sta crtcol0
00C078  1               		sta crtirq
00C078  1               		sec
00C078  1               IRQ1:		sbc #1
00C078  1               		bne IRQ1
00C078  1               		lda #$11
00C078  1               		sta crtcol0
00C078  1               		pla
00C078  1               		rti
00C078  1               	.ENDIF
00C078  1               
00C078  1               initcrt:
00C078  1               	.IF PLATFORM = 0
00C078  1               
00C078  1               ;		ldx #11
00C078  1               ;initcrt1:	lda crttab,x
00C078  1               ;		sta DISP,x
00C078  1               ;		dex
00C078  1               ;		bpl initcrt1
00C078  1               
00C078  1  C2 30        		rep #M+IX
00C07A  1  A2 00 00     		ldx #0
00C07D  1  9B           		txy
00C07E  1  98           initcrt2:	tya
00C07F  1  0A           		asl
00C080  1  29 80 FF     		and #$FF80
00C083  1  9F 00 FC FF  		sta palette,x
00C087  1  98           		tya
00C088  1  29 3F 00     		and #$3F
00C08B  1  1F 00 FC FF  		ora palette,x
00C08F  1  9F 00 FC FF  		sta palette,x
00C093  1               
00C093  1  C8           		iny
00C094  1  E8           		inx
00C095  1  E8           		inx
00C096  1  E0 00 02     		cpx #512
00C099  1  D0 E3        		bne initcrt2
00C09B  1               
00C09B  1  A9 00 00     		lda #0
00C09E  1  8F 00 FC FF  		sta palette
00C0A2  1  A9 FF 01     		lda #$1ff
00C0A5  1  8F FE FD FF  		sta palette+$1fe
00C0A9  1               
00C0A9  1               
00C0A9  1  A2 00 00     		ldx	#0
00C0AC  1               initcrt3:
00C0AC  1  BD D1 C0     		lda	rgbtab,x
00C0AF  1  9F 00 FC FF  		sta	palette,x
00C0B3  1  9F 10 FC FF  		sta	palette+$10,x
00C0B7  1  E8           		inx
00C0B8  1  E8           		inx
00C0B9  1  E0 20 00     		cpx	#$20
00C0BC  1  D0 EE        		bne	initcrt3
00C0BE  1               
00C0BE  1  E2 20        		sep	#M
00C0C0  1  A2 00 00     		ldx	#0
00C0C3  1               initcrt4:
00C0C3  1  8A           		txa
00C0C4  1  9F 00 F8 7F  		sta	$7FF800,x
00C0C8  1  E8           		inx
00C0C9  1  E0 00 08     		cpx	#$800
00C0CC  1  D0 F5        		bne	initcrt4
00C0CE  1  E2 10        		sep 	#IX
00C0D0  1  60           		rts
00C0D1  1               
00C0D1  1               rgbtab:
00C0D1  1  00 00        		.word	0 >> 1			;black
00C0D3  1  03 00        		.word	$7 >> 1			;red
00C0D5  1  1C 00        		.word	$38 >> 1		;green
00C0D7  1  23 00        		.word	$7+$38 >> 1		;yellow
00C0D9  1  E0 00        		.word	$1C0 >> 1		;blue
00C0DB  1  C3 01        		.word	$1c0+$7	>> 1		;magenta
00C0DD  1  DC 01        		.word	$1c0+$38 >> 1		;cyan
00C0DF  1  FF 00        		.word	$1ff >> 1		;white
00C0E1  1  92 00        		.word	$92			;black
00C0E3  1  07 00        		.word	$7			;red
00C0E5  1  38 00        		.word	$38			;green
00C0E7  1  3F 00        		.word	$7+$38			;yellow
00C0E9  1  C0 01        		.word	$1C0			;blue
00C0EB  1  C7 01        		.word	$1c0+$7			;magenta
00C0ED  1  F8 01        		.word	$1c0+$38		;cyan
00C0EF  1  FF 01        		.word	$1ff			;white
00C0F1  1               
00C0F1  1               
00C0F1  1               ;crttab:		.byte $49, $00		;colorBorderLo/Hi
00C0F1  1               ;		.byte $C0, $00		;colorBackgroundLo	= DISP + 2
00C0F1  1               ;		.byte $FF, $01		;color00Lo		= DISP + 4
00C0F1  1               ;		.byte $3F, $01		;color00Lo		= DISP + 4
00C0F1  1               ;		.byte $00, $FC, $3F	;screenBase	3F:FC00 * 2 = 7F:F800
00C0F1  1               ;		.byte $04		;control		= DISP + 9
00C0F1  1               ;		.byte $00, $00		;cursorLo/Hi		= DISP + 10
00C0F1  1               
00C0F1  1               	.ENDIF
00C0F1  1               
00C0F1  1               	.IF PLATFORM = 1
00C0F1  1               		lda #0
00C0F1  1               		sta crtcntl
00C0F1  1               
00C0F1  1               ;		ldx #3
00C0F1  1               ;		lda #$11
00C0F1  1               ;initcrt2:	sta crtcol3,x
00C0F1  1               ;		dex
00C0F1  1               ;		bpl initcrt2
00C0F1  1               
00C0F1  1               		ldx #15
00C0F1  1               initcrt1:	stx crtadr
00C0F1  1               		lda crtset,x
00C0F1  1               		sta crtdata
00C0F1  1               		dex
00C0F1  1               		bpl initcrt1
00C0F1  1               
00C0F1  1               ;		jsr jtime
00C0F1  1               
00C0F1  1               		ldx #$ff
00C0F1  1               		stx crtcol1		;foreground
00C0F1  1               		stx crtcol2		;not used
00C0F1  1               
00C0F1  1               		ldx #$14		;background
00C0F1  1               		stx crtcol0
00C0F1  1               		ldx #$24
00C0F1  1               		stx crtcolb		;border
00C0F1  1               
00C0F1  1               ;		jmp jtime
00C0F1  1               
00C0F1  1               clrcrt:		stz SCRSTRT		;clear first byte
00C0F1  1               		lda #1
00C0F1  1               		sta MEMCNTL
00C0F1  1               
00C0F1  1               		rep #M+IX
00C0F1  1               
00C0F1  1               		lda #(NUMROWS*640)-2
00C0F1  1               		ldx #SCRSTRT-$8000
00C0F1  1               		txy
00C0F1  1               		iny
00C0F1  1               		mvn $0,$0
00C0F1  1               		sep #M+IX
00C0F1  1               		stz MEMCNTL
00C0F1  1               		rts
00C0F1  1               	.ENDIF
00C0F1  1               
00C0F1  1               ;
00C0F1  1               ;
00C0F1  1               ;
00C0F1  1  48           SPACE:		pha
00C0F2  1  A9 20        		lda #CSPACE
00C0F4  1  20 83 DA     SPACE1:		jsr EOUTCH
00C0F7  1  68           		pla
00C0F8  1  60           		rts
00C0F9  1               
00C0F9  1               	.IF PLATFORM > 1
00C0F9  1               NEWLINE:	pha
00C0F9  1               		lda #EOL
00C0F9  1               		bne SPACE1
00C0F9  1               
00C0F9  1               PUTHEX:		PHA
00C0F9  1               		TXA
00C0F9  1               		PHA
00C0F9  1               		TYA
00C0F9  1               		PHA
00C0F9  1               
00C0F9  1               		TSX
00C0F9  1               		LDA $103,X
00C0F9  1               		PHA
00C0F9  1               		LSR
00C0F9  1               		LSR
00C0F9  1               		LSR
00C0F9  1               		LSR
00C0F9  1               		JSR PUTNIB
00C0F9  1               
00C0F9  1               		PLA
00C0F9  1               		AND #15
00C0F9  1               		JSR PUTNIB
00C0F9  1               
00C0F9  1               		PLA
00C0F9  1               		TAY
00C0F9  1               		PLA
00C0F9  1               		TAX
00C0F9  1               		PLA
00C0F9  1               		RTS
00C0F9  1               
00C0F9  1               PUTNIB:		CMP #10
00C0F9  1               		BCC PUTNIB1
00C0F9  1               		ADC #6
00C0F9  1               PUTNIB1:	ADC #48
00C0F9  1               
00C0F9  1               EOUTCH:		PHA
00C0F9  1               		TXA
00C0F9  1               		PHA
00C0F9  1               		TYA
00C0F9  1               		PHA
00C0F9  1               
00C0F9  1               		TSX
00C0F9  1               		LDA $103,x
00C0F9  1               		jsr EOUTCALL
00C0F9  1               
00C0F9  1               		PLA
00C0F9  1               		TAY
00C0F9  1               		PLA
00C0F9  1               		TAX
00C0F9  1               		PLA
00C0F9  1               		RTS
00C0F9  1               
00C0F9  1               EOUTCALL:	TAX
00C0F9  1               		LDA #>(EPB-1)
00C0F9  1               		PHA
00C0F9  1               		LDA #<(EPB-1)
00C0F9  1               		PHA
00C0F9  1               		TXA
00C0F9  1               		RTS
00C0F9  1               
00C0F9  1               	.ENDIF
00C0F9  1               
00C0F9  1               ;
00C0F9  1               ;
00C0F9  1               ;
00C0F9  1               
00C0F9  1               sdInit:
00C0F9  1               	.IF SOFTDISK=1
00C0F9  1  60           		rts
00C0FA  1               	.ELSE
00C0FA  1               		jsr deselect
00C0FA  1               		lda #CLS
00C0FA  1               		jsr EOUTCH
00C0FA  1               		ldx #12
00C0FA  1               		jsr readByteX1
00C0FA  1               
00C0FA  1               ;		jsr jtime
00C0FA  1               ;
00C0FA  1               ; CMD0 - Go Idle
00C0FA  1               ;
00C0FA  1               	.IF PLATFORM = 0
00C0FA  1               		lda #150
00C0FA  1               		sta SPICNTL
00C0FA  1               	.ENDIF
00C0FA  1               		jsr clradr
00C0FA  1               		lda #CMD0CHK
00C0FA  1               		sta sdchk
00C0FA  1               sdInit1:	lda #CMD0
00C0FA  1               		jsr cardcmd
00C0FA  1               		cmp #R1_IDLE_STATE
00C0FA  1               		beq sdInit2
00C0FA  1               		bne sdInit
00C0FA  1               ;
00C0FA  1               ; try CMD8
00C0FA  1               ;
00C0FA  1               sdInit2:	jsr clradr
00C0FA  1               		lda #01
00C0FA  1               		sta sdadr+2
00C0FA  1               		lda #$aa
00C0FA  1               		sta sdadr+3
00C0FA  1               		lda #CMD8CHK
00C0FA  1               		sta sdchk
00C0FA  1               		lda #CMD8
00C0FA  1               		jsr cardcmd
00C0FA  1               		and #R1_ILLEGAL_COMMAND
00C0FA  1               ;		cmp #R1_ILLEGAL_COMMAND
00C0FA  1               		bne sdInit3
00C0FA  1               
00C0FA  1               		ldx #3
00C0FA  1               		jsr readByteX
00C0FA  1               
00C0FA  1               ;
00C0FA  1               ; ACMD41 = CMD55 + CMD41
00C0FA  1               ;
00C0FA  1               sdInit3:	lda #64
00C0FA  1               		sta HOLD2
00C0FA  1               
00C0FA  1               sdInit6:	jsr deselect
00C0FA  1               		jsr clradr
00C0FA  1               		lda #CMD55
00C0FA  1               		jsr cardcmd
00C0FA  1               
00C0FA  1               		lda #$40
00C0FA  1               		sta sdadr
00C0FA  1               		lda #CMD41
00C0FA  1               		jsr cardcmd
00C0FA  1               		beq sdInit4		;result not 0, start over
00C0FA  1               		lda #CCUP
00C0FA  1               		jsr EOUTCH
00C0FA  1               		jsr EOUTCH
00C0FA  1               ;		dec HOLD2
00C0FA  1               		bra sdInit6
00C0FA  1               ;		bne sdInit6
00C0FA  1               ;		beq sdInit
00C0FA  1               
00C0FA  1               sdInit4:	jsr deselect
00C0FA  1               		lda #CMD58		;read OCR, ($3A)
00C0FA  1               		sta sdcmd
00C0FA  1               		jsr cardcmd
00C0FA  1               		bne sdInit9
00C0FA  1               
00C0FA  1               		ldx #3
00C0FA  1               		jsr readByteX
00C0FA  1               
00C0FA  1               ;
00C0FA  1               ; CMD9 - Read CSD
00C0FA  1               ;
00C0FA  1               sdInit5:	lda #CMD9		;read CSD
00C0FA  1               		jsr cardcmd
00C0FA  1               
00C0FA  1               		jsr waitdata
00C0FA  1               
00C0FA  1               		ldx #15			;read 16 bytes
00C0FA  1               		jsr readByteX
00C0FA  1               
00C0FA  1               sdInit9:	jsr deselect
00C0FA  1               
00C0FA  1               	.IF PLATFORM = 0
00C0FA  1               		lda #2
00C0FA  1               		sta SPICNTL
00C0FA  1               	.ENDIF
00C0FA  1               		rts
00C0FA  1               	.ENDIF
00C0FA  1               ;
00C0FA  1               ;muss mit N-Flag=0 verlassen werden!
00C0FA  1               ;
00C0FA  1               setSector:
00C0FA  1               	.IF SOFTDISK=1
00C0FA  1  8F E9 FF FF  		sta SECPTRHI
00C0FE  1  8A           		txa
00C0FF  1  8F E8 FF FF  		sta SECPTRLO
00C103  1  60           		rts
00C104  1               	.ELSE
00C104  1               		stx SECPTR
00C104  1               		sta SECPTR+1
00C104  1               		ldy #0
00C104  1               		ldx #3
00C104  1               		sty sdadr+3
00C104  1               		clc
00C104  1               setSector1:	lda (SECPTR),y
00C104  1               		rol
00C104  1               		sta sdadr-1,x
00C104  1               		iny
00C104  1               		dex
00C104  1               		bne setSector1
00C104  1               		rts
00C104  1               	.ENDIF
00C104  1               ;
00C104  1               ;
00C104  1               ;
00C104  1  A2 00        printSDadr:	ldx #0
00C106  1  BD 53 02     printSDadr1:	lda sdadr,x
00C109  1  20 0C E0     		jsr jprinthex
00C10C  1  E8           		inx
00C10D  1  E0 04        		cpx #4
00C10F  1  D0 F5        		bne printSDadr1
00C111  1  4C 1B E0     		jmp jspace
00C114  1               
00C114  1  A2 00        printBuf:	ldx #0
00C116  1  A5 0D        printBuf1:	lda SECPTR+1
00C118  1  20 0C E0     		jsr jprinthex
00C11B  1  A5 0C        		lda SECPTR
00C11D  1  20 0C E0     		jsr jprinthex
00C120  1  4C 1B E0     		jmp jspace
00C123  1               ;
00C123  1               ;
00C123  1               ;
00C123  1               readSector:
00C123  1               	.IF SOFTDISK=1
00C123  1  8F EC FF FF  		sta BUFPTRHI
00C127  1  8A           		txa
00C128  1  8F EB FF FF  		sta BUFPTRLO
00C12C  1  AF EA FF FF  		lda READWRITE
00C130  1  A0 01        		ldy #1
00C132  1  60           		rts
00C133  1               	.ELSE
00C133  1               		stx SECPTR
00C133  1               		sta SECPTR+1
00C133  1               
00C133  1               ;		jsr jnewline
00C133  1               ;		lda #'R'
00C133  1               ;		jsr jchrout
00C133  1               ;		jsr jspace
00C133  1               ;		jsr printSDadr
00C133  1               
00C133  1               		lda #CMD17
00C133  1               		jsr cardcmd
00C133  1               
00C133  1               		jsr waitdata
00C133  1               
00C133  1               		ldy #0
00C133  1               		jsr read256
00C133  1               		inc SECPTR+1
00C133  1               		jsr read256
00C133  1               
00C133  1               		ldx #1		;2-byte CRC
00C133  1               		jsr readByteX
00C133  1               		jsr deselect
00C133  1               		ldy #0
00C133  1               		rts
00C133  1               
00C133  1               read256:
00C133  1               	.IF PLATFORM = 0
00C133  1               ;		lda #$ff
00C133  1               		sta SPISTAT
00C133  1               read256a:	lda SPISTAT
00C133  1               		bne read256a
00C133  1               	;	nop
00C133  1               		lda SPIDAT
00C133  1               	.ENDIF
00C133  1               
00C133  1               	.IF PLATFORM = 1
00C133  1               		lda SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               		asl
00C133  1               		ora SPIDATA
00C133  1               	.ENDIF
00C133  1               		sta (SECPTR),y
00C133  1               		iny
00C133  1               		bne read256
00C133  1               		rts
00C133  1               	.ENDIF
00C133  1               ;
00C133  1               ;
00C133  1               ;
00C133  1               writeSector:
00C133  1               	.IF SOFTDISK=1
00C133  1  8F EC FF FF  		sta BUFPTRHI
00C137  1  8A           		txa
00C138  1  8F EB FF FF  		sta BUFPTRLO
00C13C  1  8F EA FF FF  		sta READWRITE
00C140  1  A0 01        		ldy #1
00C142  1  60           		rts
00C143  1               	.ELSE
00C143  1               		stx SECPTR
00C143  1               		sta SECPTR+1
00C143  1               
00C143  1               ;		jsr jnewline
00C143  1               ;		lda #'W'
00C143  1               ;		jsr jchrout
00C143  1               ;		jsr jspace
00C143  1               ;		jsr printSDadr
00C143  1               
00C143  1               		lda #CMD24		; write Sector
00C143  1               		jsr cardcmd
00C143  1               
00C143  1               	.IF PLATFORM = 1
00C143  1               		lda #0
00C143  1               		sta SPIMOSI		; CS\ and MOSImask=0
00C143  1               	.ENDIF
00C143  1               		lda #DATA_START_BLOCK
00C143  1               		jsr sendbyte
00C143  1               
00C143  1               		ldy #0
00C143  1               writeSector1:	lda (SECPTR),y
00C143  1               		jsr sendbyte
00C143  1               		iny
00C143  1               		bne writeSector1
00C143  1               
00C143  1               		inc SECPTR+1
00C143  1               
00C143  1               writeSector2:	lda (SECPTR),y
00C143  1               		jsr sendbyte
00C143  1               		iny
00C143  1               		bne writeSector2
00C143  1               
00C143  1               		jsr readbyte		; send two bytes CRC
00C143  1               		jsr readbyte
00C143  1               		jsr readbyte		; get data-response token
00C143  1               		and #DATA_RES_MASK
00C143  1               		cmp #DATA_RES_ACCEPTED	; "00000101" = 5 ?
00C143  1               		bne writeerror		; no -> error
00C143  1               
00C143  1               		lda #CMD13		; get Status
00C143  1               		jsr cardcmd
00C143  1               		jsr readbyte
00C143  1               		bne writeerror
00C143  1               
00C143  1               		jsr deselect		; all OK, deselect card
00C143  1               		clc			; and quit with carry clear
00C143  1               		rts
00C143  1               
00C143  1               writeerror:	jsr deselect		; an error occured
00C143  1               		sec			; quit with carry set
00C143  1               		rts
00C143  1               
00C143  1               waitready:	jsr readbyte		; read until sdcard
00C143  1               		cmp #$ff		; sends #$FF
00C143  1               		bne waitready
00C143  1               		rts
00C143  1               
00C143  1               waitdata:	jsr readbyte
00C143  1               		and #1
00C143  1               		bne waitdata
00C143  1               		rts
00C143  1               
00C143  1               cardcmd:	sta sdcmd
00C143  1               		sta sddebug
00C143  1               		cmp #CMD13
00C143  1               		beq cardcmd3
00C143  1               		cmp #CMD17
00C143  1               		beq cardcmd3
00C143  1               		cmp #CMD24
00C143  1               		beq cardcmd3
00C143  1               		lda #0
00C143  1               		sta sddebug
00C143  1               
00C143  1               		jsr printCMD
00C143  1               
00C143  1               cardcmd3:
00C143  1               	.IF PLATFORM = 0
00C143  1               		jsr select
00C143  1               	.ENDIF
00C143  1               		jsr waitready	;also selects SD card
00C143  1               
00C143  1               
00C143  1               		ldx #0
00C143  1               	.IF PLATFORM = 1
00C143  1               		stx SPIMOSI		; CS\ and MOSImask=0
00C143  1               	.ENDIF
00C143  1               cardcmd1:	lda sdcmd,x
00C143  1               		jsr sendbyte
00C143  1               		inx
00C143  1               		cpx #6
00C143  1               		bne cardcmd1
00C143  1               
00C143  1               cardcmd2:	jsr readbyte
00C143  1               		bmi cardcmd2
00C143  1               		ldx sddebug
00C143  1               		beq cardcmd4
00C143  1               		rts
00C143  1               cardcmd4:	jsr PUTHEX
00C143  1               		jmp NEWLINE
00C143  1               
00C143  1               printCMD:	lda #'C'
00C143  1               		jsr EOUTCH
00C143  1               		lda sdcmd
00C143  1               		sec
00C143  1               		sbc #$40
00C143  1               		jsr PUTHEX
00C143  1               		jsr SPACE
00C143  1               		lda #'R'
00C143  1               		jmp EOUTCH
00C143  1               
00C143  1               ;
00C143  1               ; read Reg-X number of bytes
00C143  1               ;
00C143  1               readByteX:
00C143  1               	.IF PLATFORM = 0
00C143  1               		lda #0
00C143  1               		sta SPISS
00C143  1               	.ENDIF
00C143  1               
00C143  1               	.IF PLATFORM = 1
00C143  1               		lda #1
00C143  1               		sta SPIMOSI		; CS\ and MOSImask=0
00C143  1               	.ENDIF
00C143  1               readByteX1:	jsr readbyte1
00C143  1               		dex
00C143  1               		bpl readByteX1
00C143  1               		rts
00C143  1               
00C143  1               readbyte:
00C143  1               	.IF PLATFORM = 0
00C143  1               readbyte1:
00C143  1               		lda #$FF
00C143  1               sendbyte:	sta SPIDAT
00C143  1               readbyte2:	lda SPISTAT
00C143  1               		bne readbyte2
00C143  1               		lda SPIDAT
00C143  1               		rts
00C143  1               	.ENDIF
00C143  1               
00C143  1               	.IF PLATFORM = 1
00C143  1               		lda #1
00C143  1               		sta SPIMOSI		; CS\ and MOSImask=0
00C143  1               
00C143  1               readbyte1:	lda SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		asl
00C143  1               		ora SPIDATA
00C143  1               		rts
00C143  1               
00C143  1               sendbyte:	sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		asl
00C143  1               		sta SPIDATA
00C143  1               		rts
00C143  1               	.ENDIF
00C143  1               
00C143  1               	.IF PLATFORM = 0
00C143  1               deselect:	lda #1
00C143  1               		sta SPISS
00C143  1               		jmp readbyte1
00C143  1               
00C143  1               select:		lda #0
00C143  1               		sta SPISS
00C143  1               		rts
00C143  1               	.ENDIF
00C143  1               
00C143  1               	.IF PLATFORM = 1
00C143  1               deselect:	lda #3
00C143  1               		sta SPIMOSI
00C143  1               		jmp readbyte1
00C143  1               
00C143  1               select:		lda #1
00C143  1               		sta SPIMOSI
00C143  1               		rts
00C143  1               	.ENDIF
00C143  1               
00C143  1               ;debug:		ldx #0
00C143  1               ;debug1:		lda sdcmd,x
00C143  1               ;		jsr jprinthex
00C143  1               ;		jsr jspace
00C143  1               ;		inx
00C143  1               ;		cpx #7
00C143  1               ;		bne debug1
00C143  1               ;		jsr jnewline
00C143  1               ;		rts
00C143  1               
00C143  1               clradr:		ldx #3
00C143  1               		lda #0
00C143  1               clradr1:	sta sdadr,x
00C143  1               		dex
00C143  1               		bpl clradr1
00C143  1               		rts
00C143  1               	.ENDIF
00C143  1               
00C143  1               ;;	IGN - Ignore Character and Perform Keyboard GET-BYT:
00C143  1               ;
00C143  1               ;	ENTRY	JSR	IGN
00C143  1               ;
00C143  1               ;	EXIT
00C143  1               ;		CH = $FF
00C143  1               ;
00C143  1               ;	MODS
00C143  1               ;		Original Author Unknown
00C143  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C143  1               ;		   R. K. Nordin	11/01/83
00C143  1               
00C143  1               IGN:	;=	;	;entry
00C143  1               ;	LDA	#$FF	;clear code indicator
00C143  1               ;	STA	CH	;key code
00C143  1               ;	JMP	KGB	;perform keyboard GET-BYTE, return
00C143  1               
00C143  1               ;;	KGB - Perform Keyboard GET-BYTE
00C143  1               ;
00C143  1               ;	ENTRY	JSR	KGB
00C143  1               ;
00C143  1  AD 2D 03     KGB:		lda IRQPS2S	;key available?
00C146  1  D0 FB        		bne KGB		;Bit 0 = 0?, no =>
00C148  1  EE 2D 03     		inc IRQPS2S
00C14B  1               
00C14B  1  A0 01        		ldy #SUCCES
00C14D  1  84 32        		sty DSTAT
00C14F  1  AD 2E 03     		lda IRQPS2D
00C152  1  8D 40 02     		sta ATACHR
00C155  1  60           		rts
00C156  1               
00C156  1               
00C156  1               
00C156  1               ;;	ICIO - Initialize CIO
00C156  1               ;
00C156  1               ;	ENTRY	JSR	ICIO
00C156  1               ;
00C156  1               ;	MODS
00C156  1               ;		Original Author Unknown
00C156  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C156  1               ;		   R. K. Nordin	11/01/83
00C156  1               
00C156  1               
00C156  1               ICIO:	;=	*		;entry
00C156  1               
00C156  1               ;	Initialize IOCB's.
00C156  1               
00C156  1  A2 00        	LDX	#0		;index of first IOCB
00C158  1               
00C158  1  A9 FF        ICIO1:	LDA	#IOCFRE		;IOCB free indicator
00C15A  1  9D 80 02     	STA	ICHID,X		;set IOCB free
00C15D  1               ;	LDA	#<(IIN-1)
00C15D  1               ;	STA	ICPTL,X		;initialize PUT-BYTE routine address
00C15D  1               ;	LDA	#>(IIN-1)
00C15D  1               ;	STA	ICPTH,X
00C15D  1  8A           	TXA			;index of current IOCB
00C15E  1  18           	CLC
00C15F  1  69 10        	ADC	#IOCBSZ		;add IOCB size
00C161  1  AA           	TAX			;index of next IOCB
00C162  1  C9 80        	CMP	#MAXIOC		;index of first invalid IOCB
00C164  1  90 F2        	BCC	ICIO1		;if not done
00C166  1               
00C166  1  60           	RTS			;return
00C167  1               ;	SPACE	4,10
00C167  1               ;;	IIN - Indicate IOCB Not Open Error
00C167  1               ;
00C167  1               ;	ENTRY	JSR	IIN
00C167  1               ;
00C167  1               ;	EXIT
00C167  1               ;		Y = IOCB Not Open error code
00C167  1               ;
00C167  1               ;	MODS
00C167  1               ;		Original Author Unknown
00C167  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C167  1               ;		   R. K. Nordin	11/01/83
00C167  1               
00C167  1               
00C167  1               IIN:	;=	;	;entry
00C167  1  A0 85        	LDY	#NOTOPN	;IOCB not open error
00C169  1  60           	RTS		;return
00C16A  1               ;	SPACE	4,10
00C16A  1               ;;	CIO - Central Input/Output
00C16A  1               ;
00C16A  1               ;	ENTRY	JSR	CIO
00C16A  1               ;
00C16A  1               ;	MODS
00C16A  1               ;		Original Author Unknown
00C16A  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C16A  1               ;		   R. K. Nordin	11/01/83
00C16A  1               
00C16A  1  20 6E C1     CIO24:	jsr	CIO
00C16D  1  6B           	rtl
00C16E  1               
00C16E  1               CIO:	;=	*	;entry
00C16E  1               	.IF PLATFORM=0
00C16E  1  08           	php
00C16F  1  0B           	phd
00C170  1  8B           	phb
00C171  1  E2 30        	sep	#M+IX
00C173  1  F4 00 00     	pea	0	;set direct to zero-page
00C176  1  2B           	pld
00C177  1  4B           	phk		;set program-bank to zero
00C178  1  AB           	plb
00C179  1               	.ENDIF
00C179  1               
00C179  1               ;	Initialize.
00C179  1               
00C179  1  85 2F        	STA	CIOCHR	;save possible output byte value
00C17B  1  86 2E        	STX	ICIDNO	;save IOCB index
00C17D  1               
00C17D  1               ;	Check IOCB index validity.
00C17D  1               
00C17D  1  8A           	TXA		;IOCB index
00C17E  1  29 0F        	AND	#$0F	;index modulo 16
00C180  1  D0 04        	BNE	CIO1	;if IOCB not multiple of 16, error
00C182  1               
00C182  1  E0 80        	CPX	#MAXIOC	;index of first invalid IOCB
00C184  1  90 05        	BCC	CIO2	;if index within range
00C186  1               
00C186  1               ;	Indicate Invalid IOCB Index error.
00C186  1               
00C186  1  A0 86        CIO1:	LDY	#BADIOC	;invalid IOCB index error
00C188  1  4C D5 C2     	JMP	SSC	;set status and complete operation, return
00C18B  1               
00C18B  1               ;	Move part of IOCB to zero page IOCB.
00C18B  1               
00C18B  1  A0 00        CIO2:	LDY	#0		;offset to first byte of page zero IOCB
00C18D  1               
00C18D  1  BD 80 02     CIO3:	LDA	IOCB,X		;byte of IOCB
00C190  1  99 20 00     	STA	IOCBAS,Y	;byte of zero page IOCB
00C193  1  E8           	INX
00C194  1  C8           	INY
00C195  1  C0 0C        	CPY	#ICSPRZ-IOCBAS	;offset to first undesired byte
00C197  1  90 F4        	BCC	CIO3		;if not done
00C199  1               
00C199  1               ;	Check for provisionally open IOCB.
00C199  1               
00C199  1               ;	LDA	ICHIDZ	;handler ID
00C199  1               ;	CMP	#$7F	;provisionally open indicator
00C199  1               ;	BNE	PCC	;if not provisionally open, perform:
00C199  1  4C 9C C1     	jmp 	PCC
00C19C  1               ;	Check for CLOSE command.
00C19C  1               
00C19C  1               ;	LDA	ICCOMZ	;command
00C19C  1               ;	CMP	#CLOSE
00C19C  1               ;	BEQ	XCL	;if CLOSE command
00C19C  1               
00C19C  1               ;	Check handler load flag.
00C19C  1               
00C19C  1               ;	LDA	HNDLOD
00C19C  1               ;	BNE	LHO	;if handler load desired
00C19C  1               
00C19C  1               ;	Indicate nonexistent device error.
00C19C  1               
00C19C  1               ;	JMP	IND	;indicate nonexistent device error,:
00C19C  1               ;	SPACE	4,10
00C19C  1               ;;	IND - Indicate Nonexistent Device Error
00C19C  1               ;
00C19C  1               ;	ENTRY	JSR	IND
00C19C  1               ;
00C19C  1               ;	MODS
00C19C  1               ;		Original Author Unknown
00C19C  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C19C  1               ;		   R. K. Nordin	11/01/83
00C19C  1               
00C19C  1               
00C19C  1               ;IND:	;=	*	;entry
00C19C  1               ;	LDY	#NONDEV	;nonexistent device error
00C19C  1               
00C19C  1               ;IND1:	JMP	SSC	;set status and complete operation,:
00C19C  1               ;	SPACE	4,10
00C19C  1               ;;	LHO - Load Peripheral Handler for OPEN
00C19C  1               ;
00C19C  1               ;	ENTRY	JSR	LHO
00C19C  1               ;
00C19C  1               ;	MODS
00C19C  1               ;		Original Author Unknown
00C19C  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C19C  1               ;		   R. K. Nordin	11/01/83
00C19C  1               
00C19C  1               
00C19C  1               ;LHO:	;=	;	;entry
00C19C  1               ;	JSR	PHL	;load and initialize peripheral han:
00C19C  1               ;	BMI	IND1	;if error
00C19C  1               
00C19C  1               ;	JMP	PCC	;perform CIO command, return
00C19C  1               ;	SPACE	4,10
00C19C  1               ;;	PCC - Perform CIO Command
00C19C  1               ;
00C19C  1               ;	ENTRY	JSR	PCC
00C19C  1               ;
00C19C  1               ;	MODS
00C19C  1               ;		Original Author Unknown
00C19C  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C19C  1               ;		   R. K. Nordin	11/01/83
00C19C  1               
00C19C  1               
00C19C  1               PCC:	;=	;	;entry
00C19C  1               
00C19C  1               ;	Check command validity.
00C19C  1               
00C19C  1  A0 84        	LDY	#NVALID		;assume invalid code
00C19E  1  A5 22        	LDA	ICCOMZ		;command
00C1A0  1  C9 03        	CMP	#OPEN		;first valid command
00C1A2  1  90 25        	BCC	XOP1		;if command invalid
00C1A4  1               
00C1A4  1  A8           	TAY			;command
00C1A5  1               
00C1A5  1  C0 0E        	CPY	#SPECIL		;last valid command
00C1A7  1  90 02        	BCC	PCC1		;if valid
00C1A9  1               
00C1A9  1  A0 0E        	LDY	#SPECIL		;substitute SPECIAL command
00C1AB  1               
00C1AB  1               ;	Obtain vector offset.
00C1AB  1               
00C1AB  1  84 31        PCC1:	STY	ICCOMT		;save command
00C1AD  1  B9 C1 C3     	LDA	TCVO-3,Y	;vector offset for command
00C1B0  1  F0 0F        	BEQ	XOP		;if OPEN command, process
00C1B2  1               
00C1B2  1               ;	Perform command.
00C1B2  1               
00C1B2  1  C9 02        	CMP	#2
00C1B4  1  F0 33        	BEQ	XCL		;if CLOSE command, process
00C1B6  1               
00C1B6  1  C9 08        	CMP	#8
00C1B8  1  B0 42        	BCS	XSS		;if STATUS or SPECIAL command, process
00C1BA  1               
00C1BA  1  C9 04        	CMP	#4
00C1BC  1  F0 59        	BEQ	XGT		;if GET command, process
00C1BE  1               
00C1BE  1  4C 81 C2     	JMP	XPT		;process PUT command, process
00C1C1  1               ;	SPACE	4,10
00C1C1  1               ;;	XOP - Execute OPEN Command
00C1C1  1               ;
00C1C1  1               ;	ENTRY	JSR	XOP
00C1C1  1               ;
00C1C1  1               ;	MODS
00C1C1  1               ;		Original Author Unknown
00C1C1  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C1C1  1               ;		   R. K. Nordin	11/01/83
00C1C1  1               
00C1C1  1               
00C1C1  1               XOP:	;=	;	;entry
00C1C1  1               
00C1C1  1               ;	Check IOCB free.
00C1C1  1               
00C1C1  1  A5 20        	LDA	ICHIDZ	;handler ID
00C1C3  1  C9 FF        	CMP	#IOCFRE	;IOCB free indicator
00C1C5  1  F0 05        	BEQ	XOP2	;if IOCB free
00C1C7  1               
00C1C7  1               ;	Process error.
00C1C7  1               
00C1C7  1  A0 81        	LDY	#PRVOPN	;IOCB previously open error
00C1C9  1               
00C1C9  1  4C D5 C2     XOP1:	JMP	SSC	;set status and complete operation, return
00C1CC  1               
00C1CC  1               ;	Check handler load.
00C1CC  1               
00C1CC  1               XOP2:	;LDA	HNDLOD
00C1CC  1               	;BNE	PPO	;if user wants unconditional poll
00C1CC  1               
00C1CC  1               ;	Search handler table.
00C1CC  1               
00C1CC  1  20 8E C3     	JSR	SHT	;search handler table
00C1CF  1  90 05        	bcc	XOP3
00C1D1  1               
00C1D1  1               ;	BCS	PPO	;if not found, poll
00C1D1  1               
00C1D1  1  A0 82        	ldy	#NONDEV
00C1D3  1  4C D5 C2     	JMP	SSC
00C1D6  1               
00C1D6  1               ;	Initialize status.
00C1D6  1               
00C1D6  1  A9 00        XOP3:	LDA	#0
00C1D8  1  8D 33 02     	STA	DVSTAT	;clear status
00C1DB  1  8D 34 02     	STA	DVSTAT+1
00C1DE  1               
00C1DE  1               ;	Initialize IOCB.
00C1DE  1               
00C1DE  1               ;	JMP	IIO	;initialize IOCB for OPEN, return
00C1DE  1               ;	SPACE	4,10
00C1DE  1               ;;	IIO - Initialize IOCB for OPEN
00C1DE  1               ;
00C1DE  1               ;	ENTRY	JSR	IIO
00C1DE  1               ;
00C1DE  1               ;	MODS
00C1DE  1               ;		Original Author Unknown
00C1DE  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C1DE  1               ;		   R. K. Nordin	11/01/83
00C1DE  1               
00C1DE  1               
00C1DE  1               IIO:	;=	;	;entry
00C1DE  1               
00C1DE  1               ;	Compute handler entry point.
00C1DE  1               
00C1DE  1  20 0B C3     	JSR	CEP	;compute handler entry point
00C1E1  1  B0 E6        	BCS	XOP1	;if error
00C1E3  1               
00C1E3  1               ;	Execute command.
00C1E3  1               
00C1E3  1  20 79 C3     	JSR	EHC	;execute handler command
00C1E6  1               
00C1E6  1               ;	Set PUT-BYTE routine address in IOCB.
00C1E6  1               
00C1E6  1               ;	LDA	#PUTCHR
00C1E6  1               ;	STA	ICCOMT	;command
00C1E6  1               ;	JSR	CEP	;compute handler entry point
00C1E6  1               ;	LDA	ICSPRZ	;PUT-BYTE routine address
00C1E6  1               ;	STA	ICPTLZ	;IOCB PUT-BYTE routine address
00C1E6  1               ;	LDA	ICSPRZ+1
00C1E6  1               ;	STA	ICPTHZ
00C1E6  1               
00C1E6  1  4C D7 C2     	JMP	CCO	;complete CIO operation, return
00C1E9  1               ;	SPACE	4,10
00C1E9  1               ;;	PPO - Peripheral for OPEN
00C1E9  1               ;
00C1E9  1               ;	ENTRY	JSR	PPO
00C1E9  1               ;
00C1E9  1               ;	MODS
00C1E9  1               ;		Original Author Unknown
00C1E9  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C1E9  1               ;		   R. K. Nordin	11/01/83
00C1E9  1               
00C1E9  1               
00C1E9  1               ;PPO:	;=	*	;entry
00C1E9  1               ;	JSR	PHO	;poll
00C1E9  1               ;	JMP	SSC	;set status and complete operation,:
00C1E9  1               ;	SPACE	4,10
00C1E9  1               ;;	XCL - Execute CLOSE Command
00C1E9  1               ;
00C1E9  1               ;	ENTRY	JSR	XCL
00C1E9  1               ;
00C1E9  1               ;	MODS
00C1E9  1               ;		Original Author Unknown
00C1E9  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C1E9  1               ;		   R. K. Nordin	11/01/83
00C1E9  1               
00C1E9  1               
00C1E9  1               XCL:	;=	;		;entry
00C1E9  1               
00C1E9  1               ;	Initialize.
00C1E9  1               
00C1E9  1  A0 01        	LDY	#SUCCES		;assume success
00C1EB  1  84 23        	STY	ICSTAZ		;status
00C1ED  1  20 0B C3     	JSR	CEP		;compute handler entry point
00C1F0  1  B0 03        	BCS	XCL1		;if error
00C1F2  1               
00C1F2  1               ;	Execute command.
00C1F2  1               
00C1F2  1               
00C1F2  1  20 79 C3     	JSR	EHC		;execute handler command
00C1F5  1               
00C1F5  1               ;	Close IOCB.
00C1F5  1               
00C1F5  1  A9 FF        XCL1:	LDA	#IOCFRE		;IOCB free indicator
00C1F7  1  85 20        	STA	ICHIDZ		;indicate IOCB free
00C1F9  1               ;	LDA	#>(IIN-1)
00C1F9  1               ;	STA	ICPTHZ		;reset initial PUT-BYTE routine address
00C1F9  1               ;	LDA	#<(IIN-1)
00C1F9  1               ;	STA	ICPTLZ
00C1F9  1  4C D7 C2     	JMP	CCO		;complete CIO operation, return
00C1FC  1               ;	SPACE	4,10
00C1FC  1               ;;	XSS - Execute STATUS and SPECIAL Commands
00C1FC  1               ;
00C1FC  1               ;	???word about implicit OPEN and CLOSE.
00C1FC  1               ;
00C1FC  1               ;	ENTRY	JSR	XSS
00C1FC  1               ;
00C1FC  1               ;	MODS
00C1FC  1               ;		Original Author Unknown
00C1FC  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C1FC  1               ;		   R. K. Nordin	11/01/83
00C1FC  1               
00C1FC  1               
00C1FC  1               XSS:	;=	*	;entry
00C1FC  1               
00C1FC  1               ;	Check IOCB free.
00C1FC  1               
00C1FC  1  A5 20        	LDA	ICHIDZ	;handler ID
00C1FE  1  C9 FF        	CMP	#IOCFRE
00C200  1  D0 05        	BNE	XSS1	;if IOCB not free
00C202  1               
00C202  1               ;	Open IOCB.
00C202  1               
00C202  1  20 8E C3     	JSR	SHT	;search handler table
00C205  1  B0 C2        	BCS	XOP1	;if error
00C207  1               
00C207  1               ;	Execute command.
00C207  1               
00C207  1  20 0B C3     XSS1:	JSR	CEP	;compute handler entry point
00C20A  1  20 79 C3     	JSR	EHC	;execute handler command
00C20D  1               
00C20D  1               ;	Restore handler ID, in case IOCB implicitly opened.
00C20D  1               
00C20D  1  A6 2E        	LDX	ICIDNO	;IOCB index
00C20F  1  BD 80 02     	LDA	ICHID,X	;original handler ID
00C212  1  85 20        	STA	ICHIDZ	;restore zero page handler ID
00C214  1  4C D7 C2     	JMP	CCO	;complete CIO operation, return
00C217  1               ;	SPACE	4,10
00C217  1               ;;	XGT - Execute GET Command
00C217  1               ;
00C217  1               ;	ENTRY	JSR	XGT
00C217  1               ;
00C217  1               ;	MODS
00C217  1               ;		Original Author Unknown
00C217  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C217  1               ;		   R. K. Nordin	11/01/83
00C217  1               
00C217  1               
00C217  1               XGT:	;=	;	;entry
00C217  1               
00C217  1               ;	Check GET validity.
00C217  1               
00C217  1  A5 22        	LDA	ICCOMZ	;command
00C219  1  25 2A        	AND	ICAX1Z	;???
00C21B  1  D0 05        	BNE	XGT2	;if GET command valid
00C21D  1               
00C21D  1               ;	Process error.
00C21D  1               
00C21D  1  A0 83        	LDY	#WRONLY	;IOCB opened for write only error
00C21F  1               
00C21F  1  4C D5 C2     XGT1:	JMP	SSC	;set status and complete operation, return
00C222  1               
00C222  1               ;	Compute and check handler entry point.
00C222  1               
00C222  1  20 0B C3     XGT2:	JSR	CEP	;compute handler entry point
00C225  1  B0 F8        	BCS	XGT1	;if error
00C227  1               
00C227  1               ;	Check buffer length.
00C227  1               
00C227  1  A5 27        	LDA	ICBLLZ		;buffer length
00C229  1  05 28        	ORA	ICBLLZ+1
00C22B  1               	.IF PLATFORM=0
00C22B  1  05 29        	ora	ICBLLZ+2
00C22D  1               	.ENDIF
00C22D  1  D0 08        	BNE	XGT3		;if buffer length non-zero
00C22F  1               
00C22F  1               ;	Get byte.
00C22F  1               
00C22F  1               ;	lda	#'G'
00C22F  1               ;	jsr	jchrout
00C22F  1               
00C22F  1  20 79 C3     	JSR	EHC	;execute handler command
00C232  1  85 2F        	STA	CIOCHR	;data
00C234  1  4C D7 C2     	JMP	CCO	;complete CIO operation, return
00C237  1               
00C237  1               ;	Fill buffer.
00C237  1               
00C237  1  20 79 C3     XGT3:	JSR	EHC		;execute handler command
00C23A  1  85 2F        	STA	CIOCHR		;data
00C23C  1  30 3D        	BMI	XGT7		;if error, end transfer
00C23E  1               
00C23E  1               	.IF PLATFORM=0
00C23E  1  87 24        	sta	[ICBALZ]
00C240  1               	.ELSE
00C240  1               	LDY	#0
00C240  1               	STA	(ICBALZ),Y	;byte of buffer
00C240  1               	.ENDIF
00C240  1               
00C240  1  20 55 C3     	JSR	IBP		;increment buffer pointer
00C243  1  A5 22        	LDA	ICCOMZ		;command
00C245  1  29 02        	AND	#$02
00C247  1  D0 0C        	BNE	XGT4		;if GET RECORD command
00C249  1               
00C249  1               ;	Check for EOL.
00C249  1               
00C249  1  A5 2F        	LDA	CIOCHR	;data
00C24B  1  C9 0A        	CMP	#EOL
00C24D  1  D0 06        	BNE	XGT4	;if not EOL
00C24F  1               
00C24F  1               ;	Process EOL.
00C24F  1               
00C24F  1  20 31 C3     	JSR	DBL	;decrement buffer length
00C252  1  4C 7B C2     	JMP	XGT7	;clean up
00C255  1               
00C255  1               ;	Check buffer full.
00C255  1               
00C255  1  20 31 C3     XGT4:	JSR	DBL	;decrement buffer length
00C258  1  D0 DD        	BNE	XGT3	;if buffer not full, continue
00C25A  1               
00C25A  1               ;	Check command.
00C25A  1               
00C25A  1  A5 22        	LDA	ICCOMZ	;command
00C25C  1  29 02        	AND	#$02
00C25E  1  D0 1B        	BNE	XGT7	;if GET CHARACTER command, clean up
00C260  1               
00C260  1               ;	Process GET RECORD.
00C260  1               
00C260  1  20 79 C3     XGT5:	JSR	EHC	;execute handler command
00C263  1  85 2F        	STA	CIOCHR	;data
00C265  1  30 0A        	BMI	XGT6	;if error
00C267  1               
00C267  1               ;	Check for EOL.
00C267  1               
00C267  1  A5 2F        	LDA	CIOCHR	;data
00C269  1  C9 0A        	CMP	#EOL
00C26B  1  D0 F3        	BNE	XGT5	;if not EOL, continue
00C26D  1               
00C26D  1               ;	Process end of record.
00C26D  1               
00C26D  1  A9 89        	LDA	#TRNRCD	;truncated record error
00C26F  1  85 23        	STA	ICSTAZ	;status
00C271  1               
00C271  1               ;	Process error.
00C271  1               
00C271  1  20 46 C3     XGT6:	JSR	DBP		;decrement buffer pointer
00C274  1               
00C274  1  A9 0A        	LDA	#EOL
00C276  1               	.IF PLATFORM=0
00C276  1  87 24        	sta	[ICBALZ]
00C278  1               	.ELSE
00C278  1               	LDY	#0
00C278  1               	STA	(ICBALZ),Y	;set EOL in buffer
00C278  1               	.ENDIF
00C278  1               
00C278  1  20 55 C3     	JSR	IBP		;increment buffer pointer
00C27B  1               
00C27B  1               ;	Clean up.
00C27B  1               
00C27B  1  20 60 C3     XGT7:	JSR	SFL	;set final buffer length
00C27E  1  4C D7 C2     	JMP	CCO	;complete CIO operation, return
00C281  1               ;	SPACE	4,10
00C281  1               ;;	XPT - Execute PUT Command
00C281  1               ;
00C281  1               ;	ENTRY	JSR	XPT
00C281  1               ;
00C281  1               ;	MODS
00C281  1               ;		Original Author Unknown
00C281  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C281  1               ;		   R. K. Nordin	11/01/83
00C281  1               
00C281  1               
00C281  1               XPT:	;=	;	;entry
00C281  1               
00C281  1               ;	Check PUT validity.
00C281  1               
00C281  1  A5 22        	LDA	ICCOMZ	;command
00C283  1  25 2A        	AND	ICAX1Z
00C285  1  D0 05        	BNE	XPT2	;if PUT command valid
00C287  1               
00C287  1               ;	Process error.
00C287  1               
00C287  1  A0 87        	LDY	#RDONLY	;IOCB opened for read only error
00C289  1               
00C289  1  4C D5 C2     XPT1:	JMP	SSC	;set status and complete operation, return
00C28C  1               
00C28C  1               ;	Compute and check handler entry point.
00C28C  1               
00C28C  1  20 0B C3     XPT2:	JSR	CEP	;compute handler entry point
00C28F  1  B0 F8        	BCS	XPT1	;if error
00C291  1               
00C291  1               ;	Check buffer length.
00C291  1               
00C291  1  A5 27        	LDA	ICBLLZ	;buffer length
00C293  1  05 28        	ORA	ICBLLZ+1
00C295  1               	.IF PLATFORM=0
00C295  1  05 29        	ora	ICBLLZ+2
00C297  1               	.ENDIF
00C297  1  D0 06        	BNE	XPT3	;if buffer length non-zero
00C299  1               
00C299  1               ;	Put byte.
00C299  1               
00C299  1  A5 2F        	LDA	CIOCHR	;data
00C29B  1  E6 27        	INC	ICBLLZ	;set buffer length to 1
00C29D  1  D0 04        	BNE	XPT4	;transfer one byte
00C29F  1               
00C29F  1               ;	Transfer data from buffer to handler.
00C29F  1               
00C29F  1               XPT3:	.IF PLATFORM=0
00C29F  1  A7 24        	lda	[ICBALZ]
00C2A1  1               	.ELSE
00C2A1  1               	LDY	#0
00C2A1  1               	LDA	(ICBALZ),Y	;byte from buffer
00C2A1  1               	.ENDIF
00C2A1  1  85 2F        	STA	CIOCHR		;data
00C2A3  1               
00C2A3  1  20 79 C3     XPT4:	JSR	EHC		;execute handler command
00C2A6  1  08           	PHP			;save status
00C2A7  1  20 55 C3     	JSR	IBP		;increment buffer pointer
00C2AA  1  20 31 C3     	JSR	DBL		;decrement buffer length
00C2AD  1  28           	PLP			;status
00C2AE  1  30 1F        	BMI	XPT6		;if error
00C2B0  1               
00C2B0  1               ;	Check command.
00C2B0  1               
00C2B0  1  A5 22        	LDA	ICCOMZ	;command
00C2B2  1  29 02        	AND	#$02
00C2B4  1  D0 06        	BNE	XPT5	;if PUT RECORD command
00C2B6  1               
00C2B6  1               ;	Check for EOL.
00C2B6  1               
00C2B6  1  A5 2F        	LDA	CIOCHR	;data
00C2B8  1  C9 0A        	CMP	#EOL
00C2BA  1  F0 13        	BEQ	XPT6	;if EOL, clean up
00C2BC  1               
00C2BC  1               ;	Check for buffer empty.
00C2BC  1               
00C2BC  1  A5 27        XPT5:	LDA	ICBLLZ		;buffer length
00C2BE  1  05 28        	ORA	ICBLLZ+1
00C2C0  1               	.IF PLATFORM=0
00C2C0  1  05 29        	ora	ICBLLZ+2
00C2C2  1               	.ENDIF
00C2C2  1  D0 DB        	BNE	XPT3		;if buffer not empty, continue
00C2C4  1               
00C2C4  1               ;	Check command.
00C2C4  1               
00C2C4  1  A5 22        	LDA	ICCOMZ	;command
00C2C6  1  29 02        	AND	#$02
00C2C8  1  D0 05        	BNE	XPT6	;if PUT CHARACTER command
00C2CA  1               
00C2CA  1               ;	Write EOL.
00C2CA  1               
00C2CA  1  A9 0A        	LDA	#EOL
00C2CC  1  20 79 C3     	JSR	EHC	;execute handler command
00C2CF  1               
00C2CF  1               ;	Clean up.
00C2CF  1               
00C2CF  1  20 60 C3     XPT6:	JSR	SFL	;set final buffer length
00C2D2  1  4C D7 C2     	JMP	CCO	;complete CIO operation, return
00C2D5  1               ;	SPACE	4,10
00C2D5  1               ;;	SSC - Set Status and Complete Operation
00C2D5  1               ;
00C2D5  1               ;	ENTRY	JSR	SSC
00C2D5  1               ;
00C2D5  1               ;	MODS
00C2D5  1               ;		Original Author Unknown
00C2D5  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C2D5  1               ;		   R. K. Nordin	11/01/83
00C2D5  1               
00C2D5  1               
00C2D5  1               SSC:	;=	;	;entry
00C2D5  1  84 23        	STY	ICSTAZ	;status
00C2D7  1               ;	JMP	CCO	;complete CIO operation, return
00C2D7  1               ;	SPACE	4,10
00C2D7  1               
00C2D7  1               
00C2D7  1               ;;	CCO - Complete CIO Operation
00C2D7  1               ;
00C2D7  1               ;	ENTRY	JSR	CCO
00C2D7  1               ;
00C2D7  1               ;	MODS
00C2D7  1               ;		Original Author Unknown
00C2D7  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C2D7  1               ;		   R. K. Nordin	11/01/83
00C2D7  1               
00C2D7  1               
00C2D7  1               CCO:	;=	;		;entry
00C2D7  1               
00C2D7  1               ;	Initialize.
00C2D7  1               
00C2D7  1  A4 2E        	LDY	ICIDNO		;IOCB index
00C2D9  1               
00C2D9  1               ;	Restore buffer pointer.
00C2D9  1               
00C2D9  1  B9 84 02     	LDA	ICBAL,Y
00C2DC  1  85 24        	STA	ICBALZ		;restore buffer pointer
00C2DE  1  B9 85 02     	LDA	ICBAH,Y
00C2E1  1  85 25        	STA	ICBAHZ
00C2E3  1               	.IF PLATFORM=0
00C2E3  1  B9 86 02     	lda	ICBAB,Y
00C2E6  1  85 26        	sta	ICBABZ
00C2E8  1               	.ENDIF
00C2E8  1               
00C2E8  1               ;	Move part of zero page IOCB to IOCB.
00C2E8  1               
00C2E8  1  A2 00        	LDX	#0		;first byte of zero page IOCB
00C2EA  1               ;	STX	HNDLOD
00C2EA  1               
00C2EA  1  B5 20        CCO1:	LDA	IOCBAS,X	;byte of zero page IOCB
00C2EC  1  99 80 02     	STA	IOCB,Y		;byte of IOCB
00C2EF  1  E8           	INX
00C2F0  1  C8           	INY
00C2F1  1  E0 0C        	CPX	#ICSPRZ-IOCBAS	;offset to first undesired byte
00C2F3  1  90 F5        	BCC	CCO1		;if not done
00C2F5  1               
00C2F5  1               ;	Restore A, X and Y.
00C2F5  1               
00C2F5  1               
00C2F5  1               	.IF PLATFORM=0
00C2F5  1               
00C2F5  1  A3 04        	lda	4,s		;manipulate N-Bit of status byte
00C2F7  1  A4 23        	ldy	ICSTAZ		;load status
00C2F9  1  30 04        	bmi	CCO2		;is negativ? yes ->
00C2FB  1  29 7F        	and	#$7F		;clear N-Bit
00C2FD  1  80 02        	bra	CCO3
00C2FF  1  09 80        CCO2:	ora	#$80		;set N-Bit
00C301  1  83 04        CCO3:	sta	4,s		;store (to be pulled by last pld)
00C303  1  A5 2F        	lda	CIOCHR
00C305  1  A6 2E        	ldx	ICIDNO
00C307  1  AB           	plb
00C308  1  2B           	pld
00C309  1  28           	plp
00C30A  1               
00C30A  1               	.ELSE
00C30A  1               
00C30A  1               	LDA	CIOCHR		;data
00C30A  1               	LDX	ICIDNO		;IOCB index
00C30A  1               	LDY	ICSTAZ		;status
00C30A  1               
00C30A  1               	.ENDIF
00C30A  1               
00C30A  1  60           	RTS			;return
00C30B  1               ;	SPACE	4,10
00C30B  1               ;;	CEP - Compute Handler Entry Point
00C30B  1               ;
00C30B  1               ;	ENTRY	JSR	CEP
00C30B  1               ;
00C30B  1               ;	MODS
00C30B  1               ;		Original Author Unknown
00C30B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C30B  1               ;		   R. K. Nordin	11/01/83
00C30B  1               
00C30B  1               
00C30B  1               CEP:	;=	;		;entry
00C30B  1               
00C30B  1               ;	Check handler ID validity.
00C30B  1               
00C30B  1               ;	lda 	ICHIDZ
00C30B  1               
00C30B  1  A4 20        	LDY	ICHIDZ		;handler ID
00C30D  1  C0 22        	CPY	#MAXDEV+1	;first invalid ID
00C30F  1  90 04        	BCC	CEP1		;if handler ID within range
00C311  1               
00C311  1               ;	Process error.
00C311  1               
00C311  1  A0 85        	LDY	#NOTOPN		;IOCB not open error
00C313  1  B0 1B        	BCS	CEP2		;return
00C315  1               
00C315  1               ;	Compute entry point.
00C315  1               
00C315  1               CEP1:
00C315  1  B9 01 03     	LDA	HATABS+1,Y	;low address
00C318  1  85 2C        	STA	ICSPRZ
00C31A  1  B9 02 03     	LDA	HATABS+2,Y	;high address
00C31D  1  85 2D        	STA	ICSPRZ+1
00C31F  1  A4 31        	LDY	ICCOMT		;command
00C321  1  B9 C1 C3     	LDA	TCVO-3,Y	;vector offset for command
00C324  1  A8           	TAY
00C325  1  B1 2C        	LDA	(ICSPRZ),Y	;low vector address
00C327  1  AA           	TAX			;low vector address
00C328  1  C8           	INY
00C329  1  B1 2C        	LDA	(ICSPRZ),Y	;high vector address
00C32B  1  85 2D        	STA	ICSPRZ+1	;set high address
00C32D  1  86 2C        	STX	ICSPRZ		;set low address
00C32F  1  18           	CLC			;indicate success
00C330  1               
00C330  1               ;	Exit.
00C330  1               
00C330  1  60           CEP2:	RTS			;return
00C331  1               ;	SPACE	4,10
00C331  1               ;;	DBL - Decrement Buffer Length
00C331  1               ;
00C331  1               ;	ENTRY	JSR	DBL
00C331  1               ;
00C331  1               ;	EXIT
00C331  1               ;		Z set if buffer length = 0
00C331  1               ;
00C331  1               ;	MODS
00C331  1               ;		Original Author Unknown
00C331  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C331  1               ;		   R. K. Nordin	11/01/83
00C331  1               
00C331  1               
00C331  1               DBL:	;=	;		;entry
00C331  1  A5 27        	LDA	ICBLLZ		;low buffer length
00C333  1  D0 08        	BNE	DBL1		;if low buffer length non-zero
00C335  1               
00C335  1               	.IF PLATFORM=0
00C335  1  A5 28        	lda	ICBLLZ+1
00C337  1  D0 02        	bne	DBL2
00C339  1  C6 29        	dec	ICBLLZ+2
00C33B  1               	.ENDIF
00C33B  1               
00C33B  1  C6 28        DBL2:	DEC	ICBLLZ+1	;decrement high buffer length
00C33D  1               
00C33D  1  C6 27        DBL1:	DEC	ICBLLZ		;decrement low buffer length
00C33F  1  A5 27        	LDA	ICBLLZ
00C341  1  05 28        	ORA	ICBLLZ+1	;indicate buffer length status
00C343  1               	.IF PLATFORM=0
00C343  1  05 29        	ora	ICBLLZ+2
00C345  1               	.ENDIF
00C345  1  60           	RTS			;return
00C346  1               ;	SPACE	4,10
00C346  1               ;;	DBP - Decrement Buffer Pointer
00C346  1               ;
00C346  1               ;	ENTRY	JSR	DBP
00C346  1               ;
00C346  1               ;	MODS
00C346  1               ;		Original Author Unknown
00C346  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C346  1               ;		   R. K. Nordin	11/01/83
00C346  1               
00C346  1               
00C346  1               DBP:	;=	;		;entry
00C346  1  A5 24        	LDA	ICBALZ		;low buffer address
00C348  1  D0 08        	BNE	DBP1		;if low buffer address non-zero
00C34A  1               
00C34A  1               	.IF PLATFORM=0
00C34A  1  A5 25        	lda	ICBALZ+1
00C34C  1  D0 02        	bne	DBP2
00C34E  1  C6 26        	dec	ICBALZ+2
00C350  1               	.ENDIF
00C350  1               
00C350  1  C6 25        DBP2:	DEC	ICBALZ+1	;decrement high buffer address
00C352  1               
00C352  1  C6 24        DBP1:	DEC	ICBALZ		;decrement low buffer address
00C354  1  60           	RTS			;return
00C355  1               ;	SPACE	4,10
00C355  1               ;;	IBP - Increment Buffer Pointer
00C355  1               ;
00C355  1               ;	ENTRY	JSR	IBP
00C355  1               ;
00C355  1               ;	MODS
00C355  1               ;		Original Author Unknown
00C355  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C355  1               ;		   R. K. Nordin	11/01/83
00C355  1               
00C355  1               
00C355  1               IBP:	;=	;		;entry
00C355  1  E6 24        	INC	ICBALZ		;increment low buffer address
00C357  1  D0 06        	BNE	IBP1		;if low buffer address non-zero
00C359  1               
00C359  1  E6 25        	INC	ICBALZ+1	;increment high buffer address
00C35B  1               
00C35B  1               	.IF PLATFORM=0
00C35B  1  D0 02        	bne	IBP1
00C35D  1  E6 26        	inc	ICBALZ+2
00C35F  1               	.ENDIF
00C35F  1               
00C35F  1  60           IBP1:	RTS			;return
00C360  1               ;	SPACE	4,10
00C360  1               ;;	SFL - Set Final Buffer Length
00C360  1               ;
00C360  1               ;	ENTRY	JSR	SFL
00C360  1               ;
00C360  1               ;	MODS
00C360  1               ;		Original Author Unknown
00C360  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C360  1               ;		   R. K. Nordin	11/01/83
00C360  1               
00C360  1               
00C360  1               SFL:	;=	;		;entry
00C360  1  A6 2E        	LDX	ICIDNO		;IOCB index
00C362  1  38           	SEC
00C363  1  BD 87 02     	LDA	ICBLL,X		;initial length
00C366  1  E5 27        	SBC	ICBLLZ		;subtract byte count
00C368  1  85 27        	STA	ICBLLZ		;update length
00C36A  1  BD 88 02     	LDA	ICBLH,X
00C36D  1  E5 28        	SBC	ICBLHZ
00C36F  1  85 28        	STA	ICBLHZ
00C371  1               	.IF PLATFORM=0
00C371  1  BD 89 02     	LDA	ICBLB,X
00C374  1  E5 29        	SBC	ICBLBZ
00C376  1  85 29        	STA	ICBLBZ
00C378  1               	.ENDIF
00C378  1  60           	RTS			;return
00C379  1               ;	SPACE	4,10
00C379  1               ;;	EHC - Execute Handler Command
00C379  1               ;
00C379  1               ;	ENTRY	JSR	EHC
00C379  1               ;
00C379  1               ;	MODS
00C379  1               ;		Original Author Unknown
00C379  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C379  1               ;		   R. K. Nordin	11/01/83
00C379  1               
00C379  1               
00C379  1               EHC:	;=	;		;entry
00C379  1  A0 92        	LDY	#FNCNOT		;assume function not defined error
00C37B  1  20 83 C3     	JSR	IDH		;invoke device handler
00C37E  1  84 23        	STY	ICSTAZ		;status
00C380  1  C0 00        	CPY	#0		;set N accordingly
00C382  1  60           	RTS			;return
00C383  1               ;	SPACE	4,10
00C383  1               ;;	IDH - Invoke Device Handler
00C383  1               ;
00C383  1               ;	ENTRY	JSR	IDH
00C383  1               ;
00C383  1               ;	MODS
00C383  1               ;		Original Author Unknown
00C383  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C383  1               ;		   R. K. Nordin	11/01/83
00C383  1               
00C383  1               
00C383  1               IDH:	;=	;		;entry
00C383  1  AA           	TAX			;save A
00C384  1  A5 2D        	LDA	ICSPRZ+1	;high vector
00C386  1               ;	jsr	jprinthex
00C386  1  48           	PHA			;put high vector on stack
00C387  1  A5 2C        	LDA	ICSPRZ		;low vector
00C389  1               ;	jsr	jprinthex
00C389  1  48           	PHA			;put low vector on stack
00C38A  1  8A           	TXA			;restore A
00C38B  1  A6 2E        	LDX	ICIDNO		;IOCB index
00C38D  1  60           	RTS			;invoke handler (address on stack)
00C38E  1               ;	SPACE	4,10
00C38E  1               ;;	SHT - Search Handler Table
00C38E  1               ;
00C38E  1               ;	ENTRY	JSR	SHT
00C38E  1               ;
00C38E  1               ;	MODS
00C38E  1               ;		Original Author Unknown
00C38E  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C38E  1               ;		   R. K. Nordin	11/01/83
00C38E  1               
00C38E  1               
00C38E  1               SHT:	;=	;	;entry
00C38E  1               
00C38E  1               ;	Set device number.
00C38E  1               
00C38E  1  38           	SEC
00C38F  1  A0 01        	LDY	#1
00C391  1               	.IF PLATFORM=0
00C391  1  B7 24        	lda	[ICBALZ],y
00C393  1               	.ELSE
00C393  1               	LDA	(ICBALZ),Y	;device number
00C393  1               	.ENDIF
00C393  1               
00C393  1  E9 31        	SBC	#'1'
00C395  1  30 04        	BMI	SHT1		;if number less than  "1"
00C397  1               
00C397  1  C9 09        	CMP	#'9'-'1'+1
00C399  1  90 02        	BCC	SHT2		;if number in range "1" to "9"
00C39B  1               
00C39B  1  A9 00        SHT1:	LDA	#0		;substitute device number "1"
00C39D  1               
00C39D  1  85 21        SHT2:	STA	ICDNOZ		;device number (0 through 8)
00C39F  1  E6 21        	INC	ICDNOZ		;adjust number to range 1 t:
00C3A1  1               
00C3A1  1               ;	Find device handler.
00C3A1  1               	.IF PLATFORM=0
00C3A1  1  A7 24        	lda	[ICBALZ]
00C3A3  1               	.ELSE
00C3A3  1               	LDY	#0		;offset to device code
00C3A3  1               	LDA	(ICBALZ),Y	;device code
00C3A3  1               	.ENDIF
00C3A3  1               
00C3A3  1  F0 16        	beq	FDH2		;if device code null, error
00C3A5  1  C9 61        	cmp	#'a'		; < 'a'?
00C3A7  1  90 06        	bcc	FDH		; search
00C3A9  1  C9 7B        	cmp	#'z'+1		; >= 'Z'+1?
00C3AB  1  B0 02        	bcs	FDH		; search
00C3AD  1  E9 1F        	sbc	#32-1		; carry clear!
00C3AF  1               
00C3AF  1               ;	JMP	FDH		;find device handler, return
00C3AF  1               ;	SPACE	4,10
00C3AF  1               ;;	FDH - Find Device Handler
00C3AF  1               ;
00C3AF  1               ;	ENTRY	JSR	FDH
00C3AF  1               ;
00C3AF  1               ;	MODS
00C3AF  1               ;		Original Author Unknown
00C3AF  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C3AF  1               ;		   R. K. Nordin	11/01/83
00C3AF  1               
00C3AF  1               
00C3AF  1               FDH:	;=	;		;entry
00C3AF  1               
00C3AF  1               ;	Check device code.
00C3AF  1               
00C3AF  1               ;	BEQ	FDH2		;if device code null
00C3AF  1               
00C3AF  1               ;	Search handler table for device.
00C3AF  1               
00C3AF  1  A0 21        	LDY	#MAXDEV		;offset to last possible entry
00C3B1  1               
00C3B1  1  D9 00 03     FDH1:	CMP	HATABS,Y	;device code from table
00C3B4  1  F0 09        	BEQ	FDH3		;if device found
00C3B6  1               
00C3B6  1  88           	DEY
00C3B7  1  88           	DEY
00C3B8  1  88           	DEY
00C3B9  1  10 F6        	BPL	FDH1		;if not done
00C3BB  1               
00C3BB  1               ;	Process device not found.
00C3BB  1               
00C3BB  1  A0 82        FDH2:	LDY	#NONDEV		;nonexistent device error
00C3BD  1  38           	SEC			;indicate error
00C3BE  1  60           	RTS			;return
00C3BF  1               
00C3BF  1               ;	Set handler ID.
00C3BF  1               
00C3BF  1  98           FDH3:	TYA			;offset to device code in table
00C3C0  1  85 20        	STA	ICHIDZ		;set handler ID
00C3C2  1  18           	CLC			;indicate no error
00C3C3  1  60           	RTS			;return
00C3C4  1               ;	SPACE	4,10
00C3C4  1               ;;	TCVO - Table of Command Vector Offsets
00C3C4  1               ;
00C3C4  1               ;	Entry n is the vector offset for command n+3.
00C3C4  1               
00C3C4  1               
00C3C4  1  00           TCVO:	.byte	0	;3 - open
00C3C5  1  04           	.byte	4	;4
00C3C6  1  04           	.byte	4	;5 - get record
00C3C7  1  04           	.byte	4	;6
00C3C8  1  04           	.byte	4	;7 - get byte(s)
00C3C9  1  06           	.byte	6	;8
00C3CA  1  06           	.byte	6	;9 - put record
00C3CB  1  06           	.byte	6	;10
00C3CC  1  06           	.byte	6	;11 - put byte(s)
00C3CD  1  02           	.byte	2	;12 - close
00C3CE  1  08           	.byte	8	;13 - status
00C3CF  1  0A           	.byte	10	;14 - special
00C3D0  1               
00C3D0  1               
00C3D0  1               	;;	SIN - Initialize Screen
00C3D0  1               ;
00C3D0  1               ;	ENTRY	JSR	SIN
00C3D0  1               ;
00C3D0  1               ;	MODS
00C3D0  1               ;		Original Author Unknown
00C3D0  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C3D0  1               ;		   R. K. Nordin	11/01/83
00C3D0  1               SIN:	;=	;		;entry
00C3D0  1               
00C3D0  1               ;	LDA	#$FF		;clear code indicator
00C3D0  1               ;	STA	CH		;key code
00C3D0  1               ;
00C3D0  1               ;	LDA	RAMSIZ		;size of RAM
00C3D0  1               ;	STA	RAMTOP		;RAM size
00C3D0  1               ;
00C3D0  1               ;	LDA	#$40		;CAPS lock indicator
00C3D0  1               ;	STA	SHFLOK		;shift/control lock flags
00C3D0  1               ;
00C3D0  1               ;	LDA	#<TCKD	;table of character key def:
00C3D0  1               ;	STA	KEYDEF		;key definition table addre:
00C3D0  1               ;	LDA	#>TCKD
00C3D0  1               ;	STA	KEYDEF+1
00C3D0  1               ;
00C3D0  1               ;	LDA	#<TFKD	;table of function key defi:
00C3D0  1               ;	STA	FKDEF		;function key definition ta:
00C3D0  1               ;	LDA	#>TFKD
00C3D0  1               ;	STA	FKDEF+1
00C3D0  1  A9 00        	lda 	#0
00C3D2  1  8D 46 02     	sta 	skipone
00C3D5  1  8D 47 02     	sta 	extended
00C3D8  1  85 3A        	sta	ALTACT
00C3DA  1               
00C3DA  1  A9 F8        	lda 	#(>SCRSTRT + 8) & 255
00C3DC  1  85 4B        	sta 	RAMTOP
00C3DE  1               				;init to value <> 0
00C3DE  1  A9 01        	lda	#1
00C3E0  1  8D 31 02     	sta	SHFLOK		;shift off (lowercase)
00C3E3  1               ;	sta	STRGFLG		;strgoff
00C3E3  1  8D 29 02     	sta	CLSFLG		;clearscreen pressed
00C3E6  1               
00C3E6  1               ;	sta	BRKKEY
00C3E6  1               
00C3E6  1               ;	lda 	#$E8
00C3E6  1               ;	sta 	ScrBase
00C3E6  1               
00C3E6  1  A9 00        	LDA	#LEDGE
00C3E8  1  85 35        	STA 	LMARGN		;left margin
00C3EA  1  A9 4F        	LDA 	#CCHARLINE-1
00C3EC  1  85 36        	STA 	RMARGN		;right margin
00C3EE  1               
00C3EE  1  60           	RTS			;return
00C3EF  1               
00C3EF  1               ;;	SOP - Perform Screen OPEN
00C3EF  1               ;
00C3EF  1               ;	ENTRY	JSR	SOP
00C3EF  1               ;
00C3EF  1               ;	MODS
00C3EF  1               ;		Original Author Unknown
00C3EF  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C3EF  1               ;		   R. K. Nordin	11/01/83
00C3EF  1               
00C3EF  1               
00C3EF  1               ;SOP:	;=	;	;entry
00C3EF  1               
00C3EF  1               ;	Check mode.
00C3EF  1               
00C3EF  1               ;	LDA	ICAX2Z
00C3EF  1               ;	AND	#$0F
00C3EF  1               ;	BNE	COC	;if not mode 0, complete OPEN comma:
00C3EF  1               
00C3EF  1               ;	Process mode 0.
00C3EF  1               
00C3EF  1               ;	JMP	EOP	;perform editor OPEN, return
00C3EF  1               
00C3EF  1               ;;	EOP - Perform Editor OPEN
00C3EF  1               ;
00C3EF  1               ;	ENTRY	JSR	EOP
00C3EF  1               ;
00C3EF  1               ;	MODS
00C3EF  1               ;		Original Author Unknown
00C3EF  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C3EF  1               ;		   R. K. Nordin	11/01/83
00C3EF  1               
00C3EF  1               SOP:
00C3EF  1               EOP:	;=	;	;entry
00C3EF  1               
00C3EF  1  20 78 C0     	jsr	initcrt
00C3F2  1               ;	jsr	clrcrt
00C3F2  1               
00C3F2  1  A5 2A        	LDA	ICAX1Z
00C3F4  1  29 0F        	AND	#$0F
00C3F6  1  85 2A        	STA	ICAX1Z
00C3F8  1               ;	LDA	#0
00C3F8  1               ;	JMP	COC	;complete OPEN command, return
00C3F8  1               
00C3F8  1               ;;	COC - Complete OPEN Command
00C3F8  1               ;
00C3F8  1               ;	ENTRY	JSR	COC
00C3F8  1               ;		A = mode
00C3F8  1               ;
00C3F8  1               ;	MODS
00C3F8  1               ;		Original Author Unknown
00C3F8  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C3F8  1               ;		   R. K. Nordin	11/01/83
00C3F8  1               
00C3F8  1               COC:	;=	;	;entry
00C3F8  1               
00C3F8  1               ;	Check mode.
00C3F8  1               ;	STA	DINDEX	;save mode
00C3F8  1               ;	CMP	#16
00C3F8  1               ;	BCC	COC1	;if mode within range
00C3F8  1               
00C3F8  1               ;	Process invalid mode
00C3F8  1               
00C3F8  1               ;	LDA	#BADMOD
00C3F8  1               ;	JMP	COC17
00C3F8  1               
00C3F8  1               ;	Initialize for OPEN.
00C3F8  1               
00C3F8  1               COC1:
00C3F8  1               ;	LDA	#>DCSORG	;>domestic character se:
00C3F8  1               ;	STA	CHBAS		;character set base
00C3F8  1               ;	LDA	#>ICSORG	;>international charact:
00C3F8  1               ;	STA	CHSALT		;alternate character set ba:
00C3F8  1               ;	LDA	#2
00C3F8  1               ;	STA	CHACT
00C3F8  1               ;	STA	SDMCTL		;turn off DMA
00C3F8  1  A9 01        	LDA	#SUCCES
00C3FA  1  85 32        	STA	DSTAT		;clear status
00C3FC  1               ;	LDA	#$C0		;enable IRQ
00C3FC  1               ;	ORA	POKMSK
00C3FC  1               ;	STA	POKMSK
00C3FC  1               ;	STA	IRQEN
00C3FC  1               
00C3FC  1               ;	Set DLI status.
00C3FC  1               
00C3FC  1               ;	LDA	#$40		;disable DLI
00C3FC  1               ;	STA	NMIEN
00C3FC  1               ;	BIT	FINE
00C3FC  1               ;	BPL	COC2		;if not fine scrolling (VBL:
00C3FC  1               
00C3FC  1               ;	LDA	#<FDL
00C3FC  1               ;	STA	VDSLST		;DLI vector
00C3FC  1               ;	LDA	#>FDL
00C3FC  1               ;	STA	VDSLST+1
00C3FC  1               ;	LDA	#$C0
00C3FC  1               
00C3FC  1               COC2:
00C3FC  1               ;	STA	NMIEN
00C3FC  1               
00C3FC  1               ;	Clear control.
00C3FC  1               
00C3FC  1  A9 00        	LDA	#0
00C3FE  1  8D 03 02     	STA	TINDEX		;clear text index (must alw:
00C401  1  85 5D        	STA	ADRESS
00C403  1  85 59        	STA	SWPFLG
00C405  1  8D 37 02     	STA	CRSINH
00C408  1               
00C408  1               ;	Set initial tab stops.
00C408  1               
00C408  1  A0 0E        	LDY	#14		;offset to last byte of bit:
00C40A  1  A9 01        	LDA	#$01		;tab stop every 8 character:
00C40C  1               
00C40C  1  99 12 02     COC3:	STA	TABMAP,Y	;set tab stop
00C40F  1  88           	DEY
00C410  1  10 FA        	BPL	COC3		;if not done
00C412  1               
00C412  1               ;	Load initialize color register shadows.
00C412  1               
00C412  1               ;	LDX	#4		;offset to last color regis:
00C412  1               
00C412  1               ;COC4:	LDA	TDSC,X		;default screen color
00C412  1               ;	STA	COLOR0,X	;set color register shadow
00C412  1               ;	DEX
00C412  1               ;	BPL	COC4		;if not done
00C412  1               
00C412  1               ;	Set up.
00C412  1               
00C412  1               ;	LDY	RAMTOP		;(high) RAM size
00C412  1               ;	DEY			;decrement (high) RAM size
00C412  1               ;	STY	TXTMSC+1
00C412  1               ;	LDA	#<($0000-160)	;low RAM size = 160
00C412  1               ;	STA	TXTMSC
00C412  1               ;	LDX	DINDEX		;mode
00C412  1               ;	LDA	TAGM,X		;convert to ANTIC code
00C412  1               ;	STA	HOLD1		;ANTIC code
00C412  1               
00C412  1  38           	sec
00C413  1  A5 4B        	LDA	RAMTOP		;(high) RAM size
00C415  1  E9 08        	sbc	#8		;reserve 8 pages = 2KB
00C417  1  85 5E        	STA	ADRESS+1
00C419  1               
00C419  1               ;	Allocate memory.
00C419  1               
00C419  1               ;	LDY	TSMA,X		;number of 40-byte blocks t:
00C419  1               ;
00C419  1               ;COC5:	LDA	#40		;40 bytes
00C419  1               ;	JSR	DBS		;perform double byte subtra:
00C419  1               ;	DEY
00C419  1               ;	BNE	COC5		;if not done
00C419  1               
00C419  1               ;	lda	RAMTOP
00C419  1               ;	lda	ADRESS+1
00C419  1               ;	jsr	jprinthex
00C419  1               ;	lda	ADRESS
00C419  1               ;	jsr	jprinthex
00C419  1               
00C419  1               ;	Clear GTIA modes.
00C419  1               
00C419  1               ;	LDA	GPRIOR
00C419  1               ;	AND	#$3F		;clear GTIA modes
00C419  1               ;	STA	OPNTMP+1
00C419  1               ;	lda	#0
00C419  1               ;	sta	OPNTMP+1
00C419  1               ;	jmp COC7
00C419  1               
00C419  1  A0 00        	LDY	#0
00C41B  1               
00C41B  1               ;	Determine mode.
00C41B  1               
00C41B  1               ;	CPX	#8
00C41B  1               ;	BCC	COC7		;if mode < 8
00C41B  1               
00C41B  1               ;	CPX	#15
00C41B  1               ;	BEQ	COC6		;if mode 15
00C41B  1               
00C41B  1               ;	CPX	#12
00C41B  1               ;	BCS	COC7		;if mode >= 12
00C41B  1               
00C41B  1               ;	Process mode 9, 10 and 11.
00C41B  1               
00C41B  1               ;	TXA			;mode
00C41B  1               ;	ROR	A
00C41B  1               ;	ROR	A
00C41B  1               ;	ROR	A
00C41B  1               ;	AND	#$C0		;extract 2 low bits (in 2 h:
00C41B  1               ;	ORA	OPNTMP+1
00C41B  1               ;	TAY
00C41B  1               
00C41B  1               ;	Establish line boundary at X000.
00C41B  1               
00C41B  1               ;COC6:	LDA	#16		;subtract 16 for page bound:
00C41B  1               ;	JSR	DBS		;perform double byte subtra:
00C41B  1               
00C41B  1               ;	Check for mode 11.
00C41B  1               
00C41B  1               ;	CPX	#11
00C41B  1               ;	BNE	COC7		;if mode 11
00C41B  1               
00C41B  1               ;	Set GTIA luminance.
00C41B  1               
00C41B  1               ;	LDA	#6		;GTIA luminance value
00C41B  1               ;	STA	COLOR4		;background color
00C41B  1               
00C41B  1               ;	Set new priority.
00C41B  1               
00C41B  1               COC7:
00C41B  1               ;	STY	GPRIOR		;new priority
00C41B  1               
00C41B  1               ;	Set memory scan counter.
00C41B  1               
00C41B  1  A5 5D        	LDA	ADRESS		;memory scan counter
00C41D  1  85 3B        	STA	SAVMSC		;save memory scan counter
00C41F  1  A5 5E        	LDA	ADRESS+1
00C421  1  85 3C        	STA	SAVMSC+1
00C423  1  4C 26 C4     	jmp	COC18
00C426  1               
00C426  1               
00C426  1               ;	Wait for VBLANK.
00C426  1               
00C426  1               COC8:
00C426  1               ;	jmp 	COC18
00C426  1               
00C426  1               ;	LDA	VCOUNT
00C426  1               ;	CMP	#$7A
00C426  1               ;	BNE	COC8		;if VBLANK has not occured
00C426  1               
00C426  1               ;	Put display list under RAM.
00C426  1               
00C426  1               ;	JSR	DSD		;perform double byte single:
00C426  1               ;	LDA	TDLV,X		;display list vulnerability
00C426  1               ;	BEQ	COC9		;if not vulnerable
00C426  1               ;
00C426  1               ;	LDA	#$FF
00C426  1               ;	STA	ADRESS
00C426  1               ;	DEC	ADRESS+1	;drop down 1 page
00C426  1               ;
00C426  1               ;COC9:	JSR	DDD		;perform double byte double:
00C426  1               ;	LDA	ADRESS		;end of display list
00C426  1               ;	STA	SAVADR		;save address
00C426  1               ;	LDA	ADRESS+1
00C426  1               ;	STA	SAVADR+1
00C426  1               ;
00C426  1               ;;	Set up.
00C426  1               ;
00C426  1               ;	LDA	#$41		;ANTIC wait for VBLANK and :
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	STX	OPNTMP
00C426  1               ;	LDA	#24
00C426  1               ;	STA	BOTSCR	;screen bottom
00C426  1               ;
00C426  1               ;;	Check for modes 9 ,10 and 11.
00C426  1               ;
00C426  1               ;	LDA	DINDEX		;mode
00C426  1               ;	CMP	#12
00C426  1               ;	BCS	COC10		;if mode >= 12, mixed mode :
00C426  1               ;
00C426  1               ;	CMP	#9
00C426  1               ;	BCS	COC12		;if mode >= 9, mixed mode n:
00C426  1               ;
00C426  1               ;;	Check for mixed mode.
00C426  1               ;
00C426  1               ;COC10:	LDA	ICAX1Z
00C426  1               ;	AND	#MXDMOD
00C426  1               ;	BEQ	COC12		;if not mixed mode
00C426  1               ;
00C426  1               ;;	Process mixed mode.
00C426  1               ;
00C426  1               ;	LDA	#4
00C426  1               ;	STA	BOTSCR	;screen bottom
00C426  1               ;	LDX	#2
00C426  1               ;	LDA	FINE
00C426  1               ;	BEQ	COC11		;if not fine scrolling
00C426  1               ;
00C426  1               ;	JSR	SSE		;set scrolling display list:
00C426  1               ;
00C426  1               ;COC11:	LDA	#$02
00C426  1               ;	JSR	SDF		;store data indirect for fi:
00C426  1               ;	DEX
00C426  1               ;	BPL	COC11		;if not done
00C426  1               ;
00C426  1               ;;	Reload MSC for text.
00C426  1               ;
00C426  1               ;	LDY	RAMTOP		;(high) RAM size
00C426  1               ;	DEY			;decrement (high) RAM size
00C426  1               ;	TYA
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	#<($0000-160)	;low RAM size = 160
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	#$42		;fine scrolling
00C426  1               ;	JSR	SDF		;store data indirect
00C426  1               ;	CLC
00C426  1               ;	LDA	#MXDMOD
00C426  1               ;	ADC	OPNTMP
00C426  1               ;	TAY
00C426  1               ;	LDX	TDLE,Y
00C426  1               ;	BNE	COC13
00C426  1               ;
00C426  1               ;;	Check mode.
00C426  1               ;
00C426  1               ;COC12:	LDY	OPNTMP
00C426  1               ;	LDX	TDLE,Y		;number of display list ent:
00C426  1               ;	LDA	DINDEX		;mode
00C426  1               ;	BNE	COC13		;if not mode 0
00C426  1               ;
00C426  1               ;;	Check for fine scrolling.
00C426  1               ;
00C426  1               ;;	LDA	FINE		;fine scrolling flag
00C426  1               ;;	BEQ	COC13		;if not fine scrolling
00C426  1               ;
00C426  1               ;;	Process fine scrolling.
00C426  1               ;
00C426  1               ;	JSR	SSE		;set scrolling display list:
00C426  1               ;	LDA	#$22
00C426  1               ;	STA	HOLD1
00C426  1               ;
00C426  1               ;;	Continue.
00C426  1               ;
00C426  1               ;COC13:	LDA	HOLD1
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	DEX
00C426  1               ;	BNE	COC13		;if not done
00C426  1               ;
00C426  1               ;;	Determine mode.
00C426  1               ;
00C426  1               ;	LDA	DINDEX		;mode
00C426  1               ;	CMP	#8
00C426  1               ;	BCC	COC16		;if mode < 8
00C426  1               ;
00C426  1               ;	CMP	#15
00C426  1               ;	BEQ	COC14		;if mode 15
00C426  1               ;
00C426  1               ;	CMP	#12
00C426  1               ;	BCS	COC16		;if mode >= 12
00C426  1               ;
00C426  1               ;;	Process modes 8, 9, 10, 11 and 15.
00C426  1               ;
00C426  1               ;COC14:	LDX	#93		;remaining number of DLE's
00C426  1               ;	LDA	RAMTOP		;(high) RAM size
00C426  1               ;	SEC
00C426  1               ;	SBC	#>$1000	;subtract 4K
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	#<$0000
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	HOLD1		;ANTIC MSC code
00C426  1               ;	ORA	#$40
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;
00C426  1               ;COC15:	LDA	HOLD1		;remaining DLE's
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	DEX
00C426  1               ;	BNE	COC15		;if DLE's remain
00C426  1               ;
00C426  1               ;;	Complete display list with LMS.
00C426  1               ;
00C426  1               ;COC16:	LDA	SAVMSC+1	;>saved memory scan cou:
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	SAVMSC		;low saved memory scan coun:
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	HOLD1
00C426  1               ;	ORA	#$40
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	#$70		;8 blank lines
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	#$70		;8 blank lines
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	ADRESS		;display list address
00C426  1               ;	STA	SDLSTL		;save display list address
00C426  1               ;	LDA	ADRESS+1
00C426  1               ;	STA	SDLSTL+1
00C426  1               ;	LDA	#$70		;8 blank lines
00C426  1               ;	JSR	SDI		;store data indirect
00C426  1               ;	LDA	ADRESS		;display list address
00C426  1               ;	STA	MEMTOP		;update top of memory
00C426  1               ;	LDA	ADRESS+1
00C426  1               ;	STA	MEMTOP+1
00C426  1               ;	LDY	#1		;offset
00C426  1               ;	LDA	SDLSTL		;saved display list address
00C426  1               ;	STA	(SAVADR),Y
00C426  1               ;	INY
00C426  1               ;	LDA	SDLSTL+1
00C426  1               ;	STA	(SAVADR),Y
00C426  1               ;
00C426  1               ;;	Check status.
00C426  1               ;
00C426  1               ;	LDA	DSTAT		;status
00C426  1               ;	BPL	COC18		;if no error
00C426  1               ;
00C426  1               ;;	Process error.
00C426  1               ;
00C426  1               ;COC17:	STA	DERRF		;screen OPEN error flag
00C426  1               ;	JSR	EOP		;perform editor OPEN
00C426  1               ;	LDA	DERRF		;restore status
00C426  1               ;	LDY	#0		;no screen OPEN error indic:
00C426  1               ;	STY	DERRF		;screen OPEN error flag
00C426  1               ;	TAY			;status
00C426  1               ;	RTS			;return
00C426  1               
00C426  1               ;	Check clear inhibit.
00C426  1               
00C426  1  A9 19        COC18:	lda	#NUMROWS
00C428  1  8D 32 02     	sta	BOTSCR
00C42B  1               
00C42B  1  A5 2A        	LDA	ICAX1Z
00C42D  1  29 20        	AND	#$20		;extract clear inhibit bit
00C42F  1  D0 0B        	BNE	COC19		;if clear inhibited
00C431  1               
00C431  1               ;	Clear screen.
00C431  1               
00C431  1  20 B8 C5     	JSR	CSC		;clear screen
00C434  1  8D 00 02     	STA	TXTROW		;set cursor at top row
00C437  1  A5 35        	LDA	LMARGN		;left margin
00C439  1  8D 01 02     	STA	TXTCOL		;set cursor at left margin
00C43C  1               
00C43C  1               ;	Exit.
00C43C  1               
00C43C  1               COC19:
00C43C  1               ;	LDA	#$22		;turn on DMA control
00C43C  1               ;	ORA	SDMCTL
00C43C  1               ;	STA	SDMCTL
00C43C  1  4C AC C4     	JMP	SEC_		;set exit conditions, return
00C43F  1               
00C43F  1               ;;	SGB - Perform Screen GET-BYTE
00C43F  1               ;
00C43F  1               ;	ENTRY	JSR	SGB
00C43F  1               ;
00C43F  1               ;	MODS
00C43F  1               ;		Original Author Unknown
00C43F  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C43F  1               ;		   R. K. Nordin	11/01/83
00C43F  1               
00C43F  1               
00C43F  1               SGB:	;:	;=	;	;entry
00C43F  1  20 FB C7     	JSR	CCR	;check cursor range
00C442  1  20 4E C4     	JSR	GDC	;get data under cursor
00C445  1  20 8B C8     	JSR	CIA	;convert internal character to ATAS:
00C448  1  20 57 C7     	JSR	SZA	;set zero data and advance cursor
00C44B  1  4C B5 C4     	JMP	SST	;perform screen STATUS, return
00C44E  1               
00C44E  1               ;;	GDC - Get Data Under Cursor
00C44E  1               ;
00C44E  1               ;	ENTRY	JSR	GDC
00C44E  1               ;
00C44E  1               ;	MODS
00C44E  1               ;		Original Author Unknown
00C44E  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C44E  1               ;		   R. K. Nordin	11/01/83
00C44E  1               
00C44E  1               
00C44E  1               GDC:	;=	;	;entry
00C44E  1  20 1A C7     	JSR	CCA	;convert cursor row/column to addre:
00C451  1               	.IF PLATFORM=0
00C451  1  B7 5D        	lda	[ADRESS],Y
00C453  1               	.ELSE
00C453  1               	LDA	(ADRESS),Y
00C453  1               	.ENDIF
00C453  1               
00C453  1               ;	AND	DMASK
00C453  1               
00C453  1               ;GDC1:	LSR	SHFAMT	;shift data down to low bits
00C453  1               ;	BCS	GDC2	;if done
00C453  1               
00C453  1               ;	LSR	A
00C453  1               ;	BPL	GDC1	;continue shifting
00C453  1               
00C453  1  8D 3F 02     GDC2:	STA	CHAR
00C456  1               ;	CMP	#0	;restore flags
00C456  1  60           F1A3:	RTS		;return
00C457  1               
00C457  1               ;;	SPB - Perform Screen PUT-BYTE
00C457  1               ;
00C457  1               ;	ENTRY	JSR	SPB
00C457  1               ;
00C457  1               ;	MODS
00C457  1               ;		Original Author Unknown
00C457  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C457  1               ;		   R. K. Nordin	11/01/83
00C457  1               
00C457  1               
00C457  1               SPB:	;=	;	;entry
00C457  1  8D 40 02     	STA	ATACHR
00C45A  1               
00C45A  1               ;	JSR	ROD	;restore old data under cursor
00C45A  1               
00C45A  1  C9 01        	CMP	#CLS
00C45C  1  D0 06        	BNE	SPB1	;if not clear screen
00C45E  1               
00C45E  1  20 B8 C5     	JSR	CSC	;clear screen
00C461  1  4C AC C4     	JMP	SEC_	;set exit contitions, return
00C464  1               
00C464  1  20 FB C7     SPB1:	JSR	CCR	;check cursor range
00C467  1               ;	JMP	CEL	;check EOL, return
00C467  1               
00C467  1               ;;	CEL - Check End of Line
00C467  1               ;
00C467  1               ;	ENTRY	JSR	CEL
00C467  1               ;
00C467  1               ;	MODS
00C467  1               ;		Original Author Unknown
00C467  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C467  1               ;		   R. K. Nordin	11/01/83
00C467  1               
00C467  1               
00C467  1               CEL:	;=	;	;entry
00C467  1  AD 40 02     	LDA	ATACHR
00C46A  1  C9 0A        	CMP	#EOL
00C46C  1  D0 06        	BNE	CEL1	;if not EOL
00C46E  1               
00C46E  1  20 A3 C7     	JSR	RWS	;return with scrolling
00C471  1  4C AC C4     	JMP	SEC_	;set exit conditions, return
00C474  1               
00C474  1  20 7D C4     CEL1:	JSR	PLO	;plot point
00C477  1  20 5B C7     	JSR	SEA	;set EOL data and advance cursor
00C47A  1  4C AC C4     	JMP	SEC_	;set exit conditions, return
00C47D  1               
00C47D  1               ;;	PLO - Plot Point
00C47D  1               ;
00C47D  1               ;	ENTRY	JSR	PLO
00C47D  1               ;
00C47D  1               ;	MODS
00C47D  1               ;		Original Author Unknown
00C47D  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C47D  1               ;		   R. K. Nordin	11/01/83
00C47D  1               
00C47D  1               
00C47D  1               PLO:	;=	*		;entry
00C47D  1               
00C47D  1               ;	Wait for start/stop flag clear.
00C47D  1               
00C47D  1  AD 43 02     PLO0:	LDA	SSFLAG		;start/stop flag
00C480  1  D0 FB        	BNE	PLO0		;if start/stop flag non-zer:
00C482  1               
00C482  1               ;	Save cursor row/column.
00C482  1               
00C482  1  A2 02        	LDX	#2		;offset to last byte
00C484  1               
00C484  1  B5 37        PLO1:	LDA	ROWCRS,X	;byte of cursor row/column
00C486  1  95 3D        	STA	OLDROW,X	;save byte of cursor row/co:
00C488  1  CA           	DEX
00C489  1  10 F9        	BPL	PLO1		;if not done
00C48B  1               
00C48B  1               ;	Convert ATASCII character to internal.
00C48B  1               
00C48B  1  AD 40 02     	LDA	ATACHR		;character
00C48E  1  18           	clc
00C48F  1               ;	TAY			;character
00C48F  1               ;	ROL	A
00C48F  1               ;	ROL	A
00C48F  1               ;	ROL	A
00C48F  1               ;	ROL	A
00C48F  1               ;	AND	#3
00C48F  1               ;	TAX			;index into TAIC
00C48F  1               ;	TYA			;character
00C48F  1               ;	AND	#$9F		;strip off column address
00C48F  1               ;	ORA	TAIC,X		;or in new column address
00C48F  1               ;	JMP	SPQ		;display, return
00C48F  1               
00C48F  1               ;;	SPQ - Display
00C48F  1               ;
00C48F  1               ;	ENTRY	JSR	SPQ
00C48F  1               ;
00C48F  1               ;	MODS
00C48F  1               ;		Original Author Unknown
00C48F  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C48F  1               ;		   R. K. Nordin	11/01/83
00C48F  1               
00C48F  1               
00C48F  1               SPQ:	;=	*		;entry
00C48F  1               
00C48F  1               ;	Set CHAR.
00C48F  1               ;	RS if carry set, print cursor
00C48F  1               	.IF PLATFORM = 1
00C48F  1               	php
00C48F  1               	.ENDIF
00C48F  1               
00C48F  1               	.IF PLATFORM = 0
00C48F  1  90 0F        	bcc	SPQ2
00C491  1  A5 5D        	lda	ADRESS		;use hardware cursor
00C493  1  8F 0A FE FF  	sta	cursorLo
00C497  1  A5 5E        	lda	ADRESS+1
00C499  1  29 07        	and	#%00000111	;restrict to 2KB
00C49B  1  8F 0B FE FF  	sta	cursorHi
00C49F  1  60           	rts
00C4A0  1               	.ENDIF
00C4A0  1               
00C4A0  1  8D 3F 02     SPQ2:	STA	CHAR		;character
00C4A3  1               
00C4A3  1               ;	Convert cursor row/column to address.
00C4A3  1               
00C4A3  1  20 1A C7     	JSR	CCA		;convert cursor row/column :
00C4A6  1               
00C4A6  1               ;	Shift up to proper position.
00C4A6  1               
00C4A6  1  AD 3F 02     	LDA	CHAR		;character
00C4A9  1               
00C4A9  1               ;PQ1:	LSR	SHFAMT
00C4A9  1               ;	BCS	SPQ2		;if done
00C4A9  1               
00C4A9  1               ;	ASL	A
00C4A9  1               ;	JMP	SPQ1		;continue shifting
00C4A9  1               
00C4A9  1               ;	Update data.
00C4A9  1               
00C4A9  1               ;SPQ2:	AND	DMASK
00C4A9  1               ;	STA	TMPCHR		;save shifted data
00C4A9  1               ;	LDA	DMASK		;display mask
00C4A9  1               ;	EOR	#$FF		;complement display mask
00C4A9  1               ;	AND	(ADRESS),Y	;mask off old data
00C4A9  1               ;	ORA	TMPCHR		;or in new data
00C4A9  1               	.IF PLATFORM=0
00C4A9  1  97 5D        	sta	[ADRESS],Y
00C4AB  1               	.ELSE
00C4AB  1               	STA	(ADRESS),Y	;update data
00C4AB  1               	.ENDIF
00C4AB  1               
00C4AB  1               ;	plp
00C4AB  1               
00C4AB  1               	.IF PLATFORM = 1
00C4AB  1               
00C4AB  1               ;	php
00C4AB  1               ;	cmp	#$FF
00C4AB  1               ;	beq	PRTCRS		;print cursor
00C4AB  1               PRTCH0:
00C4AB  1               	asl
00C4AB  1               	sta	FRMADR
00C4AB  1               	lda	#0
00C4AB  1               	rol
00C4AB  1               	asl	FRMADR
00C4AB  1               	rol
00C4AB  1               	asl	FRMADR
00C4AB  1               	rol
00C4AB  1               	adc 	#(>charset)		;carry is clear at this point
00C4AB  1               	sta	FRMADR+1
00C4AB  1               	plp
00C4AB  1               
00C4AB  1               PRTCH2:	ldy 	#7
00C4AB  1               PRTCH1:	lda 	(FRMADR),y
00C4AB  1               	bcc	PRTCH3
00C4AB  1               	eor	#$FF
00C4AB  1               PRTCH3:	sta	(CHRPTR),y
00C4AB  1               	dey
00C4AB  1               	bpl	PRTCH1
00C4AB  1               	.ENDIF
00C4AB  1               
00C4AB  1  60           	rts
00C4AC  1               
00C4AC  1               	.IF PLATFORM = 1
00C4AC  1               PRTCHR:	php
00C4AC  1               	jmp	PRTCH0
00C4AC  1               	.ENDIF
00C4AC  1               
00C4AC  1               ;PRTCRS:	ldy 	#7
00C4AC  1               ;PRTCR1:	lda 	(CHRPTR),y
00C4AC  1               ;	eor	#$FF
00C4AC  1               ;	sta	(CHRPTR),y
00C4AC  1               ;	dey
00C4AC  1               ;	bpl	PRTCR1
00C4AC  1               ;	rts
00C4AC  1               
00C4AC  1               ;;	SEC - Set Exit Conditions
00C4AC  1               ;
00C4AC  1               ;	ENTRY	JSR	SEC
00C4AC  1               ;
00C4AC  1               ;	MODS
00C4AC  1               ;		Original Author Unknown
00C4AC  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C4AC  1               ;		   R. K. Nordin	11/01/83
00C4AC  1               
00C4AC  1               
00C4AC  1               SEC_:	;=	;	;entry
00C4AC  1  20 4E C4     	JSR	GDC	;get data under cursor
00C4AF  1  85 40        	STA	OLDCHR
00C4B1  1               ;	LDX	DINDEX	;mode
00C4B1  1               ;	BNE	SST	;if graphics, no cursor
00C4B1  1               
00C4B1  1               ;	LDX	CRSINH	;cursor inhibit flag
00C4B1  1               ;	BNE	SST	;if cursor inhibited
00C4B1  1               
00C4B1  1               ;	EOR	#$80	;complement most significant bit
00C4B1  1               ;	lda	#'_'
00C4B1  1  38           	sec
00C4B2  1  20 8F C4     	JSR	SPQ		;display
00C4B5  1               ;	JMP	SST	;perform screen status, return
00C4B5  1               
00C4B5  1               ;;	SST - Perform Screen STATUS
00C4B5  1               ;
00C4B5  1               ;	ENTRY	JSR	SST
00C4B5  1               ;
00C4B5  1               ;	MODS
00C4B5  1               ;		Original Author Unknown
00C4B5  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C4B5  1               ;		   R. K. Nordin	11/01/83
00C4B5  1               
00C4B5  1               
00C4B5  1               SST:	;=	;	;entry
00C4B5  1  A4 32        	LDY	DSTAT	;status
00C4B7  1  4C BE C4     	JMP	SST1	;continue
00C4BA  1               ;	SUBTTL	'$F223 Patch'
00C4BA  1               
00C4BA  1               ;	FIX	$F223
00C4BA  1               
00C4BA  1               ;;	F223 - $F223 Patch
00C4BA  1               ;
00C4BA  1               ;	For compatibility with OS Revision B, perform power-up display.
00C4BA  1               
00C4BA  1               
00C4BA  1               PPD:	;=	;	;entry
00C4BA  1  4C BD C4     	JMP	SES	;select and execute self-test
00C4BD  1               ;	SUBTTL	'Keyboard, Editor and Screen Handler, Part 3'
00C4BD  1               
00C4BD  1               ;	Continue.
00C4BD  1               
00C4BD  1  60           SES:	RTS
00C4BE  1               
00C4BE  1  A9 01        SST1:	LDA	#SUCCES	;indicate success
00C4C0  1  85 32        	STA	DSTAT	;status
00C4C2  1  AD 40 02     	LDA	ATACHR	;data
00C4C5  1               ;	JMP	ESP	;return
00C4C5  1               
00C4C5  1               ;;	ESP - Perform Editor SPECIAL
00C4C5  1               ;
00C4C5  1               ;	ESP does nothing.
00C4C5  1               ;
00C4C5  1               ;	ENTRY	JSR	ESP
00C4C5  1               ;
00C4C5  1               ;	MODS
00C4C5  1               ;		Original Author Unknown
00C4C5  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C4C5  1               ;		   R. K. Nordin	11/01/83
00C4C5  1               
00C4C5  1               
00C4C5  1               ESP:	;=	;	;entry
00C4C5  1  60           	RTS		;return
00C4C6  1               
00C4C6  1               ;;	ECL - Perform Editor CLOSE
00C4C6  1               ;
00C4C6  1               ;	ENTRY	JSR	ECL
00C4C6  1               ;
00C4C6  1               ;	MODS
00C4C6  1               ;		Original Author Unknown
00C4C6  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C4C6  1               ;		   R. K. Nordin	11/01/83
00C4C6  1               
00C4C6  1               
00C4C6  1               ECL:	;=	;	;entry
00C4C6  1               
00C4C6  1  4C B5 C4     	jmp	SST
00C4C9  1               ;	Check for fine scrolling.
00C4C9  1               
00C4C9  1               ;	BIT	FINE	;fine scrolling flag
00C4C9  1               ;	BPL	SST	;if not fine scrolling, perform STA:
00C4C9  1               
00C4C9  1               ;	Process fine scrolling.
00C4C9  1               
00C4C9  1               ;	LDA	#$40
00C4C9  1               ;	STA	NMIEN		;disable DLI
00C4C9  1               ;	LDA	#0		;clear fine scrolling flag
00C4C9  1               ;	STA	FINE
00C4C9  1               ;	LDA	#<RIR		;return from interrupt rout:
00C4C9  1               ;	STA	VDSLST		;restore initial DLI vector:
00C4C9  1               ;	LDA	#>RIR
00C4C9  1               ;	STA	VDSLST+1
00C4C9  1               ;	JMP	EOP		;perform editor OPEN, retur:
00C4C9  1               
00C4C9  1               ;;	RIR - Return from Interrupt
00C4C9  1               ;
00C4C9  1               ;	ENTRY	JMP	RIR
00C4C9  1               ;
00C4C9  1               ;	EXIT
00C4C9  1               ;		Exits via RTI
00C4C9  1               ;
00C4C9  1               ;	MODS
00C4C9  1               ;		Original Author Unknown
00C4C9  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C4C9  1               ;		   R. K. Nordin	11/01/83
00C4C9  1               
00C4C9  1               
00C4C9  1               RIR:	;=	;	;entry
00C4C9  1  40           	RTI		;return
00C4CA  1               
00C4CA  1               ;;	EGB - Perform Editor GET-BYTE
00C4CA  1               ;
00C4CA  1               ;	ENTRY	JSR	EGB
00C4CA  1               ;
00C4CA  1               ;	MODS
00C4CA  1               ;		Original Author Unknown
00C4CA  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C4CA  1               ;		   R. K. Nordin	11/01/83
00C4CA  1               
00C4CA  1               
00C4CA  1               EGB:	;=	*	;entry
00C4CA  1               
00C4CA  1               ;	Initialize.
00C4CA  1               
00C4CA  1  20 0C CA     	JSR	SWA_	;swap
00C4CD  1  20 FB C7     	JSR	CRE	;check cursor range for editor
00C4D0  1  A5 4C        	LDA	BUFCNT	;buffer count
00C4D2  1               ;	jsr	jprinthex
00C4D2  1               ;	lda	BUFCNT
00C4D2  1  D0 34        	BNE	EGB4	;if something in the buffer
00C4D4  1               
00C4D4  1               ;	Get line.
00C4D4  1               
00C4D4  1  A5 37        	LDA	ROWCRS		;cursor row
00C4D6  1  85 4D        	STA	BUFSTR		;buffer start pointer
00C4D8  1  A5 38        	LDA	COLCRS		;low cursor column
00C4DA  1  85 4E        	STA	BUFSTR+1	;high buffer start pointer
00C4DC  1               
00C4DC  1  20 43 C1     EGB1:	JSR	KGB	;perform keyboard GET-BYTE
00C4DF  1  84 32        	STY	DSTAT	;status
00C4E1  1  AD 40 02     	LDA	ATACHR	;ATASCII character
00C4E4  1  C9 0A        	CMP	#EOL
00C4E6  1  F0 12        	BEQ	EGB3	;if EOL
00C4E8  1               
00C4E8  1  20 3E C5     	JSR	PCH	;process character
00C4EB  1  20 0C CA     	JSR	SWA_	;swap
00C4EE  1  A5 44        	LDA	LOGCOL	;logical column
00C4F0  1  C9 71        	CMP	#113	;column near column 120
00C4F2  1  D0 03        	BNE	EGB2	; if not near column 120, no beep
00C4F4  1               
00C4F4  1  20 F1 C6     	JSR	BEL	;beep
00C4F7  1               
00C4F7  1  4C DC C4     EGB2:	JMP	EGB1	;process new character
00C4FA  1               
00C4FA  1               ;	Process EOL.
00C4FA  1               
00C4FA  1  20 39 C8     EGB3:	JSR	ROD		;restore old data under cur:
00C4FD  1  20 5B C9     	JSR	CBC		;compute buffer count
00C500  1  A5 4D        	LDA	BUFSTR		;buffer start pointer
00C502  1  85 37        	STA	ROWCRS		;cursor row
00C504  1  A5 4E        	LDA	BUFSTR+1	;high buffer start pointer
00C506  1  85 38        	STA	COLCRS		;low cursor column
00C508  1               
00C508  1               ;	Check buffer count.
00C508  1               
00C508  1  A5 4C        EGB4:	LDA	BUFCNT	;buffer count
00C50A  1  F0 11        	BEQ	EGB6	;if buffer count zero
00C50C  1               
00C50C  1               ;	Decrement and check buffer count.
00C50C  1               
00C50C  1  C6 4C        EGB5:	DEC	BUFCNT	;decrement buffer count
00C50E  1  F0 0D        	BEQ	EGB6	;if buffer count zero
00C510  1               
00C510  1               ;	Check status.
00C510  1               
00C510  1  A5 32        	LDA	DSTAT	;status
00C512  1  30 F8        	BMI	EGB5	;if error, continue decrementing.
00C514  1               
00C514  1               ;	Perform GET-BYTE.
00C514  1               
00C514  1  20 3F C4     	JSR	SGB	;perform screen GET-BYTE
00C517  1  8D 40 02     	STA	ATACHR	;ATASCII character
00C51A  1  4C 0C CA     	JMP	SWA_	;swap, return
00C51D  1               
00C51D  1               ;	Exit.
00C51D  1               
00C51D  1  20 A3 C7     EGB6:	JSR	RWS	;return with scrolling
00C520  1  A9 0A        	LDA	#EOL
00C522  1  8D 40 02     	STA	ATACHR	;ATASCII character
00C525  1  20 AC C4     	JSR	SEC_	;set exit conditions
00C528  1  84 32        	STY	DSTAT	;status
00C52A  1  4C 0C CA     	JMP	SWA_	;swap, return
00C52D  1               
00C52D  1               ;;	IRA - Invoke Routine Pointed to by ADRESS
00C52D  1               ;
00C52D  1               ;	ENTRY	JSR	IRA
00C52D  1               ;
00C52D  1               ;	MODS
00C52D  1               ;		Original Author Unknown
00C52D  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C52D  1               ;		   R. K. Nordin	11/01/83
00C52D  1               
00C52D  1               
00C52D  1               IRA:	;=	;		;entry
00C52D  1  6C 5D 00     	JMP	(ADRESS)	;execute, return
00C530  1               
00C530  1               ;;	EPB - Perform Editor PUT-BYTE
00C530  1               ;
00C530  1               ;	ENTRY	JSR	EPB
00C530  1               ;
00C530  1               ;	MODS
00C530  1               ;		Original Author Unknown
00C530  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C530  1               ;		   R. K. Nordin	11/01/83
00C530  1               
00C530  1               EPB:	;=	;	;entry
00C530  1  8D 40 02     	STA	ATACHR	;ATASCII character
00C533  1  20 0C CA     	JSR	SWA_	;swap
00C536  1  20 FB C7     	JSR	CRE	;check cursor range for editor
00C539  1  A9 00        	LDA	#0
00C53B  1  8D 44 02     	STA	SUPERF	;clear super function flag
00C53E  1               
00C53E  1               ;	JMP	PCH	;process character, return
00C53E  1               
00C53E  1               ;;	PCH - Process Character
00C53E  1               ;
00C53E  1               ;	PCH displays the character or processes control cha:
00C53E  1               ;	super functions (shifted function keys).
00C53E  1               ;
00C53E  1               ;	ENTRY	JSR	PCH
00C53E  1               ;
00C53E  1               ;	MODS
00C53E  1               ;		Original Author Unknown
00C53E  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C53E  1               ;		   R. K. Nordin	11/01/83
00C53E  1               
00C53E  1               
00C53E  1               PCH:	;=	;	;entry
00C53E  1  20 39 C8     	JSR	ROD	;restore old data under cursor
00C541  1  20 E6 C9     	JSR	CCC	;check for control character
00C544  1  F0 09        	BEQ	PCH2	;if control character
00C546  1               
00C546  1               ;	Display character.
00C546  1               
00C546  1  0E 11 02     PCH1:	ASL	ESCFLG	;escape flag
00C549  1  20 67 C4     	JSR	CEL	;check EOL
00C54C  1  4C 0C CA     	JMP	SWA_	;swap, return
00C54F  1               
00C54F  1               ;	Process control character.
00C54F  1               
00C54F  1  AD 42 02     PCH2:	LDA	DSPFLG	;display flag
00C552  1  0D 11 02     	ORA	ESCFLG	;escape flag
00C555  1  D0 EF        	BNE	PCH1	;if display or escape, display chara:
00C557  1               
00C557  1               ;	Continue.
00C557  1               
00C557  1  0E 11 02     	ASL	ESCFLG
00C55A  1  E8           	INX
00C55B  1               
00C55B  1               ;	Check for super function.
00C55B  1               
00C55B  1  AD 44 02     	LDA	SUPERF
00C55E  1  F0 05        	BEQ	PCH3		;if not super function
00C560  1               
00C560  1               ;	Adjust for super function.
00C560  1               
00C560  1  8A           	TXA
00C561  1  18           	CLC
00C562  1  69 2D        	ADC	#TSFR-TCCR-3
00C564  1  AA           	TAX			;adjusted offset
00C565  1               
00C565  1               ;	Process control character or super function.
00C565  1               
00C565  1  BD 9D CB     PCH3:	LDA	TCCR,X		;low routine address
00C568  1  85 5D        	STA	ADRESS
00C56A  1  BD 9E CB     	LDA	TCCR+1,X	;high routine address
00C56D  1  85 5E        	STA	ADRESS+1
00C56F  1  20 2D C5     	JSR	IRA		;invoke routine pointed to :
00C572  1  20 AC C4     	JSR	SEC_		;set exit conditions
00C575  1  4C 0C CA     	JMP	SWA_		;swap, return
00C578  1               
00C578  1               
00C578  1               ;KGB:	;=	;	;entry
00C578  1               ;
00C578  1               ;;	Initialize.
00C578  1               ;
00C578  1               ;KGB1:	LDA	#0
00C578  1               ;	STA	SUPERF	;clear super function flag
00C578  1               ;
00C578  1               ;;	Check for special edit read mode.
00C578  1               ;
00C578  1               ;	LDA	ICAX1Z
00C578  1               ;	LSR	A
00C578  1               ;	BCS	KGB11	;if special edit read mode
00C578  1               ;
00C578  1               ;;	Check for BREAK abort.
00C578  1               ;
00C578  1               ;	LDA	#BRKABT	;assume BREAK abort
00C578  1               ;	LDX	BRKKEY	;BREAK key flag
00C578  1               ;	BEQ	KGB10	;if BREAK abort
00C578  1               ;
00C578  1               ;;	Check for character.
00C578  1               ;
00C578  1               ;	LDA	CH	;key code
00C578  1               ;	CMP	#$FF	;clear code indicator
00C578  1               ;	BEQ	KGB1	;if no character
00C578  1               ;
00C578  1               ;;	Process character.
00C578  1               ;
00C578  1               ;	STA	HOLDCH	;save character
00C578  1               ;	LDX	#$FF	;clear code indicator
00C578  1               ;	STX	CH	;key code
00C578  1               ;
00C578  1               ;;	Sound key click if desired.
00C578  1               ;
00C578  1               ;	LDX	NOCLIK	;click inhibit flag
00C578  1               ;	BNE	KGB2	;if click inhibited
00C578  1               ;
00C578  1               ;	JSR	SKC	;sound key click
00C578  1               ;
00C578  1               ;;	Set offset to key definition.
00C578  1               ;
00C578  1               ;KGB2:	TAY		;save character
00C578  1               ;
00C578  1               ;;	Check for CTRL and SHIFT together.
00C578  1               ;
00C578  1               ;	CPY	#$C0
00C578  1               ;	BCS	IGN	;if CTRL and SHIFT together, ignore
00C578  1               ;
00C578  1               ;;	Convert to ATASCII character.
00C578  1               ;
00C578  1               ;	LDA	(KEYDEF),Y	;ATASCII character
00C578  1               ;
00C578  1               ;;	Set ATASCII character.
00C578  1               ;
00C578  1               ;KGB3:	STA	ATACHR	;ATASCII character
00C578  1               ;	TAX
00C578  1               ;	BMI	KGB4	;if special key
00C578  1               ;
00C578  1               ;	JMP	KGB17	;process shift/control lock
00C578  1               ;
00C578  1               ;;	Check for null character.
00C578  1               ;
00C578  1               ;KGB4:	CMP	#$80
00C578  1               ;	BEQ	IGN	;if null, ignore
00C578  1               ;
00C578  1               ;;	Check for inverse video key.
00C578  1               ;
00C578  1               ;	CMP	#$81
00C578  1               ;	BNE	KGB5	;if not inverse video key
00C578  1               ;
00C578  1               ;;	Process inverse video key.
00C578  1               ;
00C578  1               ;	LDA	INVFLG
00C578  1               ;	EOR	#$80
00C578  1               ;	STA	INVFLG
00C578  1               ;	BCS	IGN	;ignore
00C578  1               ;
00C578  1               ;;	Check for CAPS key.
00C578  1               ;
00C578  1               ;KGB5:	CMP	#$82
00C578  1               ;	BNE	KGB6	;if not CAPS key
00C578  1               ;
00C578  1               ;;	Process CAPS key.
00C578  1               ;
00C578  1               ;	LDA	SHFLOK	;shift/control lock flags
00C578  1               ;	BEQ	KGB7	;if no lock, process CAPS lock
00C578  1               ;
00C578  1               ;	LDA	#$00	;no lock indicator
00C578  1               ;	STA	SHFLOK	;shoft/control lock flags
00C578  1               ;	BEQ	IGN	;ignore
00C578  1               ;
00C578  1               ;;	Check for SHIFT-CAPS key.
00C578  1               ;
00C578  1               ;KGB6:	CMP	#$83
00C578  1               ;	BNE	KGB8	;if not SHIFT-CAPS
00C578  1               ;
00C578  1               ;;	Process SHIFT-CAPS key.
00C578  1               ;
00C578  1               ;KGB7:	LDA	#$40	;CAPS lock indicator
00C578  1               ;	STA	SHFLOK	;shift/control lock flags
00C578  1               ;	BNE	IGN	;ignore
00C578  1               ;
00C578  1               ;;	Check for CTRL-CAPS key.
00C578  1               ;
00C578  1               ;KGB8:	CMP	#$84
00C578  1               ;	BNE	KGB9	;if not CTRL-CAPS
00C578  1               ;
00C578  1               ;;	Process CTRL-CAPS key.
00C578  1               ;
00C578  1               ;	LDA	#$80	;control lock indicator
00C578  1               ;	STA	SHFLOK	;shift/control lock flags
00C578  1               ;	JMP	IGN	;ignore
00C578  1               ;
00C578  1               ;;	Check for CTRL-3 key.
00C578  1               ;
00C578  1               ;KGB9:	CMP	#$85
00C578  1               ;	BNE	KGB12	;if not CTRL-3 key.
00C578  1               ;
00C578  1               ;;	Process CTRL-3 key.
00C578  1               ;
00C578  1               ;	LDA	#EOFERR
00C578  1               ;
00C578  1               ;;	Set status and BREAK key flag.
00C578  1               ;
00C578  1               ;KGB10:	STA	DSTAT	;status
00C578  1               ;	STA	BRKKEY	;BREAK key flag
00C578  1               ;
00C578  1               ;;	Set EOL character.
00C578  1               ;
00C578  1               ;KGB11:	LDA	#EOL
00C578  1               ;	JMP	KGB19	;set ATASCII character
00C578  1               ;
00C578  1               ;;	Check for CTRL-F3 key.
00C578  1               ;
00C578  1               ;KGB12:	CMP	#$89
00C578  1               ;	BNE	KGB14	;if not CTRL-F3 key
00C578  1               ;
00C578  1               ;;	Process CTRL-F3 key.
00C578  1               ;
00C578  1               ;	LDA	NOCLIK	;toggle keyclick status
00C578  1               ;	EOR	#$FF
00C578  1               ;	STA	NOCLIK
00C578  1               ;	BNE	KGB13	;if click inhibited
00C578  1               ;
00C578  1               ;	JSR	SKC	;sound key click
00C578  1               ;
00C578  1               ;KGB13:	JMP	IGN	;ignore
00C578  1               ;
00C578  1               ;;	Check for function key.
00C578  1               ;
00C578  1               ;KGB14:	CMP	#$8E
00C578  1               ;	BCS	KGB16	;if code >= $8E, not a function key
00C578  1               ;
00C578  1               ;	CMP	#$8A
00C578  1               ;	BCC	KGB13	;if code < $8A, not a function key,:
00C578  1               ;
00C578  1               ;;	Process function key.
00C578  1               ;
00C578  1               ;	SBC	#$8A		;convert $8A - $bD to 0 - 3
00C578  1               ;	ASL	HOLDCH		;saved character
00C578  1               ;	BPL	KGB15		;if no SHIFT
00C578  1               ;
00C578  1               ;	ORA	#$04		;convert 0 - 3 to 4 - 7
00C578  1               ;
00C578  1               ;KGB15:	TAY			;offset to function key def:
00C578  1               ;	LDA	(FKDEF),Y	;function key
00C578  1               ;	JMP	KGB3		;set ATASCII character
00C578  1               ;
00C578  1               ;;	Check for super function.
00C578  1               ;
00C578  1               ;KGB16:	CMP	#$92
00C578  1               ;	BCS	KGB17	;if code >= $92, process shift/cont:
00C578  1               ;
00C578  1               ;	CMP	#$8E
00C578  1               ;	BCC	KGB13	;if code < $8E, not super function,:
00C578  1               ;
00C578  1               ;;	Process super function.
00C578  1               ;
00C578  1               ;	SBC	#$8E-$1C	;convert $8E - $91 to $1C -:
00C578  1               ;	INC	SUPERF		;set super function flag
00C578  1               ;	BNE	KGB19		;set ATASCII character
00C578  1               ;
00C578  1               ;;	Process shift/control lock.
00C578  1               ;
00C578  1               ;KGB17:	LDA	HOLDCH	;saved character
00C578  1               ;	CMP	#$40
00C578  1               ;	BCS	KGB18	;if not lower case
00C578  1               ;
00C578  1               ;	LDA	ATACHR	;ATASCII character
00C578  1               ;	CMP	#'a'
00C578  1               ;	BCC	KGB18	;if < "a", do not process
00C578  1               ;
00C578  1               ;	CMP	#'z'+1
00C578  1               ;	BCS	KGB18	;if > "z", do not process
00C578  1               ;
00C578  1               ;	LDA	SHFLOK	;shift/control lock flags
00C578  1               ;	BEQ	KGB18	;if no lock
00C578  1               ;
00C578  1               ;	ORA	HOLDCH	;modify character
00C578  1               ;	JMP	KGB2	;reprocess character
00C578  1               ;
00C578  1               ;;	Invert character, if necessary.
00C578  1               ;
00C578  1               ;KGB18:	JSR	CCC	;check for control character
00C578  1               ;	BEQ	KGB20	;if control character, do not inver:
00C578  1               ;
00C578  1               ;	LDA	ATACHR	;ATASCII character
00C578  1               ;	EOR	INVFLG	;invert character
00C578  1               ;
00C578  1               ;;	Set ATASCII character.
00C578  1               ;
00C578  1               ;KGB19:	STA	ATACHR	;ATASCII character
00C578  1               ;;	Exit
00C578  1               ;
00C578  1               ;KGB20:	JMP	SST	;perform screen status, return
00C578  1               
00C578  1               ;;	ESC - Escape
00C578  1               ;
00C578  1               ;	ENTRY	JSR	ESC
00C578  1               ;
00C578  1               ;	MODS
00C578  1               ;		Original Author Unknown
00C578  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C578  1               ;		   R. K. Nordin	11/01/83
00C578  1               
00C578  1               
00C578  1               ESC_:	;=	;	;entry
00C578  1  A9 80        	LDA	#$80	;indicate escape detected
00C57A  1  8D 11 02     	STA	ESCFLG	;escape flag
00C57D  1  60           	RTS		;return
00C57E  1               
00C57E  1               ;;	CUP - Move Cursor Up
00C57E  1               ;
00C57E  1               ;	ENTRY	JSR	CUP
00C57E  1               ;
00C57E  1               ;	MODS
00C57E  1               ;		Original Author Unknown
00C57E  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C57E  1               ;		   R. K. Nordin	11/01/83
00C57E  1               
00C57E  1               
00C57E  1               CUP:	;=	;	;entry
00C57E  1  C6 37        	DEC	ROWCRS	;decrement cursor row
00C580  1  10 06        	BPL	CUP2	;if row positive
00C582  1               
00C582  1  AE 32 02     	LDX	BOTSCR	;screen bottom
00C585  1  CA           	DEX		;screen bottom - 1
00C586  1               
00C586  1  86 37        CUP1:	STX	ROWCRS	;update cursor row
00C588  1               
00C588  1  4C B6 C9     CUP2:	JMP	SBS	;set buffer start and logical colum:
00C58B  1               
00C58B  1               ;;	CDN - Move Cursor Down
00C58B  1               ;
00C58B  1               ;	ENTRY	JSR	CDN
00C58B  1               ;
00C58B  1               ;	MODS
00C58B  1               ;		Original Author Unknown
00C58B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C58B  1               ;		   R. K. Nordin	11/01/83
00C58B  1               
00C58B  1               
00C58B  1               CDN:	;=	;	;entry
00C58B  1  E6 37        	INC	ROWCRS	;increment cursor row
00C58D  1  A5 37        	LDA	ROWCRS	;cursor row
00C58F  1  CD 32 02     	CMP	BOTSCR	;screen bottom
00C592  1  90 F4        	BCC	CUP2	;if at bottom, set buffer start, re:
00C594  1               
00C594  1  A2 00        	LDX	#0
00C596  1  F0 EE        	BEQ	CUP1	;update cursor row, return
00C598  1               
00C598  1               ;;	CLF - Move Cursor Left
00C598  1               ;
00C598  1               ;	ENTRY	JSR	CLF
00C598  1               ;
00C598  1               ;	MODS
00C598  1               ;		Original Author Unknown
00C598  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C598  1               ;		   R. K. Nordin	11/01/83
00C598  1               
00C598  1               
00C598  1               CLF:	;=	;	;entry
00C598  1  C6 38        	DEC	COLCRS	;decrement low cursor column
00C59A  1  A5 38        	LDA	COLCRS	;low cursor column
00C59C  1  30 04        	BMI	CRM	;if negative, move cursor to margin:
00C59E  1               
00C59E  1  C5 35        	CMP	LMARGN	;left margin
00C5A0  1  B0 04        	BCS	SCC1	;if at left margin, set logical col:
00C5A2  1               
00C5A2  1               ;	JMP	CRM	;move cursor to right margin, retur:
00C5A2  1               
00C5A2  1               ;;	CRM - Move Cursor to Right Margin
00C5A2  1               ;
00C5A2  1               ;	ENTRY	JSR	CRM
00C5A2  1               ;
00C5A2  1               ;	MODS
00C5A2  1               ;		Original Author Unknown
00C5A2  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5A2  1               ;		   R. K. Nordin	11/01/83
00C5A2  1               
00C5A2  1               
00C5A2  1               CRM:	;=	*	;entry
00C5A2  1  A5 36        	LDA	RMARGN	;right margin
00C5A4  1               ;	JMP	SCC	;set cursor column, return
00C5A4  1               
00C5A4  1               ;;	SCC - Set Cursor Column
00C5A4  1               ;
00C5A4  1               ;	ENTRY	JSR	SCC
00C5A4  1               ;
00C5A4  1               ;	MODS
00C5A4  1               ;		Original Author Unknown
00C5A4  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5A4  1               ;		   R. K. Nordin	11/01/83
00C5A4  1               
00C5A4  1               
00C5A4  1               SCC:	;=	;	;entry
00C5A4  1  85 38        	STA	COLCRS	;set low cursor column
00C5A6  1               
00C5A6  1  4C 38 C9     SCC1:	JMP	SLC	;set logical column, return
00C5A9  1               
00C5A9  1               ;;	CRT - Move Cursor Right
00C5A9  1               ;
00C5A9  1               ;	ENTRY	JSR	CRT
00C5A9  1               ;
00C5A9  1               ;	MODS
00C5A9  1               ;		Original Author Unknown
00C5A9  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5A9  1               ;		   R. K. Nordin	11/01/83
00C5A9  1               
00C5A9  1               
00C5A9  1               CRT:	;=	;	;entry
00C5A9  1  E6 38        	INC	COLCRS	;increment low cursor column
00C5AB  1  A5 38        	LDA	COLCRS	;low cursor column
00C5AD  1  C5 36        	CMP	RMARGN	;right margin
00C5AF  1  90 F5        	BCC	SCC1	;if before right margin, process, r:
00C5B1  1               
00C5B1  1  F0 F3        	BEQ	SCC1	;if at right margin
00C5B3  1               
00C5B3  1               ;	JMP	CLM	;move cursor to left margin, return
00C5B3  1               
00C5B3  1               ;;	CLM - Move Cursor to Left Margin
00C5B3  1               ;
00C5B3  1               ;	ENTRY	JSR	CLM
00C5B3  1               ;
00C5B3  1               ;	MODS
00C5B3  1               ;		Original Author Unknown
00C5B3  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5B3  1               ;		   R. K. Nordin	11/01/83
00C5B3  1               
00C5B3  1               
00C5B3  1               CLM:	;=	;	;entry
00C5B3  1  A5 35        	LDA	LMARGN	;left margin
00C5B5  1  4C A4 C5     	JMP	SCC	;set cursor column, return
00C5B8  1               
00C5B8  1               ;;	CSC - Clear Screen
00C5B8  1               ;
00C5B8  1               ;	ENTRY	JSR	CSC
00C5B8  1               ;
00C5B8  1               ;	MODS
00C5B8  1               ;		Original Author Unknown
00C5B8  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5B8  1               ;		   R. K. Nordin	11/01/83
00C5B8  1               
00C5B8  1               
00C5B8  1               CSC:	;=	;	;entry
00C5B8  1               
00C5B8  1               ;	Set memory scan counter address.
00C5B8  1               
00C5B8  1               	.IF PLATFORM = 1
00C5B8  1               	jsr	clrcrt
00C5B8  1               	.ENDIF
00C5B8  1               
00C5B8  1  20 39 CA     	JSR	SMS	;set memory scan counter ad:
00C5BB  1               
00C5BB  1               ;	Clear address.
00C5BB  1               
00C5BB  1  A4 5D        	LDY	ADRESS
00C5BD  1  A9 00        	LDA	#0
00C5BF  1               ;	STA	ADRESS
00C5BF  1               
00C5BF  1               CSC1:	.IF PLATFORM=0
00C5BF  1  97 5D        	sta	[ADRESS],y
00C5C1  1               	.ELSE
00C5C1  1               	STA	(ADRESS),Y
00C5C1  1               	.ENDIF
00C5C1  1               
00C5C1  1  C8           	INY
00C5C2  1  D0 FB        	BNE	CSC1		;if not done with page
00C5C4  1               
00C5C4  1  E6 5E        	INC	ADRESS+1
00C5C6  1  A6 5E        	LDX	ADRESS+1
00C5C8  1  E4 4B        	CPX	RAMTOP		;(high) RAM size
00C5CA  1  D0 F3        	BNE	CSC1		;if not done
00C5CC  1               
00C5CC  1               ;	Clean up logical line bit map
00C5CC  1               
00C5CC  1               ;	LDY	#0		;offset to first byte of bi:
00C5CC  1  A9 FF        	LDA	#$FF
00C5CE  1               
00C5CE  1  99 21 02     CSC2:	STA	LOGMAP,Y	;byte of logical line bit m:
00C5D1  1  C8           	INY
00C5D2  1  C0 04        	CPY	#4		;4 bytes
00C5D4  1  90 F8        	BCC	CSC2		;if not done
00C5D6  1               
00C5D6  1               ;	Exit.
00C5D6  1               
00C5D6  1               ;	JMP	CHM		;move cursor home, return
00C5D6  1               
00C5D6  1               ;;	CHM - Move Cursor Home
00C5D6  1               ;
00C5D6  1               ;	ENTRY	JSR	CHM
00C5D6  1               ;
00C5D6  1               ;	MODS
00C5D6  1               ;		Original Author Unknown
00C5D6  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5D6  1               ;		   R. K. Nordin	11/01/83
00C5D6  1               
00C5D6  1               
00C5D6  1               CHM:	;=	;		;entry
00C5D6  1  20 2E CA     	JSR	SCL		;set cursor at left edge
00C5D9  1  85 44        	STA	LOGCOL		;logical column
00C5DB  1  85 4E        	STA	BUFSTR+1	;high buffer start
00C5DD  1  A9 00        	LDA	#0
00C5DF  1  85 37        	STA	ROWCRS		;cursor row
00C5E1  1  85 39        	STA	COLCRS+1	;high cursor column
00C5E3  1  85 4D        	STA	BUFSTR		;low buffer start pointer
00C5E5  1  60           	RTS			;return
00C5E6  1               
00C5E6  1               ;;	BSP - Backspace
00C5E6  1               ;
00C5E6  1               ;	ENTRY	JSR	BSP
00C5E6  1               ;
00C5E6  1               ;	MODS
00C5E6  1               ;		Original Author Unknown
00C5E6  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C5E6  1               ;		   R. K. Nordin	11/01/83
00C5E6  1               
00C5E6  1               
00C5E6  1               BSP:	;=	;	;entry
00C5E6  1  A5 44        	LDA	LOGCOL	;logical column
00C5E8  1  C5 35        	CMP	LMARGN	;left margin
00C5EA  1  F0 21        	BEQ	BSP3	;if at left margin
00C5EC  1               
00C5EC  1  A5 38        	LDA	COLCRS	;low cursor column
00C5EE  1  C5 35        	CMP	LMARGN	;left margin
00C5F0  1  D0 03        	BNE	BSP1	;if not atleft margin
00C5F2  1               
00C5F2  1  20 CD C9     	JSR	DWQ	;see if line should be deleted
00C5F5  1               
00C5F5  1  20 98 C5     BSP1:	JSR	CLF	;move cursor left
00C5F8  1  A5 38        	LDA	COLCRS	;low cursor column
00C5FA  1  C5 36        	CMP	RMARGN	;right margin
00C5FC  1  D0 07        	BNE	BSP2	;if not at right margin
00C5FE  1               
00C5FE  1  A5 37        	LDA	ROWCRS	;cursor low
00C600  1  F0 03        	BEQ	BSP2	;if row zero
00C602  1               
00C602  1  20 7E C5     	JSR	CUP	;move cursor up
00C605  1               
00C605  1  A9 20        BSP2:	LDA	#' '
00C607  1  8D 40 02     	STA	ATACHR	;ATASCII character
00C60A  1  20 7D C4     	JSR	PLO	;plot point
00C60D  1               
00C60D  1  4C 38 C9     BSP3:	JMP	SLC	;set logical column, return
00C610  1               
00C610  1               ;;	TAB - Tab
00C610  1               ;
00C610  1               ;	ENTRY	JSR	TAB
00C610  1               ;
00C610  1               ;	MODS
00C610  1               ;		Original Author Unknown
00C610  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C610  1               ;		   R. K. Nordin	11/01/83
00C610  1               
00C610  1               
00C610  1               TAB:	;=	*	;entry
00C610  1               
00C610  1  20 A9 C5     TAB1:	JSR	CRT	;move cursor right
00C613  1  A5 38        	LDA	COLCRS	;low cursor column
00C615  1  C5 35        	CMP	LMARGN	;left margin
00C617  1  D0 08        	BNE	TAB2	;if not at left margin
00C619  1               
00C619  1  20 A7 C7     	JSR	RET	;return
00C61C  1  20 79 C8     	JSR	BLG	;get bit from logical line bit map
00C61F  1  B0 07        	BCS	TAB3	;if end of logical line
00C621  1               
00C621  1               ;	Check for tab stop.
00C621  1               
00C621  1  A5 44        TAB2:	LDA	LOGCOL	;logical column
00C623  1  20 7E C8     	JSR	BMG	;set bit from bit map
00C626  1  90 E8        	BCC	TAB1	;if not tab stop, keep looking
00C628  1               
00C628  1               ;	Set logical lolumn
00C628  1               
00C628  1  4C 38 C9     TAB3:	JMP	SLC	;set logical column, return
00C62B  1               
00C62B  1               ;;	STB - Set Tab
00C62B  1               ;
00C62B  1               ;	ENTRY	JSR	STB
00C62B  1               ;
00C62B  1               ;	MODS
00C62B  1               ;		Original Author Unknown
00C62B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C62B  1               ;		   R. K. Nordin	11/01/83
00C62B  1               
00C62B  1               
00C62B  1               STB:	;=	;	;entry
00C62B  1  A5 44        	LDA	LOGCOL	;logical column
00C62D  1  4C 5F C8     	JMP	BMS	;set bit in bit map, retrun
00C630  1               
00C630  1               ;;	CTB - Clear Tab
00C630  1               ;
00C630  1               ;	ENTRY	JSR	CTB
00C630  1               ;
00C630  1               ;	MODS
00C630  1               ;		Original Author Unknown
00C630  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C630  1               ;		   R. K. Nordin	11/01/83
00C630  1               
00C630  1               
00C630  1               CTB:	;=	;	;entry
00C630  1  A5 44        	LDA	LOGCOL	;logical column
00C632  1  4C 6B C8     	JMP	BMC	;clear bit in bit map, return
00C635  1               
00C635  1               ;;	ICH - Insert Character
00C635  1               ;
00C635  1               ;	ENTRY	JSR	ICH
00C635  1               ;
00C635  1               ;	MODS
00C635  1               ;		Original Author Unknown
00C635  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C635  1               ;		   R. K. Nordin	11/01/83
00C635  1               
00C635  1               
00C635  1               ICH:	;=	*	;entry
00C635  1  20 F6 C9     	JSR	SRC	;save row and column
00C638  1  20 4E C4     	JSR	GDC	;get data under cursor
00C63B  1  85 5A        	STA	INSDAT
00C63D  1  A9 00        	LDA	#0
00C63F  1  8D 2E 02     	STA	SCRFLG
00C642  1               
00C642  1  18           ICH1:	clc
00C643  1  20 8F C4     	JSR	SPQ	;store data
00C646  1  A5 44        	LDA	LOGCOL	;logical column
00C648  1  48           	PHA		;save logical column
00C649  1  20 5F C7     	JSR	ACC	;advance cursor column
00C64C  1  68           	PLA		;saved logical column
00C64D  1  C5 44        	CMP	LOGCOL	;logical column
00C64F  1  B0 0C        	BCS	ICH2	;if saved logical column >= logical:
00C651  1               
00C651  1  A5 5A        	LDA	INSDAT
00C653  1  48           	PHA
00C654  1  20 4E C4     	JSR	GDC	;get data under cursor
00C657  1  85 5A        	STA	INSDAT
00C659  1  68           	PLA
00C65A  1  4C 42 C6     	JMP	ICH1	;continue
00C65D  1               
00C65D  1               ;	Exit.
00C65D  1               
00C65D  1  20 01 CA     ICH2:	JSR	RRC	;restore row and column
00C660  1               
00C660  1  CE 2E 02     ICH3:	DEC	SCRFLG
00C663  1  30 04        	BMI	ICH4	;if scroll occured
00C665  1               
00C665  1  C6 37        	DEC	ROWCRS	;decrement cursor row
00C667  1  D0 F7        	BNE	ICH3	;continue
00C669  1               
00C669  1  4C 38 C9     ICH4:	JMP	SLC	;set logical column, return
00C66C  1               
00C66C  1               ;;	DCH - Delete Character
00C66C  1               ;
00C66C  1               ;	ENTRY	JSR	DCH
00C66C  1               ;
00C66C  1               ;	MODS
00C66C  1               ;		Original Author Unknown
00C66C  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C66C  1               ;		   R. K. Nordin	11/01/83
00C66C  1               
00C66C  1               
00C66C  1               DCH:	;=	*		;entry
00C66C  1               
00C66C  1               ;	Save row and column.
00C66C  1               
00C66C  1  20 F6 C9     	JSR	SRC		;save row and column
00C66F  1               ;	dec	DEVICNO
00C66F  1               ;	lda	#'*'
00C66F  1               ;	jsr	jchrout
00C66F  1               ;	inc	DEVICNO
00C66F  1               
00C66F  1               ;	Get data to the right of cursor.
00C66F  1               
00C66F  1  20 1A C7     DCH1:	JSR	CCA		;convert cursor row/column to addre:
00C672  1  A5 5D        	LDA	ADRESS
00C674  1  85 48        	STA	SAVADR		;save address
00C676  1  A5 5E        	LDA	ADRESS+1
00C678  1  85 49        	STA	SAVADR+1
00C67A  1               	.IF PLATFORM=0
00C67A  1  A5 5F        	LDA	ADRESS+2
00C67C  1  85 4A        	STA	SAVADR+2
00C67E  1               	.ENDIF
00C67E  1  A5 44        	LDA	LOGCOL		;logical column
00C680  1  48           	PHA			;save lgical column
00C681  1  20 57 C7     	JSR	SZA		;set zero data and advance cursor
00C684  1  68           	PLA			;saved logical column
00C685  1  C5 44        	CMP	LOGCOL		;logical column
00C687  1  B0 10        	BCS	DCH2		;if saved logical column >= logical
00C689  1               
00C689  1  A5 37        	LDA	ROWCRS		;cursor row
00C68B  1  CD 32 02     	CMP	BOTSCR		;screen bottom
00C68E  1  B0 09        	BCS	DCH2		;if row off screem, exit
00C690  1               
00C690  1  20 4E C4     	JSR	GDC		;get data under cursor
00C693  1  A0 00        	LDY	#0
00C695  1               	.IF PLATFORM=0
00C695  1  97 48        	sta	[SAVADR],Y
00C697  1               	.ELSE
00C697  1               	STA	(SAVADR),Y	;put data in previous posit:
00C697  1               	.ENDIF
00C697  1               
00C697  1               	.IF PLATFORM = 1
00C697  1               	jsr	DCH3
00C697  1               	jmp	DCH1
00C697  1               	.ENDIF
00C697  1               
00C697  1  F0 D6        	BEQ	DCH1		;continue
00C699  1               
00C699  1  A0 00        DCH2:	LDY	#0
00C69B  1  98           	TYA
00C69C  1               ;	STA	(SAVADR),Y	;clear last position
00C69C  1               	.IF PLATFORM=0
00C69C  1  97 48        	sta	[SAVADR],Y
00C69E  1               	.ELSE
00C69E  1               	STA	(SAVADR),Y	;put data in previous posit:
00C69E  1               	.ENDIF
00C69E  1               
00C69E  1               	.IF PLATFORM = 1
00C69E  1               	jsr	DCH3
00C69E  1               	.ENDIF
00C69E  1               
00C69E  1  20 C2 C9     	JSR	DQQ		;try to delete a line
00C6A1  1  20 01 CA     	JSR	RRC		;restore row and column
00C6A4  1  4C 38 C9     	JMP	SLC		;set logical column, return
00C6A7  1               
00C6A7  1               	.IF PLATFORM = 1
00C6A7  1               DCH3:	tay
00C6A7  1               	lda	SAVADR
00C6A7  1               	asl
00C6A7  1               	sta	CHRPTR
00C6A7  1               
00C6A7  1               	lda	SAVADR+1
00C6A7  1               	and	#%00000111
00C6A7  1               	rol
00C6A7  1               	asl	CHRPTR
00C6A7  1               	rol
00C6A7  1               	asl	CHRPTR
00C6A7  1               	rol
00C6A7  1               	adc	#>SCRSTRT
00C6A7  1               	sta	CHRPTR+1
00C6A7  1               
00C6A7  1               	tya
00C6A7  1               	clc
00C6A7  1               	jmp	PRTCHR
00C6A7  1               	.ENDIF
00C6A7  1               
00C6A7  1               ;;	ILN - Insert Line
00C6A7  1               ;
00C6A7  1               ;	ENTRY	JSR	ILN
00C6A7  1               ;
00C6A7  1               ;	MODS
00C6A7  1               ;		Original Author Unknown
00C6A7  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C6A7  1               ;		   R. K. Nordin	11/01/83
00C6A7  1               
00C6A7  1               
00C6A7  1               ILN:	;=	;	;entry
00C6A7  1  38           	SEC
00C6A8  1               ;	JMP	ILN1
00C6A8  1               
00C6A8  1               ;;	ILN1 - Insert Line
00C6A8  1               ;
00C6A8  1               ;	ENTRY	JSR	ILN1
00C6A8  1               ;
00C6A8  1               ;	MODS
00C6A8  1               ;		Original Author Unknown
00C6A8  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C6A8  1               ;		   R. K. Nordin	11/01/83
00C6A8  1               
00C6A8  1               
00C6A8  1               ILN1:	;=	;	;entry
00C6A8  1  20 CD C8     	JSR	ELL	;extend logical line
00C6AB  1  A5 35        	LDA	LMARGN	;left margin
00C6AD  1  85 38        	STA	COLCRS	;low cursor column
00C6AF  1  20 1A C7     	JSR	CCA	;convert cursor row/column to addre:
00C6B2  1  20 92 C8     	JSR	MLN	;move line
00C6B5  1  20 ED C8     	JSR	CLN	;clear current line
00C6B8  1  4C 38 C9     	JMP	SLC	;set logical column, return
00C6BB  1               
00C6BB  1               ;;	DLN - Delete Line
00C6BB  1               ;
00C6BB  1               ;	ENTRY	JSR	DLN
00C6BB  1               ;
00C6BB  1               ;	MODS
00C6BB  1               ;		Original Author Unknown
00C6BB  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C6BB  1               ;		   R. K. Nordin	11/01/83
00C6BB  1               
00C6BB  1               
00C6BB  1               DLN:	;=	;	;entry
00C6BB  1  20 38 C9     	JSR	SLC	;set logical column
00C6BE  1  A4 34        	LDY	HOLD1
00C6C0  1  84 37        	STY	ROWCRS	;cursor row
00C6C2  1               ;	JMP	DLN1
00C6C2  1               
00C6C2  1               ;;	DLN1 - Delete Line
00C6C2  1               ;
00C6C2  1               ;	ENTRY	JSR	DLN1
00C6C2  1               ;
00C6C2  1               ;	MODS
00C6C2  1               ;		Original Author Unknown
00C6C2  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C6C2  1               ;		   R. K. Nordin	11/01/83
00C6C2  1               
00C6C2  1               
00C6C2  1               DLN1:	;=	;		;entry
00C6C2  1               
00C6C2  1  A4 37        DLN0:	LDY	ROWCRS		;cursor row
00C6C4  1               
00C6C4  1  98           DLN2:	TYA
00C6C5  1  38           	SEC
00C6C6  1  20 7C C8     	JSR	BLG2		;get next bit
00C6C9  1  08           	PHP
00C6CA  1  98           	TYA
00C6CB  1  18           	CLC
00C6CC  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00C6CE  1  28           	PLP
00C6CF  1  20 5D C8     	JSR	BMP		;put bit in bit map
00C6D2  1  C8           	INY
00C6D3  1  C0 19        	CPY	#NUMROWS
00C6D5  1  D0 ED        	BNE	DLN2		;if not done
00C6D7  1               
00C6D7  1  AD 23 02     	LDA	LOGMAP+2
00C6DA  1  09 01        	ORA	#1		;set least significant bit
00C6DC  1  8D 23 02     	STA	LOGMAP+2	;update logical line bit ma:
00C6DF  1  A9 00        	LDA	#0		;delete line of data
00C6E1  1  85 38        	STA	COLCRS		;low cursor column
00C6E3  1  20 1A C7     	JSR	CCA		;convert cursor row/column :
00C6E6  1               
00C6E6  1  20 09 C9     	JSR	SSD		;scroll screen for delete
00C6E9  1               
00C6E9  1               ;	Check for new logical line.
00C6E9  1               
00C6E9  1  20 79 C8     	JSR	BLG		;get bit from logical line :
00C6EC  1  90 D4        	BCC	DLN0		;if not new logical line
00C6EE  1               
00C6EE  1               ;	Move cursor to left margin.
00C6EE  1               
00C6EE  1  4C B3 C5     	JMP	CLM		;move cursor to left margin:
00C6F1  1               
00C6F1  1               ;;	BEL - Sound Bell
00C6F1  1               ;
00C6F1  1               ;	ENTRY	JSR	BEL
00C6F1  1               ;
00C6F1  1               ;	MODS
00C6F1  1               ;		Original Author Unknown
00C6F1  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C6F1  1               ;		   R. K. Nordin	11/01/83
00C6F1  1               
00C6F1  1               
00C6F1  1               BEL:	;=	;	;entry
00C6F1  1  A0 20        	LDY	#$20
00C6F3  1               
00C6F3  1  20 2D CA     BEL1:	JSR	SKC	;sound key click
00C6F6  1  88           	DEY
00C6F7  1  10 FA        	BPL	BEL1	;if not done
00C6F9  1               
00C6F9  1  60           	RTS		;return
00C6FA  1               
00C6FA  1               ;;	CBT - Move Cursor to Bottom
00C6FA  1               ;
00C6FA  1               ;	ENTRY	JSR	CBT
00C6FA  1               ;
00C6FA  1               ;	MODS
00C6FA  1               ;		Original Author Unknown
00C6FA  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C6FA  1               ;		   R. K. Nordin	11/01/83
00C6FA  1               
00C6FA  1               
00C6FA  1               CBT:	;=	;	;entry
00C6FA  1  20 D6 C5     	JSR	CHM	;move cursor home
00C6FD  1  4C 7E C5     	JMP	CUP	;move cursor up, return
00C700  1               
00C700  1               ;;	DDD - Perform Double Byte Double Decrement
00C700  1               ;
00C700  1               ;	ENTRY	JSR	DDD
00C700  1               ;
00C700  1               ;	MODS
00C700  1               ;		Original Author Unknown
00C700  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C700  1               ;		   R. K. Nordin	11/01/83
00C700  1               
00C700  1               
00C700  1               DDD:	;=	;	;entry
00C700  1  A9 02        	LDA	#2	;indicate subtracting 2
00C702  1  D0 02        	BNE	DBS	;perform double byte subtract, retu:
00C704  1               
00C704  1               ;;	SDF - Store Data Indirect for Fine Scrolling
00C704  1               ;
00C704  1               ;	ENTRY	JSR	SDF
00C704  1               ;
00C704  1               ;	MODS
00C704  1               ;		Original Author Unknown
00C704  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C704  1               ;		   R. K. Nordin	11/01/83
00C704  1               
00C704  1               
00C704  1               ;SDF:	;=	;	;entry
00C704  1               ;	jmp	SDI
00C704  1               
00C704  1               ;	LDY	FINE
00C704  1               ;	BEQ	SDI	;if not fine scrolling
00C704  1               
00C704  1               ;	ORA	#$20	;enable vertical scroll
00C704  1               ;	JMP	SDI	;store data indirect, return
00C704  1               
00C704  1               ;;	SDI - Store Data Indirect
00C704  1               ;
00C704  1               ;	ENTRY	JSR	SDI
00C704  1               ;
00C704  1               ;	MODS
00C704  1               ;		Original Author Unknown
00C704  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C704  1               ;		   R. K. Nordin	11/01/83
00C704  1               
00C704  1               
00C704  1               ;SDI:	;=	;	;entry
00C704  1               
00C704  1               ;	Check current status.
00C704  1               
00C704  1               ;	LDY	DSTAT	;status
00C704  1               ;	BMI	DBS3	;if error, return
00C704  1               
00C704  1               ;	Store data.
00C704  1               
00C704  1               ;	LDY	#0
00C704  1               ;	STA	(ADRESS),Y
00C704  1               
00C704  1               ;	Decrement.
00C704  1               
00C704  1               ;	JMP	DSD	;perform double byte single decreme:
00C704  1               
00C704  1               ;;	DSD - Perform Double Byte Single Decrement
00C704  1               ;
00C704  1               ;	ENTRY	JSR	DSD
00C704  1               ;
00C704  1               ;	MODS
00C704  1               ;		Original Author Unknown
00C704  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C704  1               ;		   R. K. Nordin	11/01/83
00C704  1               
00C704  1               
00C704  1               DSD:	;=	;	;entry
00C704  1  A9 01        	LDA	#1	;indicate subtracting 1
00C706  1               ;	JMP	DBS	;perform double byte subtract, retu:
00C706  1               
00C706  1               ;;	DBS - Perform Double Byte Subtract
00C706  1               ;
00C706  1               ;	ENTRY	JSR	DBS
00C706  1               ;
00C706  1               ;	MODS
00C706  1               ;		Original Author Unknown
00C706  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C706  1               ;		   R. K. Nordin	11/01/83
00C706  1               
00C706  1               
00C706  1               DBS:	;=	;	;entry
00C706  1               
00C706  1               ;	Initialize.
00C706  1               
00C706  1  8D 0D 02     	STA	SUBTMP
00C709  1               
00C709  1               ;	Check current status.
00C709  1               
00C709  1  A5 32        	LDA	DSTAT		;status
00C70B  1  30 0C        	BMI	DBS3		;if error
00C70D  1               
00C70D  1               ;	Subtract.
00C70D  1               
00C70D  1  A5 5D        	LDA	ADRESS
00C70F  1  38           	SEC
00C710  1  ED 0D 02     	SBC	SUBTMP
00C713  1  85 5D        	STA	ADRESS
00C715  1  B0 02        	BCS	DBS1		;if no borrow
00C717  1               
00C717  1  C6 5E        	DEC	ADRESS+1	;adjust high byte
00C719  1               
00C719  1               ;	Check for overwriting APPMHI.
00C719  1               
00C719  1               DBS1:
00C719  1               ;	LDA	APPMHI+1
00C719  1               ;	CMP	ADRESS+1
00C719  1               ;	BCC	DBS3		;if not overwriting APPMHI
00C719  1               
00C719  1               ;	BNE	DBS2		;if overwriting APPMHI, err:
00C719  1               
00C719  1               ;	LDA	APPMHI
00C719  1               ;	CMP	ADRESS
00C719  1               ;	BCC	DBS3		;if not overwriting APPMHI
00C719  1               
00C719  1               ;	Process error.
00C719  1               
00C719  1               ;DBS2:	LDA	#SCRMEM		;indicate insufficient memo:
00C719  1               ;	STA	DSTAT		;status
00C719  1               
00C719  1               ;	Exit.
00C719  1               
00C719  1  60           DBS3:	RTS		;return
00C71A  1               
00C71A  1               ;;	SSE - Set Scrolling Display List Entry
00C71A  1               ;
00C71A  1               ;	Store extra line in display list for fine scrolling:
00C71A  1               ;
00C71A  1               ;	ENTRY	JSR	SSE
00C71A  1               ;
00C71A  1               ;	MODS
00C71A  1               ;		H. Stewart	06/01/82
00C71A  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C71A  1               ;		   R. K. Nordin	11/01/83
00C71A  1               
00C71A  1               
00C71A  1               ;SSE:	;=	;	;entry
00C71A  1               ;	LDA	#$02
00C71A  1               ;	JSR	SDI	;store data indirect
00C71A  1               ;	LDA	#$A2	;DLI on last visible line
00C71A  1               ;	JSR	SDI	;store data indirect
00C71A  1               ;	DEX
00C71A  1               ;	RTS		;return
00C71A  1               
00C71A  1               ;;	CCA - Convert Cursor Row/Column to Address
00C71A  1               ;
00C71A  1               ;	ENTRY	JSR	CCA
00C71A  1               ;
00C71A  1               ;	MODS
00C71A  1               ;		L. Winner	06/01/82
00C71A  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C71A  1               ;		   R. K. Nordin	11/01/83
00C71A  1               
00C71A  1               
00C71A  1               CCA:	;=	;		;entry
00C71A  1  A2 01        	LDX	#1
00C71C  1               ;	STX	MLTTMP		;initialize
00C71C  1  CA           	DEX
00C71D  1  86 5E        	STX	ADRESS+1	;clear high address
00C71F  1  A5 37        	LDA	ROWCRS		;cursor row position
00C721  1  0A           	ASL	A		;2 times row position
00C722  1  26 5E        	ROL	ADRESS+1
00C724  1  0A           	ASL	A		;4 time row position
00C725  1  26 5E        	ROL	ADRESS+1
00C727  1  65 37        	ADC	ROWCRS		;add to get 5 times row pos:
00C729  1  85 5D        	STA	ADRESS
00C72B  1  90 02        	BCC	CCA1
00C72D  1               
00C72D  1  E6 5E        	INC	ADRESS+1
00C72F  1               
00C72F  1               CCA1:
00C72F  1               ;	LDY	DINDEX		;mode
00C72F  1               ;	LDX	TLSC,Y		;left shift count
00C72F  1  A2 04        	ldx	#4
00C731  1               
00C731  1  06 5D        CCA2:	ASL	ADRESS		;ADRESS = ADRESS*X
00C733  1  26 5E        	ROL	ADRESS+1	;divide
00C735  1  CA           	DEX
00C736  1  D0 F9        	BNE	CCA2
00C738  1               
00C738  1               ;	LDA	COLCRS+1	;high cursor column
00C738  1               ;	LSR	A		;save least significant bit
00C738  1               
00C738  1  18           	CLC
00C739  1  A5 38        	LDA	COLCRS		;low cursor column
00C73B  1               ;	LDX	TRSC,Y		;right shift count
00C73B  1               ;	BEQ	CCA4		;if no shift
00C73B  1               
00C73B  1               ;CCA3:	ROR	A		;roll in carry
00C73B  1               ;	ASL	MLTTMP		;shift index
00C73B  1               ;	DEX
00C73B  1               ;	BNE	CCA3
00C73B  1               
00C73B  1  65 5D        CCA4:	ADC	ADRESS		;add address
00C73D  1  90 02        	BCC	CCA5		;if no carry
00C73F  1               
00C73F  1  E6 5E        	INC	ADRESS+1	;adjust high address
00C741  1               
00C741  1               CCA5:
00C741  1               	.IF PLATFORM = 1
00C741  1               	STA	CHRPTR
00C741  1               	LDX	ADRESS+1
00C741  1               	STX	CHRPTR+1
00C741  1               	.ENDIF
00C741  1               
00C741  1  18           	CLC
00C742  1  65 3B        	ADC	SAVMSC		;add saved memory scan coun:
00C744  1  85 5D        	STA	ADRESS		;update address
00C746  1  85 41        	STA	OLDADR		;save address
00C748  1  A5 5E        	LDA	ADRESS+1
00C74A  1  65 3C        	ADC	SAVMSC+1
00C74C  1  85 5E        	STA	ADRESS+1
00C74E  1  85 42        	STA	OLDADR+1
00C750  1               
00C750  1               	.IF PLATFORM = 1
00C750  1               	lda	CHRPTR+1
00C750  1               	asl	CHRPTR
00C750  1               	rol
00C750  1               	asl	CHRPTR
00C750  1               	rol
00C750  1               	asl	CHRPTR
00C750  1               	rol
00C750  1               	adc	#>SCRSTRT
00C750  1               	sta	CHRPTR+1
00C750  1               	.ENDIF
00C750  1               
00C750  1               ;	LDX	TRSC,Y
00C750  1               ;	LDA	TMSK,X
00C750  1               ;	lda 	#0
00C750  1               ;	AND	COLCRS		;and in low cursor column
00C750  1               ;	ADC	OPNTMP
00C750  1               ;	TAY
00C750  1               ;	LDA	TDSM-1,Y	;display mask
00C750  1               ;	STA	DMASK		;display mask
00C750  1               ;	STA	SHFAMT
00C750  1               
00C750  1               	.IF PLATFORM=0
00C750  1  A9 7F        	lda 	#SCRBANK
00C752  1  85 5F        	sta	ADRESS+2
00C754  1               	.ENDIF
00C754  1               
00C754  1  A0 00        	ldy	#0
00C756  1               	;tay
00C756  1               
00C756  1  60           CCA6:	RTS			;return
00C757  1               
00C757  1               ;;	SZA - Set Zero Data and Advance Cursor Column
00C757  1               ;
00C757  1               ;	ENTRY	JSR	SZA
00C757  1               ;
00C757  1               ;	MODS
00C757  1               ;		Original Author Unknown
00C757  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C757  1               ;		   R. K. Nordin	11/01/83
00C757  1               
00C757  1               
00C757  1               SZA:	;=	;	;entry
00C757  1  A9 00        	LDA	#0
00C759  1  F0 02        	BEQ	SDA	;set data and advance cursor
00C75B  1               
00C75B  1               ;;	SEA - Set EOL Data and Advance Cursor Column
00C75B  1               ;
00C75B  1               ;	ENTRY	JSR	SEA
00C75B  1               ;
00C75B  1               ;	MODS
00C75B  1               ;		Original Author Unknown
00C75B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C75B  1               ;		   R. K. Nordin	11/01/83
00C75B  1               
00C75B  1               
00C75B  1               SEA:	;=	;	;entry
00C75B  1  A9 0A        	LDA	#EOL	;special case eliminator
00C75D  1               ;	JMP	SDA	;set data and advance cursor, retur:
00C75D  1               
00C75D  1               ;;	SDA - Set Data and Advance Cursor Column
00C75D  1               ;
00C75D  1               ;	ENTRY	JSR	SDA
00C75D  1               ;
00C75D  1               ;	MODS
00C75D  1               ;		Original Author Unknown
00C75D  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C75D  1               ;		   R. K. Nordin	11/01/83
00C75D  1               
00C75D  1               
00C75D  1               SDA:	;=	;	;entry
00C75D  1  85 5A        	STA	INSDAT	;set data
00C75F  1               ;	JMP	ACC	;advance cursor column, return
00C75F  1               
00C75F  1               ;;	ACC - Advance Cursor Column
00C75F  1               ;
00C75F  1               ;	ENTRY	JSR	ACC
00C75F  1               ;
00C75F  1               ;	MODS
00C75F  1               ;		Original Author Unknown
00C75F  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C75F  1               ;		   R. K. Nordin	11/01/83
00C75F  1               
00C75F  1               
00C75F  1               ACC:	;=	;		;entry
00C75F  1  E6 44        	INC	LOGCOL		;increment logical column
00C761  1  E6 38        	INC	COLCRS		;increment low cursor colum:
00C763  1  D0 02        	BNE	ACC1		;if no carry
00C765  1               
00C765  1  E6 39        	INC	COLCRS+1	;adjust high cursor column
00C767  1               
00C767  1  A5 38        ACC1:	LDA	COLCRS		;low cursor column
00C769  1               ;	LDX	DINDEX		;mode
00C769  1               ;	CMP	TMCC,X
00C769  1  C9 50        	CMP	#CCHARLINE
00C76B  1  F0 06        	BEQ	ACC2		;if equal, process EOL
00C76D  1               
00C76D  1               ;	CPX	#0
00C76D  1               ;	BNE	CCA6		;if not mode 0, exit
00C76D  1               
00C76D  1  C5 36        	CMP	RMARGN		;right margin
00C76F  1  F0 E5        	BEQ	CCA6		;if at right margin, exit
00C771  1               
00C771  1  90 E3        	BCC	CCA6		;if before right margin, ex:
00C773  1               
00C773  1  E0 08        ACC2:	CPX	#8
00C775  1  D0 04        	BNE	ACC3		;if not mode 8
00C777  1               
00C777  1  A5 39        	LDA	COLCRS+1	;high cursor column
00C779  1  F0 DB        	BEQ	CCA6		;if only at 64
00C77B  1               
00C77B  1               ACC3:;	LDA	DINDEX		;mode
00C77B  1               ;	BNE	RET		;if mode 0, exit
00C77B  1               
00C77B  1  A5 44        	LDA	LOGCOL		;logical column
00C77D  1               ;	jsr	jprinthex
00C77D  1  C9 51        	CMP	#81
00C77F  1  90 0A        	BCC	ACC4		;if < 81, definitely not li:
00C781  1               
00C781  1  A5 5A        	LDA	INSDAT
00C783  1  F0 22        	BEQ	RET		;if non-zero, do not do log:
00C785  1               
00C785  1  20 A3 C7     	JSR	RWS		;return with scrolling
00C788  1  4C EA C7     	JMP	RET5		;return
00C78B  1               
00C78B  1  20 A7 C7     ACC4:	JSR	RET		;return
00C78E  1  A5 37        	LDA	ROWCRS		;cursor row
00C790  1  18           	CLC
00C791  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00C793  1  20 7E C8     	JSR	BMG		;ger bit from bit map
00C796  1  90 08        	BCC	ACC5
00C798  1               
00C798  1  A5 5A        	LDA	INSDAT
00C79A  1  F0 04        	BEQ	ACC5		;if zero, do not extend
00C79C  1               
00C79C  1  18           	CLC
00C79D  1  20 A8 C6     	JSR	ILN1		;insert line
00C7A0  1               
00C7A0  1  4C 38 C9     ACC5:	JMP	SLC		;set logical column, return
00C7A3  1               
00C7A3  1               ;;	RWS - Return with Scrolling
00C7A3  1               ;
00C7A3  1               ;	ENTRY	JSR	RWS
00C7A3  1               ;
00C7A3  1               ;	MODS
00C7A3  1               ;		Original Author Unknown
00C7A3  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C7A3  1               ;		   R. K. Nordin	11/01/83
00C7A3  1               
00C7A3  1               
00C7A3  1               RWS:	;=	;	;entry
00C7A3  1  A9 0A        	LDA	#EOL	;select scrolling
00C7A5  1  85 5A        	STA	INSDAT
00C7A7  1               ;	JMP	RET	;return, return .
00C7A7  1               
00C7A7  1               ;;	RET - Return
00C7A7  1               ;
00C7A7  1               ;	ENTRY	JSR	RET
00C7A7  1               ;
00C7A7  1               ;	MODS
00C7A7  1               ;		Original Author Unknown
00C7A7  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C7A7  1               ;		   R. K. Nordin	11/01/83
00C7A7  1               
00C7A7  1               
00C7A7  1               RET:	;=	;		;entry
00C7A7  1  20 2E CA     	JSR	SCL		;set cursor at left edge
00C7AA  1               
00C7AA  1  A9 00        	LDA	#0
00C7AC  1  85 39        	STA	COLCRS+1	;high cursor column
00C7AE  1  E6 37        	INC	ROWCRS		;increment cursor row
00C7B0  1               ;	LDX	DINDEX
00C7B0  1  A0 19        	LDY	#NUMROWS	;assume NUMROWS lines
00C7B2  1  24 59        	BIT	SWPFLG
00C7B4  1  10 05        	BPL	RET1		;if normal
00C7B6  1               
00C7B6  1  A0 04        	LDY	#4		;substitute 4 lines
00C7B8  1  98           	TYA
00C7B9  1  D0 02        	BNE	RET2
00C7BB  1               
00C7BB  1               RET1:
00C7BB  1               ;	LDA	TMRC,X	;mode row count
00C7BB  1  A9 19        	lda	#NUMROWS
00C7BD  1               
00C7BD  1  C5 37        RET2:	CMP	ROWCRS	;cursor row
00C7BF  1  D0 29        	BNE	RET5
00C7C1  1               
00C7C1  1               ;	lda	#'*'
00C7C1  1               ;	jsr	jchrout
00C7C1  1               
00C7C1  1  8C 0C 02     	STY	HOLD3
00C7C4  1  8A           	TXA		;mode
00C7C5  1  D0 23        	BNE	RET5	;if mode not 0, do not scroll
00C7C7  1               
00C7C7  1  A5 5A        	LDA	INSDAT
00C7C9  1  F0 1F        	BEQ	RET5	;if zero, do not scroll
00C7CB  1               
00C7CB  1               ;	If EOL, roll in a 0.
00C7CB  1               
00C7CB  1  C9 0A        	CMP	#EOL	;to extend bottom logical line
00C7CD  1  F0 01        	BEQ	RET3	;if EOL
00C7CF  1               
00C7CF  1  18           	CLC
00C7D0  1               
00C7D0  1  20 03 C9     RET3:	JSR	SCR
00C7D3  1  EE 2E 02     	INC	SCRFLG
00C7D6  1  C6 4D        	DEC	BUFSTR
00C7D8  1  10 02        	BPL	RET4
00C7DA  1               
00C7DA  1  E6 4D        	INC	BUFSTR
00C7DC  1               
00C7DC  1  CE 0C 02     RET4:	DEC	HOLD3
00C7DF  1  AD 21 02     	LDA	LOGMAP
00C7E2  1  38           	SEC		;indicate for partial line
00C7E3  1  10 EB        	BPL	RET3	;if partial logical line
00C7E5  1               
00C7E5  1  AD 0C 02     	LDA	HOLD3
00C7E8  1  85 37        	STA	ROWCRS	;cursor row
00C7EA  1               
00C7EA  1  4C 38 C9     RET5:	JMP	SLC	;set logical column, return
00C7ED  1               
00C7ED  1               ;;	SEP - Subtract End Point
00C7ED  1               ;
00C7ED  1               ;	ENTRY	JSR	SEP
00C7ED  1               ;		X = 0, if row or 2, if column
00C7ED  1               ;
00C7ED  1               ;	MODS
00C7ED  1               ;		Original Author Unknown
00C7ED  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C7ED  1               ;		   R. K. Nordin	11/01/83
00C7ED  1               
00C7ED  1               
00C7ED  1               SEP_:	;=	;		;entry
00C7ED  1  38           	SEC
00C7EE  1  B5 50        	LDA	ROWAC,X		;low value from which to su:
00C7F0  1  E5 54        	SBC	ENDPT
00C7F2  1  95 50        	STA	ROWAC,X		;new low value
00C7F4  1  B5 51        	LDA	ROWAC+1,X	;hogh value from which to s:
00C7F6  1  E5 55        	SBC	ENDPT+1
00C7F8  1  95 51        	STA	ROWAC+1,X	;new high value
00C7FA  1  60           	RTS			;return
00C7FB  1               
00C7FB  1               ;;	CRE - Check Cursor Range for Editor
00C7FB  1               ;
00C7FB  1               ;	ENTRY	JSR	SEP
00C7FB  1               ;
00C7FB  1               ;	MODS
00C7FB  1               ;		Original Author Unknown
00C7FB  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C7FB  1               ;		   R. K. Nordin	11/01/83
00C7FB  1               
00C7FB  1               
00C7FB  1               CRE:	;=	;	;entry
00C7FB  1               
00C7FB  1               ;	Check for mixed mode.
00C7FB  1               
00C7FB  1               ;	LDA	BOTSCR
00C7FB  1               ;	CMP	#4	;mixed mode indicator
00C7FB  1               ;	BEQ	CCR	;if mixed mode, check cursor range,:
00C7FB  1               
00C7FB  1               ;	Check for mode 0.
00C7FB  1               
00C7FB  1               ;	LDA	DINDEX	;mode
00C7FB  1               ;	BEQ	CCR	;if mode 0, check ursor usage
00C7FB  1               
00C7FB  1               ;	Open editor.
00C7FB  1               
00C7FB  1               ;	JSR	EOP	;perform editor OPEN
00C7FB  1               ;	JMP	CCR	;check cursor range, return
00C7FB  1               
00C7FB  1               ;;	CCR - Check Cursor Range
00C7FB  1               ;
00C7FB  1               ;	ENTRY	JSR	CCR
00C7FB  1               ;
00C7FB  1               ;	MODS
00C7FB  1               ;		Original Author Unknown
00C7FB  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C7FB  1               ;		   R. K. Nordin	11/01/83
00C7FB  1               
00C7FB  1               
00C7FB  1               CCR:	;=	;		;entry
00C7FB  1  A9 4F        	LDA	#CCHARLINE-1
00C7FD  1  C5 36        	CMP	RMARGN		;right margin
00C7FF  1  B0 02        	BCS	CCR1		;if 39 >= right margin
00C801  1  85 36        	STA	RMARGN		;set right margin
00C803  1               
00C803  1               CCR1:
00C803  1               ;	LDX	DINDEX
00C803  1               ;	LDA	TMRC,X		;mode row count
00C803  1  A9 19        	lda	#NUMROWS
00C805  1  C5 37        	CMP	ROWCRS		;cursor row
00C807  1  90 1D        	BCC	CCR5		;if count > row position, e:
00C809  1  F0 1B        	BEQ	CCR5		;if count = row position, e:
00C80B  1               
00C80B  1               ;	CPX	#8
00C80B  1               ;	BNE	CCR2		;if not mode 8
00C80B  1               
00C80B  1  A5 39        	LDA	COLCRS+1	;high cursor column
00C80D  1  F0 12        	BEQ	CCR4		;if high cursor column zero
00C80F  1               
00C80F  1  C9 01        	CMP	#1
00C811  1  D0 13        	BNE	CCR5		;if >1, bad
00C813  1               
00C813  1  F0 04        	BEQ	CCR3		;if 1, check low
00C815  1               
00C815  1  A5 39        CCR2:	LDA	COLCRS+1	;high cursor column
00C817  1  D0 0D        	BNE	CCR5		;if high cursor column non-:
00C819  1               
00C819  1               CCR3:
00C819  1               ;	LDA	TMCC,X		;mode column count
00C819  1  A9 50        	lda 	#CCHARLINE
00C81B  1  C5 38        	CMP	COLCRS		;low cursor column
00C81D  1  90 07        	BCC	CCR5		;if count > column position:
00C81F  1  F0 05        	BEQ	CCR5		;if count = column position:
00C821  1               
00C821  1  A9 01        CCR4:	LDA	#SUCCES		;success indicator
00C823  1  85 32        	STA	DSTAT		;indicate success
00C825  1               ;	LDA	#BRKABT		;assume BREAK abort
00C825  1               ;	LDX	BRKKEY		;BREAK key status
00C825  1               ;	STA	BRKKEY		;clear BREAK key status
00C825  1               ;	BEQ	CCR6		;if BREAK
00C825  1               
00C825  1  60           	RTS			;return
00C826  1               
00C826  1               ;	Process range error.
00C826  1               
00C826  1  20 D6 C5     CCR5:	JSR	CHM		;move cursor home
00C829  1  A9 8D        	LDA	#CRSROR		;indicate cursor overrange
00C82B  1               
00C82B  1               ;	Exit.
00C82B  1               
00C82B  1  85 32        CCR6:	STA	DSTAT		;status
00C82D  1  68           	PLA			;clean stack for return to :
00C82E  1  68           	PLA
00C82F  1  A5 59        	LDA	SWPFLG
00C831  1  10 03        	BPL	CCR7		;if not swapped
00C833  1               
00C833  1  4C 0C CA     	JMP	SWA_		;swap, return
00C836  1               
00C836  1  4C B5 C4     CCR7:	JMP	SST		;return (to CIO)
00C839  1               
00C839  1               ;;	ROD - Restore Old Data under Cursor
00C839  1               ;
00C839  1               ;	ENTRY	JSR	ROD
00C839  1               ;
00C839  1               ;	MODS
00C839  1               ;		Original Author Unknown
00C839  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C839  1               ;		   R. K. Nordin	11/01/83
00C839  1               
00C839  1               
00C839  1               ROD:	;=	;		;entry
00C839  1               	.IF PLATFORM = 1
00C839  1               	lda	OLDADR
00C839  1               	asl
00C839  1               	sta	CHRPTR
00C839  1               	.ENDIF
00C839  1               
00C839  1  A0 00        	LDY	#0
00C83B  1  A5 42        	LDA	OLDADR+1
00C83D  1  F0 04        	BEQ	ROD3		;if page zero
00C83F  1               
00C83F  1               	.IF PLATFORM = 1
00C83F  1               	and	#%00000111
00C83F  1               	rol
00C83F  1               	asl	CHRPTR
00C83F  1               	rol
00C83F  1               	asl	CHRPTR
00C83F  1               	rol
00C83F  1               	adc	#>SCRSTRT
00C83F  1               	sta	CHRPTR+1
00C83F  1               	.ENDIF
00C83F  1               
00C83F  1  A5 40        	LDA	OLDCHR		;old data
00C841  1               	.IF PLATFORM=0
00C841  1  97 41        	sta	[OLDADR],Y
00C843  1               	.ELSE
00C843  1               	STA	(OLDADR),Y
00C843  1               	.ENDIF
00C843  1               
00C843  1               
00C843  1               	.IF PLATFORM = 1
00C843  1               	clc
00C843  1               	JMP	PRTCHR
00C843  1               	.ENDIF
00C843  1               
00C843  1  60           ROD3:	rts			;return
00C844  1               
00C844  1               ;;	BMI - Initialize for Bit Map Operation
00C844  1               ;
00C844  1               ;	BMI sets the bit mask in BITMSK and byte offset in :
00C844  1               ;
00C844  1               ;	ENTRY	JSR	BMI
00C844  1               ;
00C844  1               ;	MODS
00C844  1               ;		Original Author Unknown
00C844  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C844  1               ;		   R. K. Nordin	11/01/83
00C844  1               
00C844  1               
00C844  1               BMI_:	;=	;	;entry
00C844  1  48           	PHA		;save logical column
00C845  1  29 07        	AND	#7	;logical column modulo 8
00C847  1  AA           	TAX		;offset to bit mask
00C848  1  BD D9 CB     	LDA	TBTM,X	;bit mask
00C84B  1  85 4F        	STA	BITMSK	;set bit mask
00C84D  1  68           	PLA		;logical column
00C84E  1  4A           	LSR	A
00C84F  1  4A           	LSR	A
00C850  1  4A           	LSR	A	;logical column divided by 8
00C851  1  AA           	TAX		;offset
00C852  1  60           	RTS		;return
00C853  1               
00C853  1               ;;	BLR - Rotate Logical Line Bit Map Left
00C853  1               ;
00C853  1               ;	BLR rotates the logical line bit map left, scrollin:
00C853  1               ;	logical lines up.
00C853  1               ;
00C853  1               ;	ENTRY	JSR	BLR
00C853  1               ;
00C853  1               ;	MODS
00C853  1               ;		Original Author Unknown
00C853  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C853  1               ;		   R. K. Nordin	11/01/83
00C853  1               
00C853  1               
00C853  1               BLR:	;=	;		;entry
00C853  1  2E 23 02     	ROL	LOGMAP+2
00C856  1  2E 22 02     	ROL	LOGMAP+1
00C859  1  2E 21 02     	ROL	LOGMAP
00C85C  1  60           	RTS			;return
00C85D  1               
00C85D  1               ;;	BMP - Put Bit in Bit Map
00C85D  1               ;
00C85D  1               ;	PUT CARRY INTO BITMAP
00C85D  1               ;
00C85D  1               ;	ENTRY	JSR	BMP
00C85D  1               ;
00C85D  1               ;	MODS
00C85D  1               ;		Original Author Unknown
00C85D  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C85D  1               ;		   R. K. Nordin	11/01/83
00C85D  1               
00C85D  1               
00C85D  1               BMP:	;=	;	;entry
00C85D  1  90 0C        	BCC	BMC	;if C clear, clear bit in bit map,:
00C85F  1               
00C85F  1               ;	JMP	BMS	;set bit in bit map, return
00C85F  1               
00C85F  1               ;;	BMS - Set Bit in Bit Map
00C85F  1               ;
00C85F  1               ;	ENTRY	JSR	BMS
00C85F  1               ;
00C85F  1               ;	MODS
00C85F  1               ;		Original Author Unknown
00C85F  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C85F  1               ;		   R. K. Nordin	11/01/83
00C85F  1               
00C85F  1               
00C85F  1               BMS:	;=	;		;entry
00C85F  1  20 44 C8     	JSR	BMI_		;initialize for bit mask op:
00C862  1  BD 12 02     	LDA	TABMAP,X
00C865  1  05 4F        	ORA	BITMSK		;set bit
00C867  1  9D 12 02     	STA	TABMAP,X	;update bit map
00C86A  1  60           	RTS			;return
00C86B  1               
00C86B  1               ;;	BMC - Clear Bit in Bit Map
00C86B  1               ;
00C86B  1               ;	ENTRY	JSR	BMC
00C86B  1               ;
00C86B  1               ;	MODS
00C86B  1               ;		Original Author Unknown
00C86B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C86B  1               ;		   R. K. Nordin	11/01/83
00C86B  1               
00C86B  1               
00C86B  1               BMC:	;=	;		;entry
00C86B  1  20 44 C8     	JSR	BMI_		;initialize for bit mask op:
00C86E  1  A5 4F        	LDA	BITMSK
00C870  1  49 FF        	EOR	#$FF
00C872  1  3D 12 02     	AND	TABMAP,X	;clear bit
00C875  1  9D 12 02     	STA	TABMAP,X	;update bit map
00C878  1  60           	RTS			;return
00C879  1               
00C879  1               ;;	BLG - Get Bit from Logical Line Bit Map
00C879  1               ;
00C879  1               ;	ENTRY	JSR	BLG
00C879  1               ;
00C879  1               ;	MODS
00C879  1               ;		Original Author Unknown
00C879  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C879  1               ;		   R. K. Nordin	11/01/83
00C879  1               
00C879  1               
00C879  1               BLG:	;=	;	;entry
00C879  1  A5 37        	LDA	ROWCRS	;cursor row
00C87B  1               ;	JMP	BLG1
00C87B  1               
00C87B  1               ;;	BLG1 - Get Bit from Logical Line Bit Map
00C87B  1               ;
00C87B  1               ;	ENTRY	JSR	BLG1
00C87B  1               ;
00C87B  1               ;	MODS
00C87B  1               ;		Original Author Unknown
00C87B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C87B  1               ;		   R. K. Nordin	11/01/83
00C87B  1               
00C87B  1               
00C87B  1               BLG1:	;=	;	;entry
00C87B  1  18           	CLC
00C87C  1               ;	JMP	BLG2
00C87C  1               
00C87C  1               ;;	BLG2 - Get Bit from Logical Line Bit Map
00C87C  1               ;
00C87C  1               ;	ENTRY	JSR	BLG2
00C87C  1               ;
00C87C  1               ;	MODS
00C87C  1               ;		Original Author Unknown
00C87C  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C87C  1               ;		   R. K. Nordin	11/01/83
00C87C  1               
00C87C  1               
00C87C  1               BLG2:	;=	;	;entry
00C87C  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00C87E  1               ;	JMP	BMG	;get bit from bit map, return
00C87E  1               
00C87E  1               ;;	BMG - Get Bit from Bit Map
00C87E  1               ;
00C87E  1               ;	ENTRY	JSR	BMG
00C87E  1               ;
00C87E  1               ;	MODS
00C87E  1               ;		Original Author Unknown
00C87E  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C87E  1               ;		   R. K. Nordin	11/01/83
00C87E  1               
00C87E  1               
00C87E  1               BMG:	;=	;	;entry
00C87E  1  20 44 C8     	JSR	BMI_	;initialize for bit mask operation
00C881  1  18           	CLC
00C882  1  BD 12 02     	LDA	TABMAP,X
00C885  1  25 4F        	AND	BITMSK
00C887  1  F0 01        	BEQ	BMG1
00C889  1               
00C889  1  38           	SEC
00C88A  1               
00C88A  1  60           BMG1:	RTS		;return
00C88B  1               
00C88B  1               ;;	CIA - Convert Internal Character to ATASCII
00C88B  1               ;
00C88B  1               ;	ENTRY	JSR	CIA
00C88B  1               ;
00C88B  1               ;	MODS
00C88B  1               ;		Original Author Unknown
00C88B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C88B  1               ;		   R. K. Nordin	11/01/83
00C88B  1               
00C88B  1               
00C88B  1               CIA:	;=	;	;entry
00C88B  1               
00C88B  1               ;	Initialize.
00C88B  1               
00C88B  1  AD 3F 02     	LDA	CHAR
00C88E  1               ;	jmp	CIA2
00C88E  1               
00C88E  1               ;	Check mode.
00C88E  1               
00C88E  1               ;	LDY	DINDEX	;mode
00C88E  1               ;	CPY	#14
00C88E  1               ;	BCS	CIA2	;if mode >= 14
00C88E  1               
00C88E  1               ;	CPY	#12
00C88E  1               ;	BCS	CIA1	;if mode 12 or 13
00C88E  1               
00C88E  1               ;	CPY	#3
00C88E  1               ;	BCS	CIA2	;if mode >= 3
00C88E  1               
00C88E  1               ;	Convert internal character to ATASCII.
00C88E  1               
00C88E  1               ;CIA1:	ROL	A
00C88E  1               ;	ROL	A
00C88E  1               ;	ROL	A
00C88E  1               ;	ROL	A
00C88E  1               ;	AND	#3
00C88E  1               ;	TAX
00C88E  1               ;	LDA	CHAR	;character
00C88E  1               ;	AND	#$9F	;strip off cloumn address
00C88E  1               ;	ORA	TIAC,X	;or in new column address
00C88E  1               
00C88E  1               ;	Exit.
00C88E  1               
00C88E  1  8D 40 02     CIA2:	STA	ATACHR	;ATASCII character
00C891  1               
00C891  1  60           CIA3:	RTS		;return
00C892  1               
00C892  1               ;;	MLN - Move Line
00C892  1               ;
00C892  1               ;	ENTRY	JSR	MLN
00C892  1               ;
00C892  1               ;	MODS
00C892  1               ;		Original Author Unknown
00C892  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C892  1               ;		   R. K. Nordin	11/01/83
00C892  1               
00C892  1               
00C892  1               MLN:	;=	;		;entry
00C892  1               
00C892  1               ; Initialize.
00C892  1               	.IF PLATFORM <= 1
00C892  1  A9 7F        	lda	#SCRBANK
00C894  1  85 4A        	sta	FRMADR+2
00C896  1  85 47        	sta	TOADR+2
00C898  1               	.ENDIF
00C898  1  A6 4B        	LDX	RAMTOP		;(high) RAM size
00C89A  1  CA           	DEX			;decrement (high) RAM size
00C89B  1  86 49        	STX	FRMADR+1	;high source address
00C89D  1  86 46        	STX	TOADR+1		;high destination address
00C89F  1  A9 60        	LDA	#<($0000-CCHARLINE-CCHARLINE)	;low RAM size - 80
00C8A1  1  85 48        	STA	FRMADR		;low source address
00C8A3  1  A9 B0        	LDA	#<($0000-CCHARLINE)	;low RAM size - 40
00C8A5  1  85 45        	STA	TOADR		;low destination address
00C8A7  1               
00C8A7  1  A6 37        	LDX	ROWCRS		;cursor row
00C8A9  1               
00C8A9  1               ;	Check for completion.
00C8A9  1               
00C8A9  1  E8           MLN1:	INX
00C8AA  1  EC 32 02     	CPX	BOTSCR		;screen bottom
00C8AD  1  F0 1D        	BEQ	MLN3		;if done, return
00C8AF  1               ;	BEQ	CIA3		;if done, return
00C8AF  1               
00C8AF  1               ;	Move line.
00C8AF  1               
00C8AF  1  A0 4F        	LDY	#CCHARLINE-1	;offset to last byte
00C8B1  1               
00C8B1  1               MLN2:	.IF PLATFORM <= 1
00C8B1  1  B7 48        	LDA	[FRMADR],Y	;byte of source
00C8B3  1  97 45        	STA	[TOADR],Y	;byte of destination
00C8B5  1               	.ELSE
00C8B5  1               	LDA	(FRMADR),Y	;byte of source
00C8B5  1               	STA	(TOADR),Y	;byte of destination
00C8B5  1               	.ENDIF
00C8B5  1  88           	DEY
00C8B6  1  10 F9        	BPL	MLN2		;if not done
00C8B8  1               
00C8B8  1               ;	Adjust source and destination addresses.
00C8B8  1               
00C8B8  1  38           	SEC
00C8B9  1  A5 48        	LDA	FRMADR		;source address
00C8BB  1  85 45        	STA	TOADR		;update destination address
00C8BD  1  E9 50        	SBC	#<CCHARLINE		;subtract 40
00C8BF  1  85 48        	STA	FRMADR		;update.source address
00C8C1  1  A5 49        	LDA	FRMADR+1
00C8C3  1  85 46        	STA	TOADR+1
00C8C5  1  E9 00        	SBC	#>CCHARLINE
00C8C7  1  85 49        	STA	FRMADR+1
00C8C9  1               
00C8C9  1               ;	Continue.
00C8C9  1               
00C8C9  1  4C A9 C8     	JMP	MLN1		;continue
00C8CC  1               
00C8CC  1               ;
00C8CC  1               ; Move screen's bitmap
00C8CC  1               ;
00C8CC  1               MLN3:
00C8CC  1               	.IF PLATFORM <> 1
00C8CC  1  60           	rts
00C8CD  1               	.ELSE
00C8CD  1               	lda	#1
00C8CD  1               	sta	MEMCNTL
00C8CD  1               	lda	#(>(SCRSTRT-256+(NUMROWS-1)*640))-$80		;last page in line 22 (0-23)
00C8CD  1               	sta	FRMADR+1
00C8CD  1               	lda	#(>(SCRSTRT-256+NUMROWS*640))-$80
00C8CD  1               	sta	TOADR+1
00C8CD  1               	lda	#<(SCRSTRT-256+(NUMROWS-1)*640)
00C8CD  1               	sta	FRMADR
00C8CD  1               	lda	#<(SCRSTRT-256+NUMROWS*640)
00C8CD  1               	sta	TOADR
00C8CD  1               
00C8CD  1               	LDX	ROWCRS		;cursor row
00C8CD  1               
00C8CD  1               MLN6:	INX
00C8CD  1               	CPX	BOTSCR		;screen bottom
00C8CD  1               	BNE	MLN8		;if done, return
00C8CD  1               
00C8CD  1               MLNEX:	lda	#0
00C8CD  1               	sta	MEMCNTL
00C8CD  1               	rts
00C8CD  1               
00C8CD  1               MLN8:	ldy	#0
00C8CD  1               MLN4:	lda	(FRMADR),y
00C8CD  1               	sta	(TOADR),y
00C8CD  1               	iny
00C8CD  1               	bne	MLN4
00C8CD  1               
00C8CD  1               	dec	FRMADR+1
00C8CD  1               	dec	TOADR+1
00C8CD  1               
00C8CD  1               MLN7:	lda	(FRMADR),y
00C8CD  1               	sta	(TOADR),y
00C8CD  1               	iny
00C8CD  1               	bne	MLN7
00C8CD  1               
00C8CD  1               	sec
00C8CD  1               	lda	FRMADR
00C8CD  1               	sbc	#128
00C8CD  1               	sta	FRMADR
00C8CD  1               	lda	FRMADR+1
00C8CD  1               	sbc	#0
00C8CD  1               	sta	FRMADR+1
00C8CD  1               	sec
00C8CD  1               	lda	TOADR
00C8CD  1               	sbc	#128
00C8CD  1               	sta	TOADR
00C8CD  1               	lda	TOADR+1
00C8CD  1               	sbc	#0
00C8CD  1               	sta	TOADR+1
00C8CD  1               
00C8CD  1               	ldy	#127
00C8CD  1               MLN5:	lda	(FRMADR),y
00C8CD  1               	sta	(TOADR),y
00C8CD  1               	dey
00C8CD  1               	bpl	MLN5
00C8CD  1               
00C8CD  1               	dec	FRMADR+1
00C8CD  1               	dec	TOADR+1
00C8CD  1               
00C8CD  1               	jmp	MLN6
00C8CD  1               	.ENDIF
00C8CD  1               
00C8CD  1               ;;	ELL - Extend Logical Line
00C8CD  1               ;
00C8CD  1               ;	ENTRY	JSR	ELL
00C8CD  1               ;
00C8CD  1               ;	MODS
00C8CD  1               ;		Original Author Unknown
00C8CD  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C8CD  1               ;		   R. K. Nordin	11/01/83
00C8CD  1               
00C8CD  1               
00C8CD  1               ELL:	;=	;	;entry
00C8CD  1  08           	PHP		;save bit
00C8CE  1  A0 16        	LDY	#22
00C8D0  1               
00C8D0  1  98           ELL1:	TYA
00C8D1  1  20 7B C8     	JSR	BLG1
00C8D4  1  08           	PHP
00C8D5  1  98           	TYA
00C8D6  1  18           	CLC
00C8D7  1  69 79        	ADC	#8*(LOGMAP-TABMAP)+1	;add offset for log:
00C8D9  1  28           	PLP
00C8DA  1  20 5D C8     	JSR	BMP	;put bit in bit map
00C8DD  1  88           	DEY
00C8DE  1  30 04        	BMI	ELL2
00C8E0  1               
00C8E0  1  C4 37        	CPY	ROWCRS	;cursor row
00C8E2  1  B0 EC        	BCS	ELL1
00C8E4  1               
00C8E4  1  A5 37        ELL2:	LDA	ROWCRS	;cursor row
00C8E6  1  18           	CLC
00C8E7  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00C8E9  1  28           	PLP
00C8EA  1  4C 5D C8     	JMP	BMP	;put bit in bit map, return
00C8ED  1               
00C8ED  1               ;;	CLN - Clear Line
00C8ED  1               ;
00C8ED  1               ;	ENTRY	JSR	CLN
00C8ED  1               ;
00C8ED  1               ;	MODS
00C8ED  1               ;		Original Author Unknown
00C8ED  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C8ED  1               ;		   R. K. Nordin	11/01/83
00C8ED  1               
00C8ED  1               
00C8ED  1               CLN:	;=	;	;entry
00C8ED  1  A5 35        	LDA	LMARGN	;left margin
00C8EF  1  85 38        	STA	COLCRS	;low cursor column
00C8F1  1  20 1A C7     	JSR	CCA	;convert cursor row/column to addre:
00C8F4  1  38           	SEC
00C8F5  1  A5 36        	LDA	RMARGN	;right margin
00C8F7  1  E5 35        	SBC	LMARGN	;subtract left margin
00C8F9  1  A8           	TAY		;screen width
00C8FA  1  AA           	TAX
00C8FB  1  A9 00        	LDA	#0
00C8FD  1               
00C8FD  1               CLN1:	.IF PLATFORM=0
00C8FD  1  97 5D        	sta	[ADRESS],Y
00C8FF  1               	.ELSE
00C8FF  1               	STA	(ADRESS),Y
00C8FF  1               	.ENDIF
00C8FF  1  88           	DEY
00C900  1  10 FB        	BPL	CLN1	;if not done
00C902  1               
00C902  1               
00C902  1               	.IF PLATFORM = 1
00C902  1               	clc
00C902  1               	jsr	PRTCHR
00C902  1               	bmi	CLN4
00C902  1               
00C902  1               CLN3:	clc
00C902  1               	jsr	PRTCH2
00C902  1               CLN4:	clc
00C902  1               	lda	CHRPTR
00C902  1               	adc	#8
00C902  1               	sta	CHRPTR
00C902  1               	bcc	CLN2
00C902  1               	inc	CHRPTR+1
00C902  1               CLN2:	dex
00C902  1               	bpl	CLN3
00C902  1               	.ENDIF
00C902  1               
00C902  1  60           	RTS		;return
00C903  1               
00C903  1               ;;	SCR - Scroll
00C903  1               ;
00C903  1               ;	ENTRY	JSR	SCR
00C903  1               ;
00C903  1               ;	MODS
00C903  1               ;		Original Author Unknown
00C903  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C903  1               ;		   R. K. Nordin	11/01/83
00C903  1               
00C903  1               
00C903  1               SCR:	;=	;	;entry
00C903  1               
00C903  1               ;	Initialize.
00C903  1               
00C903  1  20 53 C8     	JSR	BLR	;rotate logical line bit map left
00C906  1               
00C906  1               ;	Check for fine scrolling.
00C906  1               
00C906  1               ;	LDA	FINE
00C906  1               ;	BEQ	SCR5	;if not fine scrolling
00C906  1               
00C906  1               ;SCR1:	LDA	VSFLAG	;vertical scroll count
00C906  1               ;	BNE	SCR1	;if prior scroll not yet done
00C906  1               
00C906  1               ;	LDA	#8
00C906  1               ;	STA	VSFLAG	;vertical scroll count
00C906  1               
00C906  1               ;	Wait forscroll to complete.
00C906  1               
00C906  1               ;SCR2:	LDA	VSFLAG	;vertical scroll count
00C906  1               ;	CMP	#1	;start of last scan
00C906  1               ;	BNE	SCR2	;if not done waiting
00C906  1               
00C906  1               ;SCR3:
00C906  1               ;	LDA	VCOUNT
00C906  1               ;	CMP	#$40
00C906  1               ;	BCS	SCR3	;if not done waiting for safe place
00C906  1               
00C906  1               ;	LDX	#$0D
00C906  1               ;	LDA	BOTSCR
00C906  1               ;	CMP	#4
00C906  1               ;	BNE	SCR4	;if not split screen
00C906  1               
00C906  1               ;	LDX	#$70
00C906  1               
00C906  1               ;SCR4:
00C906  1               ;	CPX	VCOUNT
00C906  1               ;	BCS	SCR4	;if not done waiting
00C906  1               
00C906  1               ;	Exit.
00C906  1               
00C906  1  20 39 CA     SCR5:	JSR	SMS	;set memory scan counter address
00C909  1               ;	JMP	SSD	;scroll screen for delete, return
00C909  1               
00C909  1               ;;	SSD - Scroll Screen for Delete
00C909  1               ;
00C909  1               ;	ENTRY	JSR	SSD
00C909  1               ;
00C909  1               ;	MODS
00C909  1               ;		Original Author Unknown
00C909  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C909  1               ;		   R. K. Nordin	11/01/83
00C909  1               
00C909  1               
00C909  1               SSD:	;=	;		;entry
00C909  1               
00C909  1  08           	php
00C90A  1               
00C90A  1  E2 20        	sep	#$20
00C90C  1               	.A8
00C90C  1               
00C90C  1               	.IF PLATFORM = 1
00C90C  1               	lda	#1
00C90C  1               	sta 	MEMCNTL
00C90C  1               	.ENDIF
00C90C  1               
00C90C  1               ;	clc
00C90C  1               ;	sei
00C90C  1               ;	xce
00C90C  1               
00C90C  1  C2 30        	rep	#$30
00C90E  1               	.A16
00C90E  1               	.I16
00C90E  1               
00C90E  1  18           	clc
00C90F  1  A5 5D        	lda	ADRESS
00C911  1  A8           	tay
00C912  1  69 50 00     	adc	#CCHARLINE
00C915  1  AA           	tax
00C916  1               
00C916  1  38           	sec
00C917  1  E9 D0 F7     	sbc	#SCRSTRT+NUMROWS*80
00C91A  1  49 FF FF     	eor	#$ffff
00C91D  1               
00C91D  1               	.if PLATFORM=0
00C91D  1               ;	sei
00C91D  1  8B           	phb
00C91E  1  54 7F 7F     	mvn	#SCRBANK,#SCRBANK
00C921  1  AB           	plb
00C922  1               ;	cli
00C922  1               	.ELSE
00C922  1               	mvn	0,0
00C922  1               	.ENDIF
00C922  1               
00C922  1  A2 80 F7     	ldx	#SCRSTRT+(NUMROWS-1)*80
00C925  1  A0 81 F7     	ldy	#SCRSTRT+(NUMROWS-1)*80+1
00C928  1  A9 00 00     	lda	#0
00C92B  1  8F 80 F7 7F  	sta	SCRBANK<<16+SCRSTRT+(NUMROWS-1)*80
00C92F  1  A9 4E 00     	lda	#78
00C932  1               	.if PLATFORM=0
00C932  1               ;	sei
00C932  1  8B           	phb
00C933  1  54 7F 7F     	mvn	#SCRBANK,#SCRBANK
00C936  1  AB           	plb
00C937  1               ;	cli
00C937  1               	.ELSE
00C937  1               	mvn	0,0
00C937  1               	.ENDIF
00C937  1               
00C937  1               	.IF PLATFORM = 1
00C937  1               	lda	ADRESS
00C937  1               	and	#$07ff
00C937  1               	asl
00C937  1               	asl
00C937  1               	asl
00C937  1               	adc	#SCRSTRT-$8000
00C937  1               	tay
00C937  1               	adc	#640
00C937  1               	tax
00C937  1               
00C937  1               	sec
00C937  1               	sbc	#$4000+NUMROWS*640
00C937  1               	eor	#$ffff
00C937  1               
00C937  1               	mvn	0,0
00C937  1               
00C937  1               	ldx	#$4000+(NUMROWS-1)*640
00C937  1               	ldy	#$4000+(NUMROWS-1)*640+1
00C937  1               	lda	#638
00C937  1               	stz	$4000+(NUMROWS-1)*640
00C937  1               	mvn	0,0
00C937  1               
00C937  1               ;	sec
00C937  1               ;	xce
00C937  1               ;	cli
00C937  1               
00C937  1               	.ENDIF
00C937  1  28           	plp
00C938  1               	.A8
00C938  1               	.I8
00C938  1               
00C938  1               	.IF PLATFORM = 1
00C938  1               	stz	MEMCNTL
00C938  1               	.ENDIF
00C938  1               
00C938  1               	.IF PLATFORM = 99
00C938  1               
00C938  1               	jmp	(SSDVEC)
00C938  1               
00C938  1               ;	Initialize
00C938  1               SSDV:	lda 	#1
00C938  1               	sta 	MEMCNTL
00C938  1               
00C938  1               	LDA	ADRESS
00C938  1               	CLC
00C938  1               	ADC	#CCHARLINE
00C938  1               	STA	COUNTR		;address + #CCHARLINE
00C938  1               	LDA	#0
00C938  1               	tay
00C938  1               	ADC	ADRESS+1
00C938  1               	STA	COUNTR+1
00C938  1               	lda	ADRESS
00C938  1               	asl
00C938  1               	sta	TOADR
00C938  1               	lda	ADRESS+1
00C938  1               	and	#%00000111
00C938  1               	rol
00C938  1               	asl	TOADR
00C938  1               	rol
00C938  1               	asl	TOADR
00C938  1               	rol
00C938  1               	adc	#(>SCRSTRT)-$80
00C938  1               	sta	TOADR+1
00C938  1               
00C938  1               	clc
00C938  1               	lda	TOADR
00C938  1               	adc	#<640
00C938  1               	sta	FRMADR
00C938  1               	lda	TOADR+1
00C938  1               	adc	#>640
00C938  1               	sta	FRMADR+1
00C938  1               
00C938  1               	sec
00C938  1               	lda 	#$D0
00C938  1               	sbc	COUNTR
00C938  1               	beq	SSDR2
00C938  1               
00C938  1               	pha
00C938  1               	tax
00C938  1               
00C938  1               ;	lda	COUNTR+1
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	COUNTR
00C938  1               ;	jsr	jprinthex
00C938  1               ;	txa
00C938  1               ;	jsr	jprinthex
00C938  1               ;	jsr	jnewline
00C938  1               
00C938  1               SSDR1:	lda	(COUNTR),y
00C938  1               	sta	(ADRESS),y
00C938  1               	iny
00C938  1               	dex
00C938  1               	bne	SSDR1
00C938  1               
00C938  1               	ldy	#0
00C938  1               	clc
00C938  1               	pla
00C938  1               	tax
00C938  1               	adc	COUNTR
00C938  1               	sta	COUNTR
00C938  1               	bcc	SSDR6
00C938  1               	inc	COUNTR+1
00C938  1               SSDR6:	clc
00C938  1               	txa
00C938  1               	adc	ADRESS
00C938  1               	sta	ADRESS
00C938  1               	bcc	SSDR2
00C938  1               	inc	ADRESS+1
00C938  1               
00C938  1               SSDR2:
00C938  1               ;	lda	COUNTR+1
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	COUNTR
00C938  1               ;	jsr	jprinthex
00C938  1               ;	jsr	jnewline
00C938  1               
00C938  1               	sec
00C938  1               	lda	COUNTR+1
00C938  1               	sbc	SAVMSC+1
00C938  1               	cmp	#7
00C938  1               	beq	SSDR3
00C938  1               
00C938  1               SSDR4:	lda	(COUNTR),y
00C938  1               	sta	(ADRESS),y
00C938  1               	iny
00C938  1               	bne	SSDR4
00C938  1               
00C938  1               	inc	ADRESS+1
00C938  1               	inc	COUNTR+1
00C938  1               	bne	SSDR2		; jmp!
00C938  1               
00C938  1               SSDR3:	lda	#$30
00C938  1               	sta	COUNTR
00C938  1               	ldy	#CCHARLINE-1
00C938  1               	lda	#0
00C938  1               SSDR5:	sta	(COUNTR),y
00C938  1               	dey
00C938  1               	bne	SSDR5
00C938  1               
00C938  1               
00C938  1               ;	lda	FRMADR+1
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	FRMADR
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	TOADR+1
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	TOADR
00C938  1               ;	jsr	jprinthex
00C938  1               
00C938  1               	ldy 	#0
00C938  1               	lda	FRMADR
00C938  1               	beq	SSDRX1
00C938  1               
00C938  1               SSDRX4:	lda	(FRMADR),y
00C938  1               	sta	(TOADR),y
00C938  1               	iny
00C938  1               	cpy	#128
00C938  1               	bne	SSDRX4
00C938  1               
00C938  1               	lda	#0
00C938  1               	tay
00C938  1               	sta	FRMADR
00C938  1               	inc	FRMADR+1
00C938  1               
00C938  1               	lda	#$80
00C938  1               	sta	TOADR
00C938  1               
00C938  1               SSDRX1:
00C938  1               ;	lda	FRMADR+1
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	FRMADR
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	TOADR+1
00C938  1               ;	jsr	jprinthex
00C938  1               ;	lda	TOADR
00C938  1               ;	jsr	jprinthex
00C938  1               
00C938  1               	sec
00C938  1               	lda	FRMADR+1
00C938  1               	sbc	#(>SCRSTRT)-$80
00C938  1               	cmp	#$3C
00C938  1               	beq	SSDRX2
00C938  1               
00C938  1               SSDRX3:	lda	(FRMADR),y
00C938  1               	sta	(TOADR),y
00C938  1               	iny
00C938  1               	bne	SSDRX3
00C938  1               
00C938  1               	inc	FRMADR+1
00C938  1               	inc	TOADR+1
00C938  1               	bne	SSDRX1
00C938  1               
00C938  1               SSDRX2:	ldx	#2
00C938  1               	lda	#0
00C938  1               SSDRX5:	sta	(TOADR),y
00C938  1               	iny
00C938  1               	bne	SSDRX5
00C938  1               	inc	TOADR+1
00C938  1               	dex
00C938  1               	bne	SSDRX5
00C938  1               
00C938  1               	ldy	#127
00C938  1               SSDRX6:	sta	(TOADR),y
00C938  1               	dey
00C938  1               	bpl	SSDRX6
00C938  1               
00C938  1               	iny
00C938  1               	sty	MEMCNTL
00C938  1               
00C938  1               	.ENDIF
00C938  1               
00C938  1               ;	jmp	SLC
00C938  1               
00C938  1               ;;	SLC - Set Logical Column
00C938  1               ;
00C938  1               ;	ENTRY	JSR	SLC
00C938  1               ;
00C938  1               ;	MODS
00C938  1               ;		Original Author Unknown
00C938  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C938  1               ;		   R. K. Nordin	11/01/83
00C938  1               
00C938  1               
00C938  1               SLC:	;=	;	;entry
00C938  1               
00C938  1               ;	Initialize.
00C938  1               
00C938  1  A9 00        	LDA	#0
00C93A  1  85 44        	STA	LOGCOL	;initialize logical column
00C93C  1  A5 37        	LDA	ROWCRS	;cursor row
00C93E  1  85 34        	STA	HOLD1	;working row
00C940  1               
00C940  1               ;	Search for beginning of line.
00C940  1               
00C940  1  A5 34        SLC1:	LDA	HOLD1	;add in row component
00C942  1  20 7B C8     	JSR	BLG1
00C945  1  B0 0C        	BCS	SLC2	;if beginning of line found
00C947  1               
00C947  1  A5 44        	LDA	LOGCOL	;logical column
00C949  1  18           	CLC
00C94A  1  69 50        	ADC	#CCHARLINE	;add number of characters per line
00C94C  1  85 44        	STA	LOGCOL	;update logical column
00C94E  1  C6 34        	DEC	HOLD1	;decrement working row
00C950  1  4C 40 C9     	JMP	SLC1	;continue
00C953  1               
00C953  1               ;	Add in cursor column.
00C953  1               
00C953  1  18           SLC2:	CLC
00C954  1  A5 44        	LDA	LOGCOL	;logical column
00C956  1  65 38        	ADC	COLCRS	;add low cursor column
00C958  1  85 44        	STA	LOGCOL	;update logical column
00C95A  1  60           	RTS		;return
00C95B  1               
00C95B  1               ;;	CBC - Compute Buffer Count
00C95B  1               ;
00C95B  1               ;	CBC computes the buffer count as the number of byte:
00C95B  1               ;	buffer start to the end of the logical line (with t:
00C95B  1               ;	spaces removed).
00C95B  1               ;
00C95B  1               ;	ENTRY	JSR	CBC
00C95B  1               ;
00C95B  1               ;	MODS
00C95B  1               ;		Original Author Unknown
00C95B  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C95B  1               ;		   R. K. Nordin	11/01/83
00C95B  1               
00C95B  1               
00C95B  1               CBC:	;=	;	;entry
00C95B  1               
00C95B  1               ;	Initialize.
00C95B  1               
00C95B  1  20 F6 C9     	JSR	SRC		;save row and column
00C95E  1  A5 44        	LDA	LOGCOL		;logical column
00C960  1  48           	PHA			;save logical column
00C961  1  A5 4D        	LDA	BUFSTR		;start of buffer
00C963  1  85 37        	STA	ROWCRS		;cursor row
00C965  1  A5 4E        	LDA	BUFSTR+1
00C967  1  85 38        	STA	COLCRS		;low cursor column
00C969  1  A9 01        	LDA	#1
00C96B  1  85 4C        	STA	BUFCNT		;initialize buffer count
00C96D  1               
00C96D  1               ;	Determine last line on screen.
00C96D  1               
00C96D  1  A2 18        CBC1:	LDX	#(NUMROWS-1)	;normal last line on screen
00C96F  1  A5 59        	LDA	SWPFLG
00C971  1  10 02        	BPL	CBC2		;if not swapped
00C973  1               
00C973  1  A2 03        	LDX	#3		;last line on screen
00C975  1               
00C975  1               ;	Check for cursor on last line of screen.
00C975  1               
00C975  1  E4 37        CBC2:	CPX	ROWCRS	;cursor row
00C977  1  D0 0B        	BNE	CBC3	;if cursor on last line
00C979  1               
00C979  1  A5 38        	LDA	COLCRS	;low cursor column
00C97B  1  C5 36        	CMP	RMARGN	;right margin
00C97D  1  D0 05        	BNE	CBC3	;if not at right margin
00C97F  1               
00C97F  1  E6 4C        	INC	BUFCNT	;fake SEA to avoid scrolling
00C981  1  4C 94 C9     	JMP	CBC4
00C984  1               
00C984  1  20 57 C7     CBC3:	JSR	SZA	;set zero data and advance cursor
00C987  1  E6 4C        	INC	BUFCNT
00C989  1  A5 44        	LDA	LOGCOL	;logical column
00C98B  1  C5 35        	CMP	LMARGN	;left margin
00C98D  1  D0 DE        	BNE	CBC1	;if not yet at left margin
00C98F  1               
00C98F  1  C6 37        	DEC	ROWCRS	;decrement cursor row
00C991  1  20 98 C5     	JSR	CLF	;move cursor left
00C994  1               
00C994  1  20 4E C4     CBC4:	JSR	GDC	;get data under cursor
00C997  1  D0 17        	BNE	CBC6	;if non-zero, quit
00C999  1               
00C999  1  C6 4C        	DEC	BUFCNT	;DECREMENT COUNTER
00C99B  1  A5 44        	LDA	LOGCOL	;logical column
00C99D  1  C5 35        	CMP	LMARGN	;left margin
00C99F  1  F0 0F        	BEQ	CBC6	;if beginning of logical line, exit
00C9A1  1               
00C9A1  1  20 98 C5     	JSR	CLF	;move cursor left
00C9A4  1  A5 38        	LDA	COLCRS	;low cursor column
00C9A6  1  C5 36        	CMP	RMARGN	;right margin
00C9A8  1  D0 02        	BNE	CBC5	;if cursor column not right margin
00C9AA  1               
00C9AA  1  C6 37        	DEC	ROWCRS	;decrement cursor row
00C9AC  1               
00C9AC  1  A5 4C        CBC5:	LDA	BUFCNT
00C9AE  1  D0 E4        	BNE	CBC4	;if BUFCNT non-zero, continue
00C9B0  1               
00C9B0  1  68           CBC6:	PLA		;saved logical column
00C9B1  1  85 44        	STA	LOGCOL	;restore logical column
00C9B3  1  4C 01 CA     	JMP	RRC	;restore row and column, return
00C9B6  1               
00C9B6  1               ;;	SBS - Set Bufer Start and Logical Column
00C9B6  1               ;
00C9B6  1               ;	ENTRY	JSR	SBS
00C9B6  1               ;
00C9B6  1               ;	MODS
00C9B6  1               ;		Original Author Unknown
00C9B6  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C9B6  1               ;		   R. K. Nordin	11/01/83
00C9B6  1               
00C9B6  1               
00C9B6  1               SBS:		;=	;		;entry
00C9B6  1  20 38 C9     	JSR	SLC		;set logical column
00C9B9  1  A5 34        	LDA	HOLD1
00C9BB  1  85 4D        	STA	BUFSTR
00C9BD  1  A5 35        	LDA	LMARGN		;left margin
00C9BF  1  85 4E        	STA	BUFSTR+1
00C9C1  1               
00C9C1  1  60           SBS1:	RTS			;return
00C9C2  1               
00C9C2  1               ;;	DQQ - Delete Line
00C9C2  1               ;
00C9C2  1               ;	ENTRY	JSR	DQQ
00C9C2  1               ;
00C9C2  1               ;	MODS
00C9C2  1               ;		Original Author Unknown
00C9C2  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C9C2  1               ;		   R. K. Nordin	11/01/83
00C9C2  1               
00C9C2  1               
00C9C2  1               DQQ:	;=	;	;entry
00C9C2  1  A5 44        	LDA	LOGCOL	;logical column
00C9C4  1  C5 35        	CMP	LMARGN	;left margin
00C9C6  1  D0 02        	BNE	DQQ1	;if not at left margin
00C9C8  1               
00C9C8  1  C6 37        	DEC	ROWCRS	;decrement cursor row
00C9CA  1  20 38 C9     DQQ1:	JSR	SLC	;set logical column
00C9CD  1               ;	JMP	DWQ
00C9CD  1               
00C9CD  1               ;;	DWQ - Delete Line
00C9CD  1               ;
00C9CD  1               ;	ENTRY	JSR	DWQ
00C9CD  1               ;
00C9CD  1               ;	MODS
00C9CD  1               ;		Original Author Unknown
00C9CD  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C9CD  1               ;		   R. K. Nordin	11/01/83
00C9CD  1               
00C9CD  1               
00C9CD  1               DWQ:	;=	;	;entry
00C9CD  1               
00C9CD  1               ;	Check for left margin.
00C9CD  1               
00C9CD  1  A5 44        	LDA	LOGCOL	;logical column
00C9CF  1  C5 35        	CMP	LMARGN	;left margin
00C9D1  1  F0 EE        	BEQ	SBS1	;if at left margin, return
00C9D3  1               
00C9D3  1  20 1A C7     	JSR	CCA	;convert cursor row/column to addre:
00C9D6  1  A5 36        	LDA	RMARGN	;right margin
00C9D8  1  38           	SEC
00C9D9  1  E5 35        	SBC	LMARGN	;subtract left margin
00C9DB  1  A8           	TAY		;offset to last byte
00C9DC  1               
00C9DC  1               DWQ1:
00C9DC  1               	.IF PLATFORM=0
00C9DC  1  B7 5D        	lda	[ADRESS],Y
00C9DE  1               	.ELSE
00C9DE  1               	LDA	(ADRESS),Y
00C9DE  1               	.ENDIF
00C9DE  1  D0 E1        	BNE	SBS1
00C9E0  1               
00C9E0  1  88           	DEY
00C9E1  1  10 F9        	BPL	DWQ1	;if not done
00C9E3  1               
00C9E3  1  4C C2 C6     	JMP	DLN1	;delete line, return
00C9E6  1               
00C9E6  1               ;;	CCC - Check for Control Character
00C9E6  1               ;
00C9E6  1               ;	ENTRY	JSR	CCC
00C9E6  1               ;
00C9E6  1               ;	MODS
00C9E6  1               ;		Original Author Unknown
00C9E6  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C9E6  1               ;		   R. K. Nordin	11/01/83
00C9E6  1               
00C9E6  1               
00C9E6  1               CCC:	;=	;	;entry
00C9E6  1               
00C9E6  1  A2 2D        	LDX	#TCCRL-3	;offset to last entry
00C9E8  1               
00C9E8  1  BD 9D CB     CCC1:	LDA	TCCR,X		;control character
00C9EB  1  CD 40 02     	CMP	ATACHR		;ATASCII character
00C9EE  1  F0 05        	BEQ	CCC2		;if character found, exit
00C9F0  1               
00C9F0  1  CA           	DEX
00C9F1  1  CA           	DEX
00C9F2  1  CA           	DEX
00C9F3  1  10 F3        	BPL	CCC1		;if not done, continue sear:
00C9F5  1               
00C9F5  1  60           CCC2:	RTS			;return
00C9F6  1               
00C9F6  1               ;;	SRC - Save Row and Column
00C9F6  1               ;
00C9F6  1               ;	ENTRY	JSR	SRC
00C9F6  1               ;
00C9F6  1               ;	MODS
00C9F6  1               ;		Original Author Unknown
00C9F6  1               ;		1. Bring closer to Coding Standard (object unchanged).
00C9F6  1               ;		   R. K. Nordin	11/01/83
00C9F6  1               
00C9F6  1               
00C9F6  1               SRC:	;=	;		;entry
00C9F6  1  A2 02        	LDX	#2		;offset to last byte
00C9F8  1               
00C9F8  1  B5 37        SRC1:	LDA	ROWCRS,X	;byte of cursor row/column
00C9FA  1  9D 2B 02     	STA	TMPROW,X	;save byte of cursor row/co:
00C9FD  1  CA           	DEX
00C9FE  1  10 F8        	BPL	SRC1		;if not done
00CA00  1               
00CA00  1  60           	RTS			;return
00CA01  1               
00CA01  1               ;;	RRC - Restore Row and Column
00CA01  1               ;
00CA01  1               ;	ENTRY	JSR	RRC
00CA01  1               ;
00CA01  1               ;	MODS
00CA01  1               ;		Original Author Unknown
00CA01  1               ;		1. Bring closer to Coding Standard (object unchanged).
00CA01  1               ;		   R. K. Nordin	11/01/83
00CA01  1               
00CA01  1               
00CA01  1               RRC:	;=	;		;entry
00CA01  1  A2 02        	LDX	#2		;offset to last byte
00CA03  1               
00CA03  1  BD 2B 02     RRC1:	LDA	TMPROW,X	;byte of saved cursor row/c:
00CA06  1  95 37        	STA	ROWCRS,X	;byte of row/column
00CA08  1  CA           	DEX
00CA09  1  10 F8        	BPL	RRC1		;if not done
00CA0B  1               
00CA0B  1  60           	RTS			;return
00CA0C  1               
00CA0C  1               ;;	SWA - Swap Cursor Position with Regular Cursor Posi:
00CA0C  1               ;
00CA0C  1               ;	ENTRY	JSR	SWA
00CA0C  1               ;
00CA0C  1               ;	MODS
00CA0C  1               ;		Original Author Unknown
00CA0C  1               ;		1. Bring closer to Coding Standard (object unchanged).
00CA0C  1               ;		   R. K. Nordin	11/01/83
00CA0C  1               
00CA0C  1               
00CA0C  1               SWA_:	;=	;		;entry
00CA0C  1               
00CA0C  1               ;	Check for split screen.
00CA0C  1               
00CA0C  1  AD 32 02     	LDA	BOTSCR		;screen bottom
00CA0F  1  C9 19        	CMP	#NUMROWS	;normal indicator
00CA11  1  F0 17        	BEQ	SWA2		;if not split screen
00CA13  1               
00CA13  1               ;	Swap cursor parameters.
00CA13  1               
00CA13  1  A2 0B        	LDX	#11		;offset to last byte
00CA15  1               
00CA15  1  B5 37        SWA1:	LDA	ROWCRS,X	;destination cursor paramet:
00CA17  1  48           	PHA			;save cursor parameter
00CA18  1  BD 00 02     	LDA	TXTROW,X	;source cursor parameter
00CA1B  1  95 37        	STA	ROWCRS,X	;update destination cursor :
00CA1D  1  68           	PLA			;saved cursor parameter
00CA1E  1  9D 00 02     	STA	TXTROW,X	;update source cursor param:
00CA21  1  CA           	DEX
00CA22  1  10 F1        	BPL	SWA1		;if not done
00CA24  1               
00CA24  1               ;	Complement swap flag.
00CA24  1               
00CA24  1  A5 59        	LDA	SWPFLG		;swap flag
00CA26  1  49 FF        	EOR	#$FF		;complement swap flag
00CA28  1  85 59        	STA	SWPFLG		;update swap flag
00CA2A  1               
00CA2A  1               ;	Exit.
00CA2A  1               
00CA2A  1  4C B5 C4     SWA2:	JMP	SST	;perform screen STATUS, return
00CA2D  1               
00CA2D  1               ;;	SKC - Sound Key Click
00CA2D  1               ;
00CA2D  1               ;	ENTRY	JSR	SKC
00CA2D  1               ;
00CA2D  1               ;	MODS
00CA2D  1               ;		Original Author Unknown
00CA2D  1               ;		1. Bring closer to Coding Standard (object unchanged).
00CA2D  1               ;		   R. K. Nordin	11/01/83
00CA2D  1               
00CA2D  1               
00CA2D  1               SKC:	;=	;	;entry
00CA2D  1               
00CA2D  1               ;	Initialize.
00CA2D  1               
00CA2D  1  60           	RTS		;return
00CA2E  1               
00CA2E  1               ;;	SCL - Set Cursor at Left Edge
00CA2E  1               ;
00CA2E  1               ;	ENTRY	JSR	SCL
00CA2E  1               ;
00CA2E  1               ;	MODS
00CA2E  1               ;		Original Author Unknown
00CA2E  1               ;		1. Bring closer to Coding Standard (object unchanged).
00CA2E  1               ;		   R. K. Nordin	11/01/83
00CA2E  1               
00CA2E  1               
00CA2E  1               SCL:	;=	;	;entry
00CA2E  1               
00CA2E  1  A9 00        	LDA	#0	;assume 0
00CA30  1               
00CA30  1  A6 59        	LDX	SWPFLG	;swap flag
00CA32  1  D0 00        	BNE	SCL1	;if not swapped
00CA34  1               
00CA34  1               ;	LDX	DINDEX	;mode
00CA34  1               ;	BNE	SCL2	;if not mode 0
00CA34  1               
00CA34  1  A5 35        SCL1:	LDA	LMARGN	;use left margin instead of 0
00CA36  1               
00CA36  1  85 38        SCL2:	STA	COLCRS	;set low cursor column
00CA38  1  60           	RTS		;return
00CA39  1               
00CA39  1               ;;	SMS - Set Memory Scan Counter Address
00CA39  1               ;
00CA39  1               ;	ENTRY	JSR	SMS
00CA39  1               ;
00CA39  1               ;	MODS
00CA39  1               ;		Original Author Unknown
00CA39  1               ;		1. Bring closer to Coding Standard (object unchanged).
00CA39  1               ;		   R. K. Nordin	11/01/83
00CA39  1               
00CA39  1               
00CA39  1               SMS:	;=	;		;entry
00CA39  1  A5 3B        	LDA	SAVMSC		;saved low memory scan coun:
00CA3B  1  85 5D        	STA	ADRESS		;saved low address
00CA3D  1  A5 3C        	LDA	SAVMSC+1	;saved high memory scan cou:
00CA3F  1  85 5E        	STA	ADRESS+1	;set high address
00CA41  1               	.IF PLATFORM=0
00CA41  1  A9 7F        	lda	#SCRBANK
00CA43  1  85 5F        	sta	ADRESS+2
00CA45  1  85 43        	sta	OLDADR+2
00CA47  1               	.ENDIF
00CA47  1  60           	RTS			;return
00CA48  1               
00CA48  1               ;;	SSP - Perform Screen SPECIAL
00CA48  1               ;
00CA48  1               ;	SSP draws a line from OLDROW/OLDCOL to NEWROW/NEWCO:
00CA48  1               ;
00CA48  1               ;	ENTRY	JSR	SSP
00CA48  1               ;
00CA48  1               ;	MODS
00CA48  1               ;		A. Miller
00CA48  1               ;		1. Bring closer to Coding Standard (object unchanged).
00CA48  1               ;		   R. K. Nordin	11/01/83
00CA48  1               
00CA48  1               
00CA48  1               SSP:	;=	;		;entry
00CA48  1               
00CA48  1               ;	Determine command.
00CA48  1               
00CA48  1  A2 00        	LDX	#0		;assume no fill
00CA4A  1  A5 22        	LDA	ICCOMZ		;command
00CA4C  1  C9 11        	CMP	#$11		;DRAW command
00CA4E  1  F0 08        	BEQ	SSP2		;if DRAW command
00CA50  1               
00CA50  1  C9 12        	CMP	#$12		;FILL command
00CA52  1  F0 03        	BEQ	SSP1		;if FILL command
00CA54  1               
00CA54  1  A0 84        	LDY	#NVALID		;invalid command error
00CA56  1  60           	RTS			;return
00CA57  1               
00CA57  1  E8           SSP1:	INX			;indicate fill
00CA58  1               
00CA58  1  8E 2A 02     SSP2:	STX	FILFLG		;right fill flag
00CA5B  1               
00CA5B  1               ;	Set destination row/column.
00CA5B  1               
00CA5B  1  A5 37        	LDA	ROWCRS		;cursor row
00CA5D  1  8D 3A 02     	STA	NEWROW
00CA60  1  A5 38        	LDA	COLCRS		;cursor column
00CA62  1  8D 3B 02     	STA	NEWCOL
00CA65  1  A5 39        	LDA	COLCRS+1
00CA67  1  8D 3C 02     	STA	NEWCOL+1
00CA6A  1               
00CA6A  1               ;	Compute row increment and difference.
00CA6A  1               
00CA6A  1  A9 01        	LDA	#1		;assume increment +1
00CA6C  1  8D 3D 02     	STA	ROWINC		;row increment
00CA6F  1  8D 3E 02     	STA	COLINC		;column increment
00CA72  1  38           	SEC
00CA73  1  AD 3A 02     	LDA	NEWROW		;destination row
00CA76  1  E5 3D        	SBC	OLDROW		;subtract source row
00CA78  1  85 56        	STA	DELTAR		;row difference
00CA7A  1  B0 0E        	BCS	SSP3		;if difference positive
00CA7C  1               
00CA7C  1               ;	Set row increment to -1 and complement row differen:
00CA7C  1               
00CA7C  1  A9 FF        	LDA	#$FF		;increment -1
00CA7E  1  8D 3D 02     	STA	ROWINC		;update row increment
00CA81  1  A5 56        	LDA	DELTAR		;row difference
00CA83  1  49 FF        	EOR	#$FF
00CA85  1  18           	CLC
00CA86  1  69 01        	ADC	#1		;add 1 for 2's complement
00CA88  1  85 56        	STA	DELTAR		;update row difference
00CA8A  1               
00CA8A  1               ;	Compute column increment and difference.
00CA8A  1               
00CA8A  1  38           SSP3:	SEC
00CA8B  1  AD 3B 02     	LDA	NEWCOL		;destination column
00CA8E  1  E5 3E        	SBC	OLDCOL		;source column
00CA90  1  85 57        	STA	DELTAC		;column difference
00CA92  1  AD 3C 02     	LDA	NEWCOL+1
00CA95  1  E5 3F        	SBC	OLDCOL+1
00CA97  1  85 58        	STA	DELTAC+1
00CA99  1  B0 17        	BCS	SSP4		;if difference positive
00CA9B  1               
00CA9B  1               ;	Set column increment to -1 and complement column di:
00CA9B  1               
00CA9B  1  A9 FF        	LDA	#$FF		;increment -1
00CA9D  1  8D 3E 02     	STA	COLINC		;update column increment
00CAA0  1  A5 57        	LDA	DELTAC		;column difference
00CAA2  1  49 FF        	EOR	#$FF		;absolute value of column d:
00CAA4  1  85 57        	STA	DELTAC		;update column difference
00CAA6  1  A5 58        	LDA	DELTAC+1
00CAA8  1  49 FF        	EOR	#$FF
00CAAA  1  85 58        	STA	DELTAC+1
00CAAC  1  E6 57        	INC	DELTAC		;add 1 for 2's complement
00CAAE  1  D0 02        	BNE	SSP4		;if no carry
00CAB0  1               
00CAB0  1  E6 58        	INC	DELTAC+1	;adjust for 2's complement
00CAB2  1               
00CAB2  1  A2 02        SSP4:	LDX	#2		;offset to last byte
00CAB4  1  A0 00        	LDY	#0
00CAB6  1  84 53        	STY	COLAC+1		;zero high working column
00CAB8  1               
00CAB8  1  98           SSP5:	TYA
00CAB9  1  95 50        	STA	ROWAC,X		;zero byte of working row/c:
00CABB  1  B5 3D        	LDA	OLDROW,X	;byte of source row/column
00CABD  1  95 37        	STA	ROWCRS,X	;byte of cursor row/column
00CABF  1  CA           	DEX
00CAC0  1  10 F6        	BPL	SSP5		;if not done
00CAC2  1               
00CAC2  1               ;	Determine difference.
00CAC2  1               
00CAC2  1  A5 57        	LDA	DELTAC		;low column difference
00CAC4  1  E8           	INX			;offset to working row
00CAC5  1  A8           	TAY			;low column difference
00CAC6  1  A5 58        	LDA	DELTAC+1	;high column difference
00CAC8  1  85 5C        	STA	COUNTR+1	;initialize high iteration :
00CACA  1  85 55        	STA	ENDPT+1		;initialize high end point
00CACC  1  D0 0B        	BNE	SSP6		;if high column difference :
00CACE  1               
00CACE  1  A5 57        	LDA	DELTAC		;low column difference
00CAD0  1  C5 56        	CMP	DELTAR		;row difference
00CAD2  1  B0 05        	BCS	SSP6		;if column difference > row:
00CAD4  1               
00CAD4  1  A5 56        	LDA	DELTAR		;row difference
00CAD6  1  A2 02        	LDX	#2		;offset to working column
00CAD8  1  A8           	TAY			;row difference
00CAD9  1               
00CAD9  1  98           SSP6:	TYA			;low maximum difference
00CADA  1  85 5B        	STA	COUNTR		;low iteration counter
00CADC  1  85 54        	STA	ENDPT		;low end point
00CADE  1  48           	PHA			;save low end point
00CADF  1  A5 55        	LDA	ENDPT+1		;high end point
00CAE1  1  4A           	LSR	A		;C = LSB of high end point
00CAE2  1  68           	PLA			;saved low end point
00CAE3  1  6A           	ROR	A
00CAE4  1  95 50        	STA	ROWAC,X		;low working row or column
00CAE6  1               
00CAE6  1               ;	Check for iteration counter zero.
00CAE6  1               
00CAE6  1  A5 5B        SSP7:	LDA	COUNTR		;low iteration counter
00CAE8  1  05 5C        	ORA	COUNTR+1	;or in high iteration count:
00CAEA  1  D0 03        	BNE	SSP8		;if iteration counter is no:
00CAEC  1               
00CAEC  1  4C 9A CB     	JMP	SSP19		;exit
00CAEF  1               
00CAEF  1               ;	Update working row.
00CAEF  1               
00CAEF  1  18           SSP8:	CLC
00CAF0  1  A5 50        	LDA	ROWAC		;working row
00CAF2  1  65 56        	ADC	DELTAR		;row difference
00CAF4  1  85 50        	STA	ROWAC		;update working row
00CAF6  1  90 02        	BCC	SSP9		;if no carry
00CAF8  1               
00CAF8  1  E6 51        	INC	ROWAC+1		;adjust high working row
00CAFA  1               
00CAFA  1  A5 51        SSP9:	LDA	ROWAC+1		;high working row
00CAFC  1  C5 55        	CMP	ENDPT+1		;high end point
00CAFE  1  90 15        	BCC	SSP11		;if high working row < high:
00CB00  1               
00CB00  1  D0 06        	BNE	SSP10		;if high working row > high:
00CB02  1               
00CB02  1  A5 50        	LDA	ROWAC		;low working row
00CB04  1  C5 54        	CMP	ENDPT		;low end point
00CB06  1  90 0D        	BCC	SSP11		;if low working row < low e:
00CB08  1               
00CB08  1  18           SSP10:	CLC
00CB09  1  A5 37        	LDA	ROWCRS		;cursor row
00CB0B  1  6D 3D 02     	ADC	ROWINC		;add row increment
00CB0E  1  85 37        	STA	ROWCRS		;update cursor row
00CB10  1  A2 00        	LDX	#0		;indicate subtract from wor:
00CB12  1  20 ED C7     	JSR	SEP_		;subtract end pointer
00CB15  1               
00CB15  1  18           SSP11:	CLC
00CB16  1  A5 52        	LDA	COLAC		;low working column
00CB18  1  65 57        	ADC	DELTAC		;add column difference
00CB1A  1  85 52        	STA	COLAC		;update working column
00CB1C  1  A5 53        	LDA	COLAC+1
00CB1E  1  65 58        	ADC	DELTAC+1
00CB20  1  85 53        	STA	COLAC+1
00CB22  1  C5 55        	CMP	ENDPT+1		;high end point
00CB24  1  90 28        	BCC	SSP15		;if high working column < h:
00CB26  1               
00CB26  1  D0 06        	BNE	SSP12		;if high working column > h:
00CB28  1               
00CB28  1  A5 52        	LDA	COLAC		;low working column
00CB2A  1  C5 54        	CMP	ENDPT		;low end point
00CB2C  1  90 20        	BCC	SSP15		;if low working column < lo:
00CB2E  1               
00CB2E  1  2C 3E 02     SSP12:	BIT	COLINC		;column increment
00CB31  1  10 10        	BPL	SSP13		;if column increment positi:
00CB33  1               
00CB33  1  C6 38        	DEC	COLCRS		;decrement low cursor colum:
00CB35  1  A5 38        	LDA	COLCRS		;low cursor column
00CB37  1  C9 FF        	CMP	#$FF
00CB39  1  D0 0E        	BNE	SSP14
00CB3B  1               
00CB3B  1  A5 39        	LDA	COLCRS+1	;high cursor column
00CB3D  1  F0 0A        	BEQ	SSP14		;if zero, do not decrement
00CB3F  1               
00CB3F  1  C6 39        	DEC	COLCRS+1	;decrement high cursor colu:
00CB41  1  10 06        	BPL	SSP14
00CB43  1               
00CB43  1  E6 38        SSP13:	INC	COLCRS		;increment low cursor colum:
00CB45  1  D0 02        	BNE	SSP14		;if no carry
00CB47  1               
00CB47  1  E6 39        	INC	COLCRS+1	;adjust high cursor column
00CB49  1               
00CB49  1  A2 02        SSP14:	LDX	#2		;indicate subtract from wor:
00CB4B  1  20 ED C7     	JSR	SEP_		;subtract end pointer
00CB4E  1               
00CB4E  1               ;	Plot point.
00CB4E  1               
00CB4E  1  20 FB C7     SSP15:	JSR	CCR		;check cursor range
00CB51  1  20 7D C4     	JSR	PLO		;plot point
00CB54  1               
00CB54  1               ;	Check for right fill.
00CB54  1               
00CB54  1  AD 2A 02     	LDA	FILFLG		;right fill flag
00CB57  1  F0 2F        	BEQ	SSP18		;if no right fill
00CB59  1               
00CB59  1               ;	Process right fill.
00CB59  1               
00CB59  1  20 F6 C9     	JSR	SRC		;save row and column
00CB5C  1  AD 40 02     	LDA	ATACHR		;plot point
00CB5F  1  8D 2F 02     	STA	HOLD4		;save plot point
00CB62  1               
00CB62  1  A5 37        SSP16:	LDA	ROWCRS		;cursor row
00CB64  1  48           	PHA			;save cursor row
00CB65  1  20 5F C7     	JSR	ACC		;advance cursor column
00CB68  1  68           	PLA			;saved cursor row
00CB69  1  85 37        	STA	ROWCRS		;restore cursor row
00CB6B  1  20 FB C7     	JSR	CCR		;check cursor range
00CB6E  1  20 4E C4     	JSR	GDC		;get data under cursor
00CB71  1  D0 0C        	BNE	SSP17		;if non-zero data encounter:
00CB73  1               
00CB73  1  AD 41 02     	LDA	FILDAT		;fill data
00CB76  1  8D 40 02     	STA	ATACHR		;plot point
00CB79  1  20 7D C4     	JSR	PLO		;plot point
00CB7C  1  4C 62 CB     	JMP	SSP16		;continue
00CB7F  1               
00CB7F  1  AD 2F 02     SSP17:	LDA	HOLD4		;saved plot point
00CB82  1  8D 40 02     	STA	ATACHR		;restore plot point
00CB85  1  20 01 CA     	JSR	RRC		;restore row and column
00CB88  1               
00CB88  1               ;	Subtract 1 from iteration counter.
00CB88  1               
00CB88  1  38           SSP18:	SEC
00CB89  1  A5 5B        	LDA	COUNTR		;iteration counter
00CB8B  1  E9 01        	SBC	#1		;subtract 1
00CB8D  1  85 5B        	STA	COUNTR		;update iteration counter
00CB8F  1  A5 5C        	LDA	COUNTR+1
00CB91  1  E9 00        	SBC	#0
00CB93  1  85 5C        	STA	COUNTR+1
00CB95  1               
00CB95  1               ;	Check for completion.
00CB95  1               
00CB95  1  30 03        	BMI	SSP19	;if iteration counter negative, exi:
00CB97  1               
00CB97  1  4C E6 CA     	JMP	SSP7	;continue
00CB9A  1               
00CB9A  1               ;	Exit.
00CB9A  1               
00CB9A  1  4C B5 C4     SSP19:	JMP	SST	;perform screen STATUS, return
00CB9D  1               
00CB9D  1               ;**	TMSK - Table of Bit Masks
00CB9D  1               
00CB9D  1               
00CB9D  1               ;TMSK:	.byte	$00	;0 - mask for no bits
00CB9D  1               ;	.byte	$01	;1 - mask for lower 1 bit
00CB9D  1               ;	.byte	$03	;2 - mask for lower 2 bits
00CB9D  1               ;	.byte	$07	;3 - mask for lower 3 bits
00CB9D  1               
00CB9D  1               ;**	TDSC - Table of Default Screen Colors
00CB9D  1               
00CB9D  1               
00CB9D  1               ;TDSC:	.byte	$28	;default playfield 0 color
00CB9D  1               ;	.byte	$CA	;default playfield 1 color
00CB9D  1               ;	.byte	$94	;default playfield 2 color
00CB9D  1               ;	.byte	$46	;default playfield 3 color
00CB9D  1               ;	.byte	$00	;default background color
00CB9D  1               
00CB9D  1               ;;	TCCR - Table of Control Character Routines
00CB9D  1               ;
00CB9D  1               ;	Each entry is 3 bytes. The first byte is the contr:
00CB9D  1               ;	character; the second and third bytes are the addre:
00CB9D  1               ;	the routine which processes the control character.
00CB9D  1               
00CB9D  1               
00CB9D  1  1B           TCCR:	.byte	$1B
00CB9E  1  78 C5        	.word	ESC_	;escape
00CBA0  1               
00CBA0  1  1C           	.byte	CCUP
00CBA1  1  7E C5        	.word	CUP	;move cursor up
00CBA3  1               
00CBA3  1  1D           	.byte	CCDN
00CBA4  1  8B C5        	.word	CDN	;move cursor down
00CBA6  1               
00CBA6  1  1E           	.byte	CCLF
00CBA7  1  98 C5        	.word	CLF	;move cursor left
00CBA9  1               
00CBA9  1  1F           	.byte	CCRT
00CBAA  1  A9 C5        	.word	CRT	;move cursor right
00CBAC  1               
00CBAC  1  01           	.byte	CLS
00CBAD  1  B8 C5        	.word	CSC	;clear screen
00CBAF  1               
00CBAF  1  08           	.byte	BACK
00CBB0  1  E6 C5        	.word	BSP	;backspace
00CBB2  1               
00CBB2  1  7F           	.byte	TABU
00CBB3  1  10 C6        	.word	TAB	;tab
00CBB5  1               
00CBB5  1  0A           	.byte	EOL	;$9B
00CBB6  1  A3 C7        	.word	RWS	;return with scrolling
00CBB8  1               
00CBB8  1  9C           	.byte	$9C
00CBB9  1  BB C6        	.word	DLN	;delete line
00CBBB  1               
00CBBB  1  9D           	.byte	CILN
00CBBC  1  A7 C6        	.word	ILN	;insert line
00CBBE  1               
00CBBE  1  9E           	.byte	$9E
00CBBF  1  30 C6        	.word	CTB	;clear tab
00CBC1  1               
00CBC1  1  9F           	.byte	$9F
00CBC2  1  2B C6        	.word	STB	;set tab
00CBC4  1               
00CBC4  1  FD           	.byte	$FD
00CBC5  1  F1 C6        	.word	BEL	;sound bell
00CBC7  1               
00CBC7  1  FE           	.byte	CDCH
00CBC8  1  6C C6        	.word	DCH	;delete character
00CBCA  1               
00CBCA  1  FF           	.byte	CICH
00CBCB  1  35 C6        	.word	ICH	;insert character
00CBCD  1               
00CBCD  1               TCCRL	= * - TCCR	;length
00CBCD  1               
00CBCD  1               ;;	TSFR - Table of Super Function (Shifted Function Ke:
00CBCD  1               ;
00CBCD  1               ;	Each entry is 3 bytes. The first byte is the super:
00CBCD  1               ;	character; the second and third bytes are the addre:
00CBCD  1               ;	routine which processes the super function.
00CBCD  1               
00CBCD  1               
00CBCD  1  1C           TSFR:	.byte	CCHM
00CBCE  1  D6 C5        	.word	CHM	;move cursor home
00CBD0  1               
00CBD0  1  1D           	.byte	CCBT
00CBD1  1  FA C6        	.word	CBT	;move cursor to bottom
00CBD3  1               
00CBD3  1  1E           	.byte	CCLM
00CBD4  1  B3 C5        	.word	CLM	;move cursor to left margin
00CBD6  1               
00CBD6  1  1F           	.byte	CCRM
00CBD7  1  A2 C5        	.word	CRM	;move cursor to right margin
00CBD9  1               
00CBD9  1               ;;	TAIC - Table of ATASCII to Internal Conversion Cons:
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TAIC:	.byte	$40	;0
00CBD9  1               ;	.byte	$00	;1
00CBD9  1               ;	.byte	$20	;2
00CBD9  1               ;	.byte	$60	;3
00CBD9  1               
00CBD9  1               ;;	TIAC - Table of Internal to ATASCII Conversion Cons:
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TIAC:	.byte	$20	;0
00CBD9  1               ;	.byte	$40	;1
00CBD9  1               ;	.byte	$00	;2
00CBD9  1               ;	.byte	$60	;3
00CBD9  1               
00CBD9  1               ;;	TCKD - Table of Character Key Definitions
00CBD9  1               ;
00CBD9  1               ;	Entry n is the ATASCII equivalent of key code n.
00CBD9  1               
00CBD9  1               
00CBD9  1               TCKD:	;=	;
00CBD9  1               
00CBD9  1               ;	Lower Case Characters
00CBD9  1               
00CBD9  1               ;	.byte	$6C	;$00 - l
00CBD9  1               ;	.byte	$6A	;$01 - j
00CBD9  1               ;	.byte	$3B	;$02 - semicolon
00CBD9  1               ;	.byte	$8A	;$03 - F1
00CBD9  1               ;	.byte	$8B	;$04 - F2
00CBD9  1               ;	.byte	$6B	;$05 - k
00CBD9  1               ;	.byte	$2B	;$06 - +
00CBD9  1               ;	.byte	$2A	;$07 - *
00CBD9  1               ;	.byte	$6F	;$08 - o
00CBD9  1               ;	.byte	$80	;$09 - (invalid)
00CBD9  1               ;	.byte	$70	;$0A - p
00CBD9  1               ;	.byte	$75	;$0B - u
00CBD9  1               ;	.byte	$9B	;$0C - return
00CBD9  1               ;	.byte	$69	;$0D - i
00CBD9  1               ;	.byte	$2D	;$0E - -
00CBD9  1               ;	.byte	$3D	;$0F - =
00CBD9  1               ;
00CBD9  1               ;	.byte	$76	;$10 - v
00CBD9  1               ;	.byte	$80	;$11 - (invalid)
00CBD9  1               ;	.byte	$63	;$12 - c
00CBD9  1               ;	.byte	$8C	;$13 - F3
00CBD9  1               ;	.byte	$8D	;$14 - F4
00CBD9  1               ;	.byte	$62	;$15 - b
00CBD9  1               ;	.byte	$78	;$16 - x
00CBD9  1               ;	.byte	$7A	;$17 - z
00CBD9  1               ;	.byte	$34	;$18 - 4
00CBD9  1               ;	.byte	$80	;$19 - (invalid)
00CBD9  1               ;	.byte	$33	;$1A - 3
00CBD9  1               ;	.byte	$36	;$1B - 6
00CBD9  1               ;	.byte	$1B	;$1C - escape
00CBD9  1               ;	.byte	$35	;$1D - 5
00CBD9  1               ;	.byte	$32	;$1E - 2
00CBD9  1               ;	.byte	$31	;$1F - 1
00CBD9  1               ;
00CBD9  1               ;	.byte	$2C	;$20 - comma
00CBD9  1               ;	.byte	$20	;$21 - space
00CBD9  1               ;	.byte	$2E	;$22 - period
00CBD9  1               ;	.byte	$6E	;$23 - n
00CBD9  1               ;	.byte	$80	;$24 - (invalid)
00CBD9  1               ;	.byte	$6D	;$25 - m
00CBD9  1               ;	.byte	$2F	;$26 - /
00CBD9  1               ;	.byte	$81	;$27 - inverse
00CBD9  1               ;	.byte	$72	;$28 - r
00CBD9  1               ;	.byte	$80	;$29 - (invalid)
00CBD9  1               ;	.byte	$65	;$2A - e
00CBD9  1               ;	.byte	$79	;$2B - y
00CBD9  1               ;	.byte	$7F	;$2C - tab
00CBD9  1               ;	.byte	$74	;$2D - t
00CBD9  1               ;	.byte	$77	;$2E - w
00CBD9  1               ;	.byte	$71	;$2F - q
00CBD9  1               ;
00CBD9  1               ;	.byte	$39	;$30 - 9
00CBD9  1               ;	.byte	$80	;$31 - (invalid)
00CBD9  1               ;	.byte	$30	;$32 - 0
00CBD9  1               ;	.byte	$37	;$33 - 7
00CBD9  1               ;	.byte	$7E	;$34 - backspace
00CBD9  1               ;	.byte	$38	;$35 - 8
00CBD9  1               ;	.byte	$3C	;$36 - <
00CBD9  1               ;	.byte	$3E	;$37 - >
00CBD9  1               ;	.byte	$66	;$38 - f
00CBD9  1               ;	.byte	$68	;$39 - h
00CBD9  1               ;	.byte	$64	;$3A - d
00CBD9  1               ;	.byte	$80	;$3B - (invalid)
00CBD9  1               ;	.byte	$82	;$3C - CAPS
00CBD9  1               ;	.byte	$67	;$3D - g
00CBD9  1               ;	.byte	$73	;$3E - s
00CBD9  1               ;	.byte	$61	;$3F - a
00CBD9  1               ;
00CBD9  1               ;;	Upper Case Characters
00CBD9  1               ;
00CBD9  1               ;	.byte	$4C	;$40 - L
00CBD9  1               ;	.byte	$4A	;$41 - J
00CBD9  1               ;	.byte	$3A	;$42 - colon
00CBD9  1               ;	.byte	$8A	;$43 - SHIFT-F1
00CBD9  1               ;	.byte	$8B	;$44 - SHIFT-F2
00CBD9  1               ;	.byte	$4B	;$45 - K
00CBD9  1               ;	.byte	$5C	;$46 - \
00CBD9  1               ;	.byte	$5E	;$47 - ^
00CBD9  1               ;	.byte	$4F	;$48 - O
00CBD9  1               ;	.byte	$80	;$49 - (invalid)
00CBD9  1               ;	.byte	$50	;$4A - P
00CBD9  1               ;	.byte	$55	;$4B - U
00CBD9  1               ;	.byte	$9B	;$4C - SHIFT-return
00CBD9  1               ;	.byte	$49	;$4D - I
00CBD9  1               ;	.byte	$5F	;$4E - _
00CBD9  1               ;	.byte	$7C	;$4F - |
00CBD9  1               ;
00CBD9  1               ;	.byte	$56	;$50 - V
00CBD9  1               ;	.byte	$80	;$51 - (invalid)
00CBD9  1               ;	.byte	$43	;$52 - C
00CBD9  1               ;	.byte	$8C	;$53 - SHIFT-F3
00CBD9  1               ;	.byte	$8D	;$54 - SHIFT-F4
00CBD9  1               ;	.byte	$42	;$55 - B
00CBD9  1               ;	.byte	$58	;$56 - X
00CBD9  1               ;	.byte	$5A	;$57 - Z
00CBD9  1               ;	.byte	$24	;$58 - $
00CBD9  1               ;	.byte	$80	;$59 - (invalid)
00CBD9  1               ;	.byte	$23	;$5A - #
00CBD9  1               ;	.byte	$26	;$5B - &
00CBD9  1               ;	.byte	$1B	;$5C - SHIFT-escape
00CBD9  1               ;	.byte	$25	;$5D - %
00CBD9  1               ;	.byte	$22	;$5E - "
00CBD9  1               ;	.byte	$21	;$5F - !
00CBD9  1               ;
00CBD9  1               ;	.byte	$5B	;$60 - [
00CBD9  1               ;	.byte	$20	;$61 - SHIFT-space
00CBD9  1               ;	.byte	$5D	;$62 - ]
00CBD9  1               ;	.byte	$4E	;$63 - N
00CBD9  1               ;	.byte	$80	;$64 - (invalid)
00CBD9  1               ;	.byte	$4D	;$65 - M
00CBD9  1               ;	.byte	$3F	;$66 - ?
00CBD9  1               ;	.byte	$81	;$67 - SHIFT-inverse
00CBD9  1               ;	.byte	$52	;$68 - R
00CBD9  1               ;	.byte	$80	;$69 - (invalid)
00CBD9  1               ;	.byte	$45	;$6A - E
00CBD9  1               ;	.byte	$59	;$6B - Y
00CBD9  1               ;	.byte	$9F	;$6C - SHIFT-tab
00CBD9  1               ;	.byte	$54	;$6D - T
00CBD9  1               ;	.byte	$57	;$6E - W
00CBD9  1               ;	.byte	$51	;$6F - Q
00CBD9  1               ;
00CBD9  1               ;	.byte	$28	;$70 - (
00CBD9  1               ;	.byte	$80	;$71 - (invalid)
00CBD9  1               ;	.byte	$29	;$72 - )
00CBD9  1               ;	.byte	$27	;$73 - '
00CBD9  1               ;	.byte	$9C	;$74 - SHIFT-delete
00CBD9  1               ;	.byte	$40	;$75 - @
00CBD9  1               ;	.byte	$7D	;$76 - SHIFT-clear
00CBD9  1               ;	.byte	$9D	;$77 - SHIFT-insert
00CBD9  1               ;	.byte	$46	;$78 - F
00CBD9  1               ;	.byte	$48	;$79 - H
00CBD9  1               ;	.byte	$44	;$7A - D
00CBD9  1               ;	.byte	$80	;$7B - (invalid)
00CBD9  1               ;	.byte	$83	;$7C - SHIFT-CAPS
00CBD9  1               ;	.byte	$47	;$7D - G
00CBD9  1               ;	.byte	$53	;$7E - S
00CBD9  1               ;	.byte	$41	;$7F - A
00CBD9  1               ;
00CBD9  1               ;;	Control Characters
00CBD9  1               ;
00CBD9  1               ;	.byte	$0C	;$80 - CTRL-L
00CBD9  1               ;	.byte	$0A	;$81 - CTRL-J
00CBD9  1               ;	.byte	$7B	;$82 - CTRL-semicolon
00CBD9  1               ;	.byte	$80	;$83 - (invalid)
00CBD9  1               ;	.byte	$80	;$84 - (invalid)
00CBD9  1               ;	.byte	$0B	;$85 - CTRL-K
00CBD9  1               ;	.byte	$1E	;$86 - CTRL-left arrow
00CBD9  1               ;	.byte	$1F	;$87 - CTRL-right arrow
00CBD9  1               ;	.byte	$0F	;$88 - CTRL-O
00CBD9  1               ;	.byte	$80	;$89 - (invalid)
00CBD9  1               ;	.byte	$10	;$8A - CTRL-P
00CBD9  1               ;	.byte	$15	;$8B - CTRL-U
00CBD9  1               ;	.byte	$9B	;$8C - CTRL-return
00CBD9  1               ;	.byte	$09	;$8D - CTRL-I
00CBD9  1               ;	.byte	$1C	;$8E - CTRL-up arrow
00CBD9  1               ;	.byte	$1D	;$8F - CTRL-down arrow
00CBD9  1               ;
00CBD9  1               ;	.byte	$16	;$90 - CTRL-V
00CBD9  1               ;	.byte	$80	;$91 - (invalid)
00CBD9  1               ;	.byte	$03	;$92 - CTRL-C
00CBD9  1               ;	.byte	$89	;$93 - CTRL-F3
00CBD9  1               ;	.byte	$80	;$94 - (invalid)
00CBD9  1               ;	.byte	$02	;$95 - CTRL-B
00CBD9  1               ;	.byte	$18	;$96 - CTRL-X
00CBD9  1               ;	.byte	$1A	;$97 - CTRL-Z
00CBD9  1               ;	.byte	$80	;$98 - (invalid)
00CBD9  1               ;	.byte	$80	;$99 - (invalid)
00CBD9  1               ;	.byte	$85	;$9A - CTRL-3
00CBD9  1               ;	.byte	$80	;$9B - (invalid)
00CBD9  1               ;	.byte	$1B	;$9C - CTRL-escape
00CBD9  1               ;	.byte	$80	;$9D - (invalid)
00CBD9  1               ;	.byte	$FD	;$9E - CTRL-2
00CBD9  1               ;	.byte	$80	;$9F - (invalid)
00CBD9  1               ;
00CBD9  1               ;	.byte	$00	;$A0 - CTRL-comma
00CBD9  1               ;	.byte	$20	;$A1 - CTRL-space
00CBD9  1               ;	.byte	$60	;$A2 - CTRL-period
00CBD9  1               ;	.byte	$0E	;$A3 - CTRL-N
00CBD9  1               ;	.byte	$80	;$A4 - (invalid)
00CBD9  1               ;	.byte	$0D	;$A5 - CTRL-M
00CBD9  1               ;	.byte	$80	;$A6 - (invalid)
00CBD9  1               ;	.byte	$81	;$A7 - CTRL-inverse
00CBD9  1               ;	.byte	$12	;$A8 - CTRL-R
00CBD9  1               ;	.byte	$80	;$A9 - (invalid)
00CBD9  1               ;	.byte	$05	;$AA - CTRL-E
00CBD9  1               ;	.byte	$19	;$AB - CTRL-Y
00CBD9  1               ;	.byte	$9E	;$AC - CTRL-tab
00CBD9  1               ;	.byte	$14	;$AD - CTRL-T
00CBD9  1               ;	.byte	$17	;$AE - CTRL-W
00CBD9  1               ;	.byte	$11	;$AF - CTRL-Q
00CBD9  1               ;
00CBD9  1               ;	.byte	$80	;$B0 - (invalid)
00CBD9  1               ;	.byte	$80	;$B1 - (invalid)
00CBD9  1               ;	.byte	$80	;$B2 - (invalid)
00CBD9  1               ;	.byte	$80	;$B3 - (invalid)
00CBD9  1               ;	.byte	$FE	;$B4 - CTRL-delete
00CBD9  1               ;	.byte	$80	;$B5 - (invalid)
00CBD9  1               ;	.byte	$7D	;$B6 - CTRL-clear
00CBD9  1               ;	.byte	$FF	;$B7 - CTRL-insert
00CBD9  1               ;	.byte	$06	;$B8 - CTRL-F
00CBD9  1               ;	.byte	$08	;$B9 - CTRL-H
00CBD9  1               ;	.byte	$04	;$BA - CTRL-D
00CBD9  1               ;	.byte	$80	;$BB - (invalid)
00CBD9  1               ;	.byte	$84	;$BC - CTRL-CAPS
00CBD9  1               ;	.byte	$07	;$BD - CTRL-G
00CBD9  1               ;	.byte	$13	;$BE - CTRL-S
00CBD9  1               ;	.byte	$01	;$BF - CTRL-A
00CBD9  1               
00CBD9  1               ;;	TFKD - Table of Function Key Definitions
00CBD9  1               ;
00CBD9  1               ;	Entry n is the ATASCII equivalent of adjusted funct:
00CBD9  1               ;	code n.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TFKD:	.byte	$1C	;0 - F1 key
00CBD9  1               ;	.byte	$1D	;1 - F2 key
00CBD9  1               ;	.byte	$1E	;2 - F3 key
00CBD9  1               ;	.byte	$1F	;3 - F3 key
00CBD9  1               ;
00CBD9  1               ;	.byte	$8E	;4 - SHIFT-F1 key
00CBD9  1               ;	.byte	$8F	;5 - SHIFT-F2 key
00CBD9  1               ;	.byte	$90	;6 - SHIFT-F3 key
00CBD9  1               ;	.byte	$91	;7 - SHIFT-F4 key
00CBD9  1               
00CBD9  1               ;	SUBTTL	'Keyboard, Editor and Screen Handler, Part 1'
00CBD9  1               ;;	SPACE	4,10
00CBD9  1               ;;	TSMA - Table of Screen Memory Allocation
00CBD9  1               ;
00CBD9  1               ;	Entry n is the number of $40-byte blocks to allocate for
00CBD9  1               ;	graphics mode n.
00CBD9  1               ;
00CBD9  1               ;	NOTES
00CBD9  1               ;		Problem: For readability, this, and other t:
00CBD9  1               ;		this area, could be moved closer to the oth:
00CBD9  1               ;		the Keyboard, Editor and Screen Handler (ju:
00CBD9  1               ;		the EF6B patch).
00CBD9  1               
00CBD9  1               
00CBD9  1               TSMA:
00CBD9  1               ;	.byte	24	;0
00CBD9  1               ;	.byte	16	;1
00CBD9  1               ;	.byte	10	;2
00CBD9  1               ;	.byte	10	;3
00CBD9  1               ;	.byte	16	;4
00CBD9  1               ;	.byte	28	;5
00CBD9  1               ;	.byte	52	;6
00CBD9  1               ;	.byte	100	;7
00CBD9  1               ;	.byte	196	;8
00CBD9  1               ;	.byte	196	;9
00CBD9  1               ;	.byte	196	;10
00CBD9  1               ;	.byte	196	;11
00CBD9  1               ;	.byte	28	;12
00CBD9  1               ;	.byte	16	;13
00CBD9  1               ;	.byte	100	;14
00CBD9  1               ;	.byte	196	;15
00CBD9  1               ;;	SPACE	4,10
00CBD9  1               ;;	TDLE - Table of Display List Entry Counts
00CBD9  1               ;
00CBD9  1               ;	Each entry is 2 bytes.
00CBD9  1               
00CBD9  1               
00CBD9  1               TDLE:
00CBD9  1               ;	.byte	23,23	;0
00CBD9  1               ;	.byte	11,23	;1
00CBD9  1               ;	.byte	47,47	;2
00CBD9  1               ;	.byte	95,95	;3
00CBD9  1               ;	.byte	97,97	;4
00CBD9  1               ;	.byte	97,97	;5
00CBD9  1               ;	.byte	23,11	;6
00CBD9  1               ;	.byte	191,97	;7
00CBD9  1               ;	.byte	19,19	;8
00CBD9  1               ;	.byte	9,19	;9
00CBD9  1               ;	.byte	39,39	;10
00CBD9  1               ;	.byte	79,79	;11
00CBD9  1               ;	.byte	65,65	;12
00CBD9  1               ;	.byte	65,65	;13
00CBD9  1               ;	.byte	19,9	;14
00CBD9  1               ;	.byte	159,65	;15
00CBD9  1               ;	SPACE	4,10
00CBD9  1               ;;	TAGM - Table of ANTIC Graphics Modes
00CBD9  1               ;
00CBD9  1               ;	Entry n is the ANTIC graphics mode corresponding to internal
00CBD9  1               ;	graphics mode n.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TAGM:	.byte	$02	;internal 0 - 40x2x8 characters
00CBD9  1               ;	.byte	$06	;internal 1 - 20x5x8 characters
00CBD9  1               ;	.byte	$07	;internal 2 - 20x5x16 characters
00CBD9  1               ;	.byte	$08	;internal 3 - 40x4x8 graphics
00CBD9  1               ;	.byte	$09	;internal 4 - 80x2x4 graphics
00CBD9  1               ;	.byte	$0A	;internal 5 - 80x4x4 graphics
00CBD9  1               ;	.byte	$0B	;internal 6 - 160x2x2 graphics
00CBD9  1               ;	.byte	$0D	;internal 7 - 160x4x2 graphics
00CBD9  1               ;	.byte	$0F	;internal 8 - 320x2x1 graphics
00CBD9  1               ;	.byte	$0F	;internal 9 - 320x2x1 GTIA "lum" mode
00CBD9  1               ;	.byte	$0F	;internal 10 - 320x2x1 GTIA "color/lum" mode
00CBD9  1               ;	.byte	$0F	;internal 11 - 320x2x1 GTIA "color" mode
00CBD9  1               ;	.byte	$04	;internal 12 - 40x5x8 characters
00CBD9  1               ;	.byte	$05	;internal 13 - 40x5x16 characters
00CBD9  1               ;	.byte	$0C	;internal 14 - 160x2x1 graphics
00CBD9  1               ;	.byte	$0E	;internal 15 - 160x4x1 graphics
00CBD9  1               ;	SPACE	4,10
00CBD9  1               ;;	TDLV - Table of Display List Vulnerability
00CBD9  1               ;
00CBD9  1               ;	Entry n is non-zero if the display list for mode n cannot
00CBD9  1               ;	cross a page boundary.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TDLV:	.byte	0	;0
00CBD9  1               ;	.byte	0	;1
00CBD9  1               ;	.byte	0	;2
00CBD9  1               ;	.byte	0	;3
00CBD9  1               ;	.byte	0	;4
00CBD9  1               ;	.byte	0	;5
00CBD9  1               ;	.byte	0	;6
00CBD9  1               ;	.byte	1	;7
00CBD9  1               ;	.byte	1	;8
00CBD9  1               ;	.byte	1	;9
00CBD9  1               ;	.byte	1	;10
00CBD9  1               ;	.byte	1	;11
00CBD9  1               ;	.byte	0	;12
00CBD9  1               ;	.byte	0	;13
00CBD9  1               ;	.byte	1	;14
00CBD9  1               ;	.byte	1	;15
00CBD9  1               ;	SPACE	4,10
00CBD9  1               ;;	TLSC - Table of Left Shift Counts
00CBD9  1               ;
00CBD9  1               ;	Entry n is the NUMBER OF LEFT SHIFTS NEEDED TO MULTIPLY
00CBD9  1               ;	COLCRS BY # BYTES/ROW ((ROWCRS;5)/(2;;TLSC)) for mode n.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TLSC:	.byte	4
00CBD9  1               ;	.byte	3	;0
00CBD9  1               ;	.byte	2	;1
00CBD9  1               ;	.byte	2	;2
00CBD9  1               ;	.byte	1	;3
00CBD9  1               ;	.byte	1	;4
00CBD9  1               ;	.byte	2	;5
00CBD9  1               ;	.byte	2	;6
00CBD9  1               ;	.byte	3	;7
00CBD9  1               ;	.byte	3	;8
00CBD9  1               ;	.byte	3	;9
00CBD9  1               ;	.byte	3	;10
00CBD9  1               ;	.byte	3	;11
00CBD9  1               ;	.byte	3	;12
00CBD9  1               ;	.byte	3	;13
00CBD9  1               ;	.byte	2	;14
00CBD9  1               ;	.byte	3	;15
00CBD9  1               ;;	SPACE	4,10
00CBD9  1               ;;	TMCC - Table of Mode Column Counts
00CBD9  1               ;
00CBD9  1               ;	Entry n is the low column count for mode n.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TMCC:	.byte	< CCHARLINE	;0
00CBD9  1               ;	.byte	< 20		;1
00CBD9  1               ;	.byte	< 20		;2
00CBD9  1               ;	.byte	< 40		;3
00CBD9  1               ;	.byte	< 80		;4
00CBD9  1               ;	.byte	< 80		;5
00CBD9  1               ;	.byte	< 160		;6
00CBD9  1               ;	.byte	< 160		;7
00CBD9  1               ;	.byte	< 320		;8
00CBD9  1               ;	.byte	< 80		;9
00CBD9  1               ;	.byte	< 80		;10
00CBD9  1               ;	.byte	< 80		;11
00CBD9  1               ;	.byte	< 40		;12
00CBD9  1               ;	.byte	< 40		;13
00CBD9  1               ;	.byte	< 160		;14
00CBD9  1               ;	.byte	< 160		;15
00CBD9  1               ;	SPACE	4,10
00CBD9  1               ;;	TMRC - Table of Mode Row Counts
00CBD9  1               ;
00CBD9  1               ;	Entry n is the row count for mode n.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TMRC:	.byte	24	;0
00CBD9  1               ;	.byte	24	;1
00CBD9  1               ;	.byte	12	;2
00CBD9  1               ;	.byte	24	;3
00CBD9  1               ;	.byte	48	;4
00CBD9  1               ;	.byte	48	;5
00CBD9  1               ;	.byte	96	;6
00CBD9  1               ;	.byte	96	;7
00CBD9  1               ;	.byte	192	;8
00CBD9  1               ;	.byte	192	;9
00CBD9  1               ;	.byte	192	;10
00CBD9  1               ;	.byte	192	;11
00CBD9  1               ;	.byte	24	;12
00CBD9  1               ;	.byte	12	;13
00CBD9  1               ;	.byte	192	;14
00CBD9  1               ;	.byte	192	;15
00CBD9  1               ;	SPACE	4,10
00CBD9  1               ;;	TRSC - Table of Right Shift Counts
00CBD9  1               ;
00CBD9  1               ;	Entry n is HOW MANY RIGHT SHIFTS FOR HCRSR FOR PARTIAL
00CBD9  1               ;	BYTE MODES for mode n.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;	.byte	0	;0
00CBD9  1               ;	.byte	0	;1
00CBD9  1               ;	.byte	0	;2
00CBD9  1               ;	.byte	2	;3
00CBD9  1               ;	.byte	3	;4
00CBD9  1               ;	.byte	2	;5
00CBD9  1               ;	.byte	3	;6
00CBD9  1               ;	.byte	2	;7
00CBD9  1               ;	.byte	3	;8
00CBD9  1               ;	.byte	1	;9
00CBD9  1               ;	.byte	1	;10
00CBD9  1               ;	.byte	1	;11
00CBD9  1               ;	.byte	0	;12
00CBD9  1               ;	.byte	0	;13
00CBD9  1               ;	.byte	3	;14
00CBD9  1               ;	.byte	2	;15
00CBD9  1               ;	SPACE	4,10
00CBD9  1               ;;	TDSM - Table of Display Masks
00CBD9  1               ;
00CBD9  1               ;	NOTES
00CBD9  1               ;		Includes TBTM - Table of Bit Masks.
00CBD9  1               
00CBD9  1               
00CBD9  1               ;TDSM:	.byte	$FF	;1
00CBD9  1               ;	.byte	$F0	;2
00CBD9  1               ;	.byte	$0F	;3
00CBD9  1               ;	.byte	$C0	;4
00CBD9  1               ;	.byte	$30	;5
00CBD9  1               ;	.byte	$0C	;6
00CBD9  1               ;	.byte	$03	;7
00CBD9  1               
00CBD9  1  80           TBTM:	.byte	$80	;8 (0)
00CBDA  1  40           	.byte	$40	;9 (1)
00CBDB  1  20           	.byte	$20	;10 (2)
00CBDC  1  10           	.byte	$10	;11 (3)
00CBDD  1  08           	.byte	$08	;12 (4)
00CBDE  1  04           	.byte	$04	;13 (5)
00CBDF  1  02           	.byte	$02	;14 (6)
00CBE0  1  01           	.byte	$01	;15 (7)
00CBE1  1               
00CBE1  1  45 3A 0A     EDITOR:		.byte "E:",EOL
00CBE4  1  4B 3A 0A     KEYB:		.byte "K:",EOL
00CBE7  1               
00CBE7  1               HATABSROM:
00CBE7  1  45           		.byte	SCREDT	;editor device code
00CBE8  1  F6 CB        		.word	EDITRV	;editor handler vector table
00CBEA  1               
00CBEA  1  53           		.byte	DISPLY	;screen device code
00CBEB  1  06 CC        		.word	SCRENV	;screen handler vector table
00CBED  1               
00CBED  1  4B           		.byte	KBD	;keyboard device code
00CBEE  1  16 CC        		.word	KEYBDV	;keyboard handler vector table
00CBF0  1               HATABSRS232:
00CBF0  1  52           		.byte	RS232D	;RS232 device code
00CBF1  1  00 00        		.word	0	;RS232 handler vector table
00CBF3  1               
00CBF3  1               	.IF PLATFORM <= 1
00CBF3  1  44           		.byte 	DISK
00CBF4  1  29 CC        		.word	HANDTAB
00CBF6  1               	.ENDIF
00CBF6  1               
00CBF6  1               HATABSROM_end:
00CBF6  1               
00CBF6  1               ;;	EDITRV - Editor Handler Vector Table
00CBF6  1               EDITRV:
00CBF6  1  EE C3        		.word	EOP-1	;perform editor OPEN
00CBF8  1  C5 C4        		.word	ECL-1	;perform editor CLOSE
00CBFA  1  C9 C4        		.word	EGB-1	;perform editor GET-BYTE
00CBFC  1  2F C5        		.word	EPB-1	;perform editor PUT-BYTE
00CBFE  1  B4 C4        		.word	SST-1	;perform editor STATUS (screen STAT:
00CC00  1  C4 C4        		.word	ESP-1	;perform editor SPECIAL
00CC02  1  4C D0 C3     		JMP	SIN	;initialize editor (initialize scre:
00CC05  1  00           		.byte	0	;reserved
00CC06  1               
00CC06  1               
00CC06  1               ;;	SCRENV - Screen Handler Vector Table
00CC06  1               SCRENV:
00CC06  1  EE C3        		.word	SOP-1	;perform screen OPEN
00CC08  1  C5 C4        		.word	ECL-1	;perform screen CLOSE (editor CLOSE:
00CC0A  1  3E C4        		.word	SGB-1	;perform screen GET-BYTE
00CC0C  1  56 C4        		.word	SPB-1	;perform screen PUT-BYTE
00CC0E  1  B4 C4        		.word	SST-1	;perform screen STATUS
00CC10  1  47 CA        		.word	SSP-1	;perform screen SPECIAL
00CC12  1  4C D0 C3     		JMP	SIN	;initialize screen
00CC15  1  00           		.byte	0	;reserved
00CC16  1               
00CC16  1               ;;	KEYBDV - Keyboard Handler Vector Table
00CC16  1               KEYBDV:
00CC16  1  B4 C4        		.word	SST-1	;perform keyboard OPEN (screen STAT:
00CC18  1  B4 C4        		.word	SST-1	;perform keyboard CLOSE (screen STA:
00CC1A  1  42 C1        		.word	KGB-1	;perform keyboard GET-BYTE
00CC1C  1  C4 C4        		.word	ESP-1	;perform keyboard SPECIAL (editor S:
00CC1E  1  B4 C4        		.word	SST-1	;perform keyboard STATUS (screen ST:
00CC20  1  C4 C4        		.word	ESP-1	;perform keyboard SPECIAL (editor S:
00CC22  1  4C D0 C3     		JMP	SIN	;initialize keyboard (initialize sc:
00CC25  1  00           		.byte	0	;reserved
00CC26  1               
00CC26  1               	.IF PLATFORM = 1
00CC26  1               crtset:		.byte 117	; H-Total		R0
00CC26  1               		.byte 80	; H-Disp		R1
00CC26  1               		.byte 91	; H-Sync-Pos		R2
00CC26  1               		.byte $08	; V/H-Sync-Width	R3
00CC26  1               		.byte 37	; V-Total	37	R4
00CC26  1               		.byte 3		; V-Adjust		R5
00CC26  1               		.byte 25	; V-Display 		R6
00CC26  1               		.byte 30	; V-Sync-Pos		R7
00CC26  1               		.byte 0		; Interlace + Skew	R8
00CC26  1               		.byte 7		; Scan-Lines		R9
00CC26  1               		.byte 7		; Cursor-Start		R10
00CC26  1               		.byte 7		; Cursor-End		R11
00CC26  1               		.byte (>SCRSTRT)/8  ; Screen-Start Hi   R12
00CC26  1               		.byte 0		; Screen-Start Lo	R13
00CC26  1               		.byte (>SCRSTRT)/8+$07, $a8; Cursor-Pos		R14,R15 H+L
00CC26  1               	.ENDIF
00CC26  1               ;
00CC26  1               		.include "fat16.a65"
00CC26  2               .macro	cmp_icbalz_y
00CC26  2               	.IF PLATFORM=0
00CC26  2               		CMP [ICBALZ],Y
00CC26  2               	.ELSE
00CC26  2               		CMP (ICBALZ),Y
00CC26  2               	.ENDIF
00CC26  2               .endmacro
00CC26  2               
00CC26  2               .macro	lda_icbalz_y
00CC26  2               	.IF PLATFORM=0
00CC26  2               		LDA [ICBALZ],Y
00CC26  2               	.ELSE
00CC26  2               		LDA (ICBALZ),Y
00CC26  2               	.ENDIF
00CC26  2               .endmacro
00CC26  2               
00CC26  2               .macro	sta_icbalz_y
00CC26  2               	.IF PLATFORM=0
00CC26  2               		STA [ICBALZ],Y
00CC26  2               	.ELSE
00CC26  2               		STA (ICBALZ),Y
00CC26  2               	.ENDIF
00CC26  2               .endmacro
00CC26  2               
00CC26  2               	.IF PLATFORM = 2
00CC26  2               		.include "atarixl.inc"
00CC26  2               		.include "fat16.inc"
00CC26  2               
00CC26  2               EPB	=	$F2B0		;putbyte
00CC26  2               
00CC26  2               		.ORG FATCODE
00CC26  2               
00CC26  2               		JMP STARTUP	;0
00CC26  2               		JMP PRINT	;3
00CC26  2               		JMP PUTHEX	;6
00CC26  2               		JMP PRINTSTR	;9
00CC26  2               		JMP INITFAT
00CC26  2               	.ENDIF
00CC26  2               ;
00CC26  2               ;
00CC26  2               ;
00CC26  2               STARTUP:
00CC26  2               	.IF PLATFORM = 2
00CC26  2               		LDA #<INIT
00CC26  2               		STA DOSINI
00CC26  2               		LDA #>INIT
00CC26  2               		STA DOSINI+1
00CC26  2               
00CC26  2               		LDA #<DUPCODE
00CC26  2               		STA DOSVEC
00CC26  2               		LDA #>DUPCODE
00CC26  2               		STA DOSVEC+1
00CC26  2               
00CC26  2               ;		LDA #25		; ATMAS-II patches
00CC26  2               ;		STA $329F
00CC26  2               ;		STA $32BF
00CC26  2               ;		LDA #'B'
00CC26  2               ;		STA $2A11
00CC26  2               
00CC26  2               INIT:		LDY #<HANDTAB
00CC26  2               		LDA #>HANDTAB
00CC26  2               		LDX #DRVCHAR
00CC26  2               		JSR $E486
00CC26  2               
00CC26  2               		LDA #<$2150
00CC26  2               		STA MEMLO
00CC26  2               		LDA #>$2150
00CC26  2               		STA MEMLO+1
00CC26  2               
00CC26  2               	.ELSE
00CC26  2               ;		ldx #0
00CC26  2               ;HAFIND:		lda HATABS,x
00CC26  2               ;		beq HAFOUND
00CC26  2               ;		cmp #DRVCHAR
00CC26  2               ;		beq HAFOUND
00CC26  2               ;		inx
00CC26  2               ;		inx
00CC26  2               ;		inx
00CC26  2               ;		cpx #MAXDEV
00CC26  2               ;		bcc HAFIND
00CC26  2               ;		rts
00CC26  2               ;HAFOUND:	lda #DRVCHAR
00CC26  2               ;		sta HATABS,x
00CC26  2               ;		lda #<HANDTAB
00CC26  2               ;		sta HATABS+1,x
00CC26  2               ;		lda #>HANDTAB
00CC26  2               ;		sta HATABS+2,x
00CC26  2               	.ENDIF
00CC26  2  4C BD D5     		JMP INITFAT
00CC29  2               
00CC29  2  AF CD        HANDTAB:	.word OPENCHA-1		; open channel
00CC2B  2  E8 CE        		.word CLOSECHA-1	; close ...
00CC2D  2  C0 CF        		.word GETCHA-1		; get channel
00CC2F  2  25 CF        		.word PUTCHA-1		; put channel
00CC31  2  87 D0        		.word STATUSCHA-1	; status of channel
00CC33  2  8A D0        		.word SPECIAL-1
00CC35  2               		;jmp INITFAT
00CC35  2  60           		rts
00CC36  2  00 00        		.byte 0,0
00CC38  2  00           		.byte 0
00CC39  2               
00CC39  2               ;
00CC39  2               ; 		DIRFILE	0=ALL, 1=FILES, 2=FREE DIR,
00CC39  2               ;			3=DIR
00CC39  2               ;
00CC39  2  8D AD 04     DIRSTART:	STA DIRFILE
00CC3C  2               
00CC3C  2  AD 41 04     		LDA DIRCLUS
00CC3F  2  8D 81 04     		STA FSTRTCL
00CC42  2  AD 42 04     		LDA DIRCLUS+1
00CC45  2  8D 82 04     		STA FSTRTCL+1
00CC48  2  60           		RTS
00CC49  2               ;
00CC49  2               ;
00CC49  2               ;
00CC49  2  A0 01        CHECKHAN:	LDY #1
00CC4B  2  A9 3A        		LDA #':'
00CC4D  2  D7 24        		cmp_icbalz_y
00CC4F  2               ;		CMP (ICBALZ),Y
00CC4F  2  F0 0A        		BEQ CHECKHA1
00CC51  2  C8           		INY
00CC52  2  D7 24        		cmp_icbalz_y
00CC54  2               ;		CMP (ICBALZ),Y
00CC54  2  F0 05        		BEQ CHECKHA1
00CC56  2  20 B8 CC     ERR165:		JSR CLOSEFCB
00CC59  2  A0 A5        		LDY #165
00CC5B  2  60           CHECKHA1:	RTS
00CC5C  2               
00CC5C  2               ;
00CC5C  2               ;
00CC5C  2               ;
00CC5C  2  20 39 CC     GETFILE:	JSR DIRSTART
00CC5F  2  20 49 CC     		JSR CHECKHAN
00CC62  2  30 23        		BMI FINDFILEND
00CC64  2               
00CC64  2  C8           		INY
00CC65  2  20 63 CE     		JSR STR2RAW
00CC68  2  20 49 D2     		JSR OPENDIR
00CC6B  2               
00CC6B  2               FINDFIL1:	;lda #'F'
00CC6B  2               		;jsr PRINT
00CC6B  2               
00CC6B  2  A0 00        		LDY #0
00CC6D  2               FINDFIL3:
00CC6D  2               ;		lda (FATPTRS),y
00CC6D  2  B9 9C 04     		LDA DIRTEXT,Y
00CC70  2               ;		jsr PRINT
00CC70  2  C9 3F        		CMP #'?'
00CC72  2  F0 0C        		BEQ FINDFIL2
00CC74  2  D1 06        		CMP (FATPTRS),Y
00CC76  2  F0 08        		BEQ FINDFIL2
00CC78  2               
00CC78  2  20 44 D0     NEXTFILE:	JSR NEXTDIR
00CC7B  2  90 EE        		BCC FINDFIL1
00CC7D  2  A0 AA        		LDY #170
00CC7F  2  60           		RTS
00CC80  2               
00CC80  2  C8           FINDFIL2:	INY
00CC81  2  C0 0B        		CPY #11
00CC83  2  D0 E8        		BNE FINDFIL3
00CC85  2  A0 01        		LDY #1
00CC87  2  60           FINDFILEND:	RTS
00CC88  2               ;
00CC88  2               ;
00CC88  2               ;
00CC88  2               
00CC88  2  A5 06        SAVEDIR:	LDA FATPTRS
00CC8A  2  8D A7 04     		STA DIRPTR
00CC8D  2  A5 07        		LDA FATPTRS+1
00CC8F  2  8D A8 04     		STA DIRPTR+1
00CC92  2  A2 03        		LDX #3
00CC94  2               SAVEDIR1:
00CC94  2  BD 0C 04     		LDA SECTOR,X
00CC97  2  9D A9 04     		STA DIRSEC,X
00CC9A  2  CA           		DEX
00CC9B  2  10 F7        		BPL SAVEDIR1
00CC9D  2  60           		RTS
00CC9E  2               
00CC9E  2  8D 0B 04     GETFCB:		STA FCBCODE
00CCA1  2  A2 00        		LDX #0
00CCA3  2  AD 0B 04     GETFCB0:	LDA FCBCODE
00CCA6  2  DD 00 05     		CMP FCB0,X
00CCA9  2  F0 0A        		BEQ GETFCB9
00CCAB  2  8A           		TXA
00CCAC  2  18           		CLC
00CCAD  2  69 40        		ADC #64
00CCAF  2  AA           		TAX
00CCB0  2  D0 F1        		BNE GETFCB0
00CCB2  2  A0 A1        		LDY #161		;TOO MANY
00CCB4  2  60           		RTS
00CCB5  2  A0 01        GETFCB9:	LDY #1
00CCB7  2  60           		RTS			;OPEN FILES
00CCB8  2               
00CCB8  2               CLOSEFCB:
00CCB8  2  AE 80 04     		LDX FFCBOFF
00CCBB  2               
00CCBB  2               ;		stz DEVICNO
00CCBB  2               ;		txa
00CCBB  2               ;		jsr jprinthex
00CCBB  2               ;		inc DEVICNO
00CCBB  2               
00CCBB  2  A9 FF        		LDA #$FF
00CCBD  2  8D 7F 04     		STA FIOCBNR
00CCC0  2  9D 00 05     		STA FCB0,X
00CCC3  2  60           		RTS
00CCC4  2               
00CCC4  2               
00CCC4  2               SETFCB:
00CCC4  2               ;		stz DEVICNO
00CCC4  2               ;		lda FIOCBNR
00CCC4  2               ;		jsr jprinthex
00CCC4  2               ;		lda ICIDNO
00CCC4  2               ;		jsr jprinthex
00CCC4  2               ;		inc DEVICNO
00CCC4  2               
00CCC4  2  AD 7F 04     		LDA FIOCBNR		;RIGHT FCB
00CCC7  2  C5 2E        		CMP ICIDNO		;ACTIVE?
00CCC9  2  F0 37        		BEQ SETFCB9		;YES
00CCCB  2               
00CCCB  2               ;		stz DEVICNO
00CCCB  2               ;		lda #'*'
00CCCB  2               ;		jsr jprinthex
00CCCB  2               ;		inc DEVICNO
00CCCB  2               ;		lda FIOCBNR
00CCCB  2               
00CCCB  2  C9 FF        SWAPFCB:	CMP #$FF
00CCCD  2  F0 14        		BEQ SWAPIN
00CCCF  2               
00CCCF  2  20 35 D5     		JSR SEC2FSEC
00CCD2  2               
00CCD2  2  A0 00        		LDY #0
00CCD4  2  AE 80 04     		LDX FFCBOFF
00CCD7  2               SWAPFCB0:
00CCD7  2  B9 7F 04     		LDA FIOCBNR,Y
00CCDA  2  9D 00 05     		STA FCB0,X
00CCDD  2  E8           		INX
00CCDE  2  C8           		INY
00CCDF  2  C0 2F        		CPY #FBLKEND-F+1
00CCE1  2  D0 F4        		BNE SWAPFCB0
00CCE3  2               
00CCE3  2               SWAPIN:
00CCE3  2  A5 2E        		LDA ICIDNO
00CCE5  2  20 9E CC     		JSR GETFCB
00CCE8  2               
00CCE8  2  A0 00        		LDY #0
00CCEA  2  BD 00 05     SWAPIN0:	LDA FCB0,X
00CCED  2  99 7F 04     		STA FIOCBNR,Y
00CCF0  2  E8           		INX
00CCF1  2  C8           		INY
00CCF2  2  C0 2F        		CPY #FBLKEND-F+1
00CCF4  2  D0 F4        		BNE SWAPIN0
00CCF6  2               
00CCF6  2  A5 22        		LDA ICCOMZ
00CCF8  2  C9 03        		CMP #OPEN
00CCFA  2  F0 06        		BEQ SETFCB9
00CCFC  2               
00CCFC  2  20 4B D5     		JSR FSEC2SEC
00CCFF  2  20 EE D8     		JSR READSEC
00CD02  2               
00CD02  2  60           SETFCB9:	RTS
00CD03  2               ;
00CD03  2               ;
00CD03  2               ;
00CD03  2               
00CD03  2  A9 FF        OPENFCB:	LDA #$FF
00CD05  2  20 9E CC     		JSR GETFCB		;get FREE FCB
00CD08  2  10 01        		BPL OPENFCB1
00CD0A  2  60           		RTS
00CD0B  2               
00CD0B  2  A5 2E        OPENFCB1:	LDA ICIDNO
00CD0D  2  9D 00 05     		STA FCB0,X
00CD10  2               
00CD10  2  A9 00        		LDA #0			;CLEAR FCB
00CD12  2  A0 2D        		LDY #FBLKEND-F-1
00CD14  2               OPENFCB0:
00CD14  2  9D 02 05     		STA FCB0+2,X
00CD17  2  E8           		INX
00CD18  2  88           		DEY
00CD19  2  D0 F9        		BNE OPENFCB0
00CD1B  2               
00CD1B  2  20 C4 CC     		JSR SETFCB
00CD1E  2  A0 01        		LDY #1
00CD20  2  60           		RTS
00CD21  2               ;
00CD21  2               ;
00CD21  2               ;
00CD21  2               VALIDNAM:
00CD21  2               ;		ldx #0
00CD21  2               ;v1:		lda DIRTEXT,x
00CD21  2               ;		jsr PUTHEX
00CD21  2               ;		lda #32
00CD21  2               ;		jsr PRINT
00CD21  2               ;		inx
00CD21  2               ;		cpx #11
00CD21  2               ;		bne v1
00CD21  2               
00CD21  2  A2 0A        		LDX #10
00CD23  2  BD 9C 04     VALIDNA1:	LDA DIRTEXT,X	;CARD
00CD26  2  C9 30        		CMP #'0'
00CD28  2  90 0C        		BCC VALIDNA3	;< 0? => check special chars
00CD2A  2  C9 3A        		CMP #'9'+1	;<= 9?
00CD2C  2  90 21        		BCC VALIDNA2	;yes OK, next char
00CD2E  2  C9 41        		CMP #'A'	;
00CD30  2  90 04        		BCC VALIDNA3	;< A? => check special chars
00CD32  2  C9 5B        		CMP #'Z'+1	;<= Z?
00CD34  2  90 19        		BCC VALIDNA2	;yes OK, next char
00CD36  2               
00CD36  2  AC 69 04     VALIDNA3:	LDY VALIDS
00CD39  2  D9 42 CD     VALIDNA4:	CMP VALIDCHA,Y
00CD3C  2  F0 11        		BEQ VALIDNA2
00CD3E  2  88           		DEY
00CD3F  2  10 F8        		BPL VALIDNA4
00CD41  2  60           		RTS		;no valid char found, return N=1
00CD42  2               
00CD42  2  20 21 23 24  VALIDCHA:	.byte " !#$%&()-_^|?"	;usually test without "?", so 12+1 bytes!
00CD46  2  25 26 28 29  
00CD4A  2  2D 5F 5E 7C  
00CD4F  2               
00CD4F  2  CA           VALIDNA2:	DEX
00CD50  2  10 D1        		BPL VALIDNA1	;X=$FF
00CD52  2               
00CD52  2  A9 20        		LDA #32		;check if first char != space
00CD54  2  CD 9C 04     		CMP DIRTEXT
00CD57  2  F0 02        		BEQ VALIDNA9
00CD59  2               
00CD59  2               ;		CMP DIRTEXT+8
00CD59  2               ;		BEQ VALIDNA9
00CD59  2               
00CD59  2  E8           		INX		;X=0, make sure N=0
00CD5A  2  60           		RTS
00CD5B  2               
00CD5B  2  CA           VALIDNA9:	DEX		;X=$FE, N=1
00CD5C  2  60           		RTS
00CD5D  2               ;
00CD5D  2               ;
00CD5D  2               ;
00CD5D  2  A5 06        DUMPPTR:	LDA FATPTRS
00CD5F  2  20 53 D9     		JSR PUTHEX
00CD62  2  A5 07        		LDA FATPTRS+1
00CD64  2  4C 53 D9     		JMP PUTHEX
00CD67  2               ;
00CD67  2               ;
00CD67  2               ;
00CD67  2  A2 02        INITDIR:	LDX #2
00CD69  2  A9 00        		LDA #0
00CD6B  2  20 61 D5     		JSR GETFCLUS
00CD6E  2  AD 3C 04     		LDA NEWCLUS+1
00CD71  2  48           		PHA
00CD72  2  AD 3B 04     		LDA NEWCLUS
00CD75  2  48           		PHA
00CD76  2               
00CD76  2  20 53 CE     		JSR FINDFDIR
00CD79  2  B0 0A        		BCS INITDIR1
00CD7B  2  68           		PLA
00CD7C  2  68           		PLA		;NO FREE DIR
00CD7D  2  68           		PLA
00CD7E  2  68           		PLA
00CD7F  2  20 B8 CC     ERR169:		JSR CLOSEFCB
00CD82  2  A0 A9        		LDY #169
00CD84  2  60           		RTS
00CD85  2               
00CD85  2               INITDIR1:
00CD85  2  A0 00        		LDY #0		;DIRNAME IN
00CD87  2  8C AD 04     		STY DIRFILE	;RESET DIRFILE
00CD8A  2               INITDIR2:
00CD8A  2  B9 9C 04     		LDA DIRTEXT,Y	;DIR ENTRY
00CD8D  2  91 06        		STA (FATPTRS),Y
00CD8F  2  C8           		INY
00CD90  2  C0 0B        		CPY #11
00CD92  2  D0 F6        		BNE INITDIR2
00CD94  2               
00CD94  2  A9 00        		LDA #0		;INITIALIZE
00CD96  2  91 06        INITDIR3:	STA (FATPTRS),Y	;REST
00CD98  2  C8           		INY
00CD99  2  C0 20        		CPY #32
00CD9B  2  D0 F9        		BNE INITDIR3
00CD9D  2               
00CD9D  2  8C 3D 04     		STY DDIRTY	;PUT START
00CDA0  2  A0 1A        		LDY #DCLUS	;CLUSTER
00CDA2  2  68           		PLA		;INTO
00CDA3  2  8D 91 04     		STA FCURCLUS
00CDA6  2               ;		JSR PUTHEX
00CDA6  2  91 06        		STA (FATPTRS),Y	;DIR ENTRY
00CDA8  2  C8           		INY
00CDA9  2  68           		PLA
00CDAA  2  8D 92 04     		STA FCURCLUS+1
00CDAD  2               ;		JSR PUTHEX
00CDAD  2  91 06        		STA (FATPTRS),Y
00CDAF  2               
00CDAF  2               ;		BRK
00CDAF  2  60           		RTS
00CDB0  2               
00CDB0  2               ;-------------------------------------------------------------------------------
00CDB0  2               ; OPENCHA - Open Channel
00CDB0  2               ; opens a FCB file control block for IO
00CDB0  2               ;-------------------------------------------------------------------------------
00CDB0  2  20 03 CD     OPENCHA:	JSR OPENFCB
00CDB3  2  30 27        		BMI OPENERR
00CDB5  2               ;		RTS
00CDB5  2               
00CDB5  2               ;		LDA #$FF
00CDB5  2               ;		STA FBURST
00CDB5  2               
00CDB5  2  A5 2A        		LDA ICAX1Z
00CDB7  2  29 06        		AND #6
00CDB9  2  C9 06        		CMP #6
00CDBB  2  D0 0B        		BNE OPENFILE
00CDBD  2               
00CDBD  2  20 A7 D5     OPENDI:		JSR INITLSEC
00CDC0  2  A9 00        		LDA #0
00CDC2  2  8D 6A 04     		STA HILF
00CDC5  2  4C 5C CC     		JMP GETFILE
00CDC8  2               
00CDC8  2  A9 01        OPENFILE:	LDA #1		;FILE THERE?
00CDCA  2  20 5C CC     		JSR GETFILE
00CDCD  2  10 19        		BPL OPENEXIS	;YES
00CDCF  2               
00CDCF  2  A5 2A        OPENNEW:	LDA ICAX1Z	;WRITE FILE?
00CDD1  2  29 0D        		AND #1+4+8	;NO READ OR
00CDD3  2  C9 08        		CMP #8		;APPEND
00CDD5  2  F0 06        		BEQ OPENNEW3
00CDD7  2  20 B8 CC     OPEN170:	JSR CLOSEFCB
00CDDA  2  A0 AA        		LDY #170
00CDDC  2  60           OPENERR:	RTS
00CDDD  2               
00CDDD  2  20 21 CD     OPENNEW3:	JSR VALIDNAM
00CDE0  2  10 03        		BPL OPENNEW4
00CDE2  2  4C 56 CC     		JMP ERR165
00CDE5  2               
00CDE5  2  20 67 CD     OPENNEW4:	JSR INITDIR
00CDE8  2               
00CDE8  2  20 88 CC     OPENEXIS:	JSR SAVEDIR
00CDEB  2  A2 05        		LDX #5		;GET START
00CDED  2  A0 1F        		LDY #DCLUS+5	;CLUSTER
00CDEF  2  B1 06        OPENF1:		LDA (FATPTRS),Y	;AND FILELEN
00CDF1  2  9D 81 04     		STA FSTRTCL,X	;FROM
00CDF4  2  88           		DEY		;DIRENTRY
00CDF5  2  CA           		DEX
00CDF6  2  10 F7        		BPL OPENF1
00CDF8  2               
00CDF8  2               ;		LDX #15		INITIALIZE
00CDF8  2               ;		LDA #0		REST
00CDF8  2               ;		STA FCURSEC
00CDF8  2               ;OPENF2		STA FBYT2RD,X
00CDF8  2               ;		DEX
00CDF8  2               ;		BNE OPENF2
00CDF8  2               
00CDF8  2  A5 2A        		LDA ICAX1Z	;IF READ
00CDFA  2  29 04        		AND #4		;FINISHED
00CDFC  2  D0 29        		BNE OPENEND
00CDFE  2               
00CDFE  2               ;		LDA #'*'
00CDFE  2               ;		JSR PRINT
00CDFE  2               
00CDFE  2  A5 2A        		LDA ICAX1Z	;APPEND?
00CE00  2  29 01        		AND #1
00CE02  2  F0 0E        		BEQ OPENWRIT	;NO
00CE04  2               
00CE04  2  A2 03        		LDX #3		;if append
00CE06  2  BD 83 04     OPENF3:		LDA FILELEN,X	;copy filelen
00CE09  2  9D 89 04     		STA FRPOS,X	;to file-read-pos
00CE0C  2  CA           		DEX
00CE0D  2  10 F7        		BPL OPENF3
00CE0F  2               
00CE0F  2  4C 27 CE     		JMP OPENEND
00CE12  2               
00CE12  2               OPENWRIT:
00CE12  2  A0 FF        		LDY #$FF
00CE14  2  AE 81 04     		LDX FSTRTCL
00CE17  2  AD 82 04     		LDA FSTRTCL+1
00CE1A  2  20 2D CE     		JSR DELCLUS
00CE1D  2               
00CE1D  2  A9 00        		LDA #0
00CE1F  2  A2 03        		LDX #3
00CE21  2  9D 83 04     OPENW4:		STA FILELEN,X
00CE24  2  CA           		DEX
00CE25  2  10 FA        		BPL OPENW4
00CE27  2               
00CE27  2  20 96 D4     OPENEND:	JSR FSEEK
00CE2A  2  A0 01        		LDY #1
00CE2C  2  60           		RTS
00CE2D  2               ;
00CE2D  2               ;
00CE2D  2               ;
00CE2D  2  8C 6A 04     DELCLUS:	STY HILF
00CE30  2               
00CE30  2  C9 FF        DELCLUS1:	CMP #$FF
00CE32  2  D0 05        		BNE DELCLUS2
00CE34  2  E0 FF        		CPX #$FF
00CE36  2  D0 01        		BNE DELCLUS2
00CE38  2  60           		RTS
00CE39  2               
00CE39  2  20 0F D8     DELCLUS2:	JSR GETCLUST
00CE3C  2  48           		PHA
00CE3D  2  8C 3E 04     		STY FDIRTY
00CE40  2  AD 6A 04     		LDA HILF
00CE43  2  91 06        		STA (FATPTRS),Y
00CE45  2  88           		DEY
00CE46  2  91 06        		STA (FATPTRS),Y
00CE48  2  68           		PLA
00CE49  2               
00CE49  2  AC 6A 04     		LDY HILF
00CE4C  2  F0 E2        		BEQ DELCLUS1
00CE4E  2  EE 6A 04     		INC HILF
00CE51  2  F0 DD        		BEQ DELCLUS1
00CE53  2               ;
00CE53  2               ;
00CE53  2               ;
00CE53  2  A9 02        FINDFDIR:	LDA #2
00CE55  2  20 39 CC     		JSR DIRSTART
00CE58  2  20 49 D2     		JSR OPENDIR
00CE5B  2  B0 05        		BCS FINDFDI1
00CE5D  2               FINDFDI2:
00CE5D  2  20 44 D0     		JSR NEXTDIR
00CE60  2  90 FB        		BCC FINDFDI2
00CE62  2  60           FINDFDI1:	RTS
00CE63  2               
00CE63  2               
00CE63  2  A2 0A        STR2RAW:	LDX #10			;fill DIRTEXT
00CE65  2  A9 20        		LDA #32			;with spaces
00CE67  2  9D 9C 04     S2R12:		STA DIRTEXT,X
00CE6A  2  CA           		DEX
00CE6B  2  10 FA        		BPL S2R12
00CE6D  2               
00CE6D  2  E8           		INX			;x = 0
00CE6E  2  8E 4F 04     		STX WILD
00CE71  2               
00CE71  2  A9 2E        		LDA #'.'
00CE73  2  D7 24        		cmp_icbalz_y		;first char '.' (local dir)?
00CE75  2               ;		CMP (ICBALZ),Y
00CE75  2  D0 0E        		BNE S2R1			;no, goto S2R1
00CE77  2  8D 9C 04     		STA DIRTEXT			;save in first char of DIRTEXT
00CE7A  2  C8           		INY					;examine next input char
00CE7B  2  D7 24        		cmp_icbalz_y
00CE7D  2               ;		CMP (ICBALZ),Y		;also '.'?
00CE7D  2  D0 06        		BNE S2R1			;no, goto S2R1
00CE7F  2  8D 9D 04     		STA DIRTEXT+1		;save in 2nd char of DIRTEXT
00CE82  2  C8           		INY					;Y += 2 ?
00CE83  2  C8           		INY
00CE84  2  60           		RTS					;return
00CE85  2               
00CE85  2  20 A7 CE     S2R1:		JSR S2R4		;call S2R4 until 8 chars processed
00CE88  2  B0 04        		BCS S2R2
00CE8A  2  E0 08        		CPX #8
00CE8C  2  D0 F7        		BNE S2R1
00CE8E  2  C9 0A        S2R2:		CMP #EOL
00CE90  2  F0 14        		BEQ S2R6
00CE92  2  C9 2F        		CMP #'/'
00CE94  2  F0 10        		BEQ S2R6
00CE96  2  A2 08        		LDX #8
00CE98  2  A9 00        		LDA #0
00CE9A  2  8D 4F 04     		STA WILD
00CE9D  2  20 A7 CE     S2R5:		JSR S2R4
00CEA0  2  B0 04        		BCS S2R6
00CEA2  2  E0 0B        		CPX #11
00CEA4  2  D0 F7        		BNE S2R5
00CEA6  2  60           S2R6:		RTS
00CEA7  2               
00CEA7  2  B7 24        S2R4:		lda_icbalz_y
00CEA9  2               ;		LDA (ICBALZ),Y
00CEA9  2               ;		JSR PRINT
00CEA9  2  2C 4F 04     		BIT WILD		;wildcard active?
00CEAC  2  30 26        		BMI S2R7		;yes => S2R7
00CEAE  2               
00CEAE  2  C8           		INY
00CEAF  2  C9 2A        		CMP #'*'
00CEB1  2  D0 05        		BNE S2R8
00CEB3  2  CE 4F 04     		DEC WILD
00CEB6  2  30 1C        		BMI S2R7
00CEB8  2  C9 2E        S2R8:		CMP #'.'
00CEBA  2  D0 06        		BNE S2R11
00CEBC  2  E0 08        		CPX #8
00CEBE  2  90 26        		BCC S2R3
00CEC0  2  18           		CLC
00CEC1  2  60           		RTS
00CEC2  2  C9 20        S2R11:		CMP #32			;is space?
00CEC4  2  F0 20        		BEQ S2R3		;yes => next
00CEC6  2  C9 0A        		CMP #EOL
00CEC8  2  F0 1C        		BEQ S2R3
00CECA  2  C9 2F        		CMP #'/'
00CECC  2  F0 18        		BEQ S2R3
00CECE  2  C9 00        		CMP #0
00CED0  2  F0 14        		BEQ S2R3
00CED2  2  D0 02        		BNE S2R9
00CED4  2  A9 3F        S2R7:		LDA #'?'
00CED6  2  C9 61        S2R9:		CMP #'a'
00CED8  2  90 06        		BCC S2R10
00CEDA  2  C9 7B        		CMP #'z'+1
00CEDC  2  B0 02        		BCS S2R10
00CEDE  2  E9 1F        		SBC #31
00CEE0  2  9D 9C 04     S2R10:		STA DIRTEXT,X		;normal character
00CEE3  2  E8           		INX
00CEE4  2  18           		CLC
00CEE5  2  60           		RTS
00CEE6  2  E8           S2R3:		INX
00CEE7  2  38           		SEC
00CEE8  2  60           		RTS
00CEE9  2               
00CEE9  2               ;
00CEE9  2               ;
00CEE9  2               ;
00CEE9  2  20 C4 CC     CLOSECHA:	JSR SETFCB
00CEEC  2               
00CEEC  2  A5 2A        		LDA ICAX1Z
00CEEE  2  29 08        		AND #8
00CEF0  2  F0 2E        		BEQ CLOSE5
00CEF2  2               
00CEF2  2  20 84 D8     		JSR WRITEFAT
00CEF5  2               
00CEF5  2  A2 03        		LDX #3
00CEF7  2  BD A9 04     CLOSE3:		LDA DIRSEC,X
00CEFA  2  9D 0C 04     		STA SECTOR,X
00CEFD  2  CA           		DEX
00CEFE  2  10 F7        		BPL CLOSE3
00CF00  2  20 EE D8     		JSR READSEC
00CF03  2               
00CF03  2  AD A7 04     		LDA DIRPTR
00CF06  2  85 08        		STA FATPTRD
00CF08  2  AD A8 04     		LDA DIRPTR+1
00CF0B  2  85 09        		STA FATPTRD+1
00CF0D  2               
00CF0D  2  A0 1F        		LDY #DLEN+3
00CF0F  2  8C 3D 04     		STY DDIRTY
00CF12  2  A2 03        		LDX #3
00CF14  2  BD 83 04     CLOSE4:		LDA FILELEN,X
00CF17  2               ;		JSR PUTHEX
00CF17  2  91 08        		STA (FATPTRD),Y
00CF19  2  88           		DEY
00CF1A  2  CA           		DEX
00CF1B  2  10 F7        		BPL CLOSE4
00CF1D  2               
00CF1D  2  20 D4 D8     		JSR WRITESEC
00CF20  2               
00CF20  2  20 B8 CC     CLOSE5:		JSR CLOSEFCB
00CF23  2  4C 45 D2     		JMP OK
00CF26  2               
00CF26  2               ;
00CF26  2               ;
00CF26  2               ;
00CF26  2               ;
00CF26  2               ; PUTCHANNEL
00CF26  2               ;
00CF26  2  85 2F        PUTCHA:		STA CIOCHR	; save byte, could have been called via ICPTLZ
00CF28  2               
00CF28  2  20 C4 CC     		JSR SETFCB
00CF2B  2               
00CF2B  2  A5 2A        		LDA ICAX1Z	;UPDATE?
00CF2D  2  29 04        		AND #4		;CECK
00CF2F  2  F0 08        		BEQ PUTCHA1	;FILELEN
00CF31  2               
00CF31  2  20 C7 D2     PUTUPD:		JSR CHECKLEN	;file-pos less than filelen
00CF34  2  90 68        		BCC PUTSLOW1	;yes, continue slow
00CF36  2  A0 88        PUTUPD1:	LDY #EOF	;signal error
00CF38  2  60           		RTS
00CF39  2               
00CF39  2  A5 06        PUTCHA1:	LDA FATPTRS	;points to begin of page?
00CF3B  2  D0 5E        		BNE PUTSLOW
00CF3D  2  A5 28        		LDA ICBLHZ	;at least 512 bytes To write?
00CF3F  2  C9 02        		CMP #2
00CF41  2  90 58        		BCC PUTSLOW
00CF43  2  A5 07        		LDA FATPTRS+1	;points to begin of buffer?
00CF45  2  C9 06        		CMP #>BUFFER
00CF47  2  D0 52        		BNE PUTSLOW
00CF49  2  A5 22        		LDA ICCOMZ	;binary put?
00CF4B  2  C9 0B        		CMP #PUTCHR
00CF4D  2  D0 4C        		BNE PUTSLOW
00CF4F  2               
00CF4F  2  EE 87 04     PUTFAST:	INC FWBURST
00CF52  2  A0 00        		LDY #0
00CF54  2  B7 24        PUTFAST1:	lda_icbalz_y
00CF56  2               ;		LDA (ICBALZ),Y
00CF56  2  99 00 06     		STA BUFFER,Y
00CF59  2  C8           		INY
00CF5A  2  D0 F8        		BNE PUTFAST1
00CF5C  2  E6 25        		INC ICBAHZ
00CF5E  2  B7 24        PUTFAST2:	lda_icbalz_y
00CF60  2               ;		LDA (ICBALZ),Y
00CF60  2  99 00 07     		STA BUFFER+$100,Y
00CF63  2  C8           		INY
00CF64  2  D0 F8        		BNE PUTFAST2
00CF66  2               
00CF66  2  C8           		INY
00CF67  2  8C 3D 04     		STY DDIRTY
00CF6A  2               
00CF6A  2  20 6E D3     		JSR INCRPOS2
00CF6D  2  20 6E D3     		JSR INCRPOS2
00CF70  2               
00CF70  2  20 B3 CF     		JSR INCFILELE2
00CF73  2  20 B3 CF     		JSR INCFILELE2
00CF76  2               
00CF76  2  38           		SEC
00CF77  2  A5 27        		LDA ICBLLZ
00CF79  2  E9 FF        		SBC #$FF
00CF7B  2  85 27        		STA ICBLLZ
00CF7D  2  A5 28        		LDA ICBLHZ
00CF7F  2  E9 01        		SBC #1
00CF81  2  85 28        		STA ICBLHZ
00CF83  2               	.IF PLATFORM=0
00CF83  2  A5 29        		lda ICBLBZ
00CF85  2  E9 00        		sbc #0
00CF87  2  85 29        		sta ICBLBZ
00CF89  2               	.ENDIF
00CF89  2               
00CF89  2  18           		CLC
00CF8A  2  A5 24        		LDA ICBALZ
00CF8C  2  69 FF        		ADC #$FF
00CF8E  2  85 24        		STA ICBALZ
00CF90  2  90 06        		BCC PUTFAST3
00CF92  2  E6 25        		INC ICBAHZ
00CF94  2               	.IF PLATFORM=0
00CF94  2  D0 02        		bne PUTFAST3
00CF96  2  E6 26        		inc ICBABZ
00CF98  2               	.ENDIF
00CF98  2               
00CF98  2  4C FA D3     PUTFAST3:	JMP INCSEC
00CF9B  2               
00CF9B  2               
00CF9B  2  20 AE CF     PUTSLOW:	JSR INCFILELEN
00CF9E  2  A5 2F        PUTSLOW1:	LDA CIOCHR
00CFA0  2  A0 00        		LDY #0
00CFA2  2  91 06        		STA (FATPTRS),Y
00CFA4  2  C8           		INY
00CFA5  2  8C 3D 04     		STY DDIRTY
00CFA8  2               
00CFA8  2  20 69 D3     		JSR INCRPOS
00CFAB  2  4C EE D3     		JMP INCPTR
00CFAE  2               
00CFAE  2               
00CFAE  2  EE 83 04     INCFILELEN:	INC FILELEN
00CFB1  2  D0 0D        		BNE INCFILELEX
00CFB3  2  EE 84 04     INCFILELE2:	INC FILELEN+1
00CFB6  2  D0 08        		BNE INCFILELEX
00CFB8  2  EE 85 04     		INC FILELEN+2
00CFBB  2  D0 03        		BNE INCFILELEX
00CFBD  2  EE 86 04     		INC FILELEN+3
00CFC0  2  60           INCFILELEX:	RTS
00CFC1  2               ;
00CFC1  2               ;
00CFC1  2               ;
00CFC1  2  20 C4 CC     GETCHA:		JSR SETFCB
00CFC4  2  A6 2E        		LDX ICIDNO
00CFC6  2  BD 8A 02     		LDA ICAX1,X
00CFC9  2  29 02        		AND #2
00CFCB  2  D0 03        		BNE GETDIR	;if Bit 1 set, dir access
00CFCD  2               
00CFCD  2  4C E6 D2     GETBYTE:	JMP READBYTE
00CFD0  2               
00CFD0  2               GETDIR:		;lda #'*'
00CFD0  2               		;jsr PRINT
00CFD0  2               
00CFD0  2  AC 6A 04     		LDY HILF	;each call to GETDIR return just one byte
00CFD3  2  10 03        		BPL GETDIR6	;HILF counts the bytes in one dir entry
00CFD5  2               		;lda #'E'
00CFD5  2               		;jsr PRINT
00CFD5  2  A0 88        		LDY #EOF
00CFD7  2  60           		RTS
00CFD8  2               
00CFD8  2  D0 3F        GETDIR6:	BNE GETDIR1		; Y > 0, get next Dir
00CFDA  2               
00CFDA  2  A9 20        		LDA #32			; Y==0, init DIRLINE
00CFDC  2  8D 58 04     		STA DIRLINE+8
00CFDF  2  8D 5C 04     		STA DIRLENG-1
00CFE2  2  A9 0A        		LDA #EOL
00CFE4  2  8D 67 04     		STA DIREOF
00CFE7  2               
00CFE7  2  A2 00        		LDX #0			; copy DIR-info
00CFE9  2  B1 06        GETDIR3:	LDA (FATPTRS),Y		; from sector-buffer
00CFEB  2  9D 50 04     		STA DIRLINE,X		; into DIRLINE
00CFEE  2  E8           		INX
00CFEF  2  C8           		INY
00CFF0  2  C0 08        		CPY #8			; 8.3 jump over " "
00CFF2  2  D0 01        		BNE GETDIR3A
00CFF4  2  E8           		INX
00CFF5  2               
00CFF5  2  C0 0B        GETDIR3A:	CPY #11
00CFF7  2  D0 F0        		BNE GETDIR3
00CFF9  2               
00CFF9  2  A0 0B        		LDY #DATTRIB
00CFFB  2  B1 06        		LDA (FATPTRS),Y
00CFFD  2  A0 09        		LDY #9
00CFFF  2  29 10        		AND #16			;ist directory?
00D001  2  F0 0B        		BEQ GETDLEN		;no, get file length
00D003  2               
00D003  2  B9 3A D0     GETDTXT:	LDA DIRTXT,Y		;write "DIR" into
00D006  2  99 5D 04     		STA DIRLENG,Y		;output length
00D009  2  88           		DEY			;pos 9 downto 0
00D00A  2  10 F7        		BPL GETDTXT
00D00C  2  30 09        		BMI GETDIR5
00D00E  2               
00D00E  2  B9 31 04     GETDLEN:	LDA DECIMAL,Y
00D011  2  99 5D 04     		STA DIRLENG,Y
00D014  2  88           		DEY
00D015  2  10 F7        		BPL GETDLEN
00D017  2               
00D017  2  A0 00        GETDIR5:	LDY #0
00D019  2               
00D019  2               GETDIR1:	;lda #'1'
00D019  2               		;jsr PRINT
00D019  2               
00D019  2  EE 6A 04     		INC HILF
00D01C  2  B9 50 04     		LDA DIRLINE,Y		;if Y points to end in DIRLINE
00D01F  2  C9 0A        		CMP #EOL		;read next dir entry
00D021  2  D0 14        		BNE GETDIR7
00D023  2               
00D023  2               		;lda #'2'
00D023  2               		;jsr PRINT
00D023  2               
00D023  2  20 78 CC     		JSR NEXTFILE
00D026  2  30 09        		BMI GETDIR9
00D028  2               
00D028  2               		;lda #'D'
00D028  2               		;jsr PRINT
00D028  2               
00D028  2  A0 00        		LDY #0
00D02A  2  8C 6A 04     		STY HILF
00D02D  2               
00D02D  2  B1 06        		LDA (FATPTRS),Y
00D02F  2  D0 04        		BNE GETDIR8
00D031  2               
00D031  2               GETDIR9:	;lda #'9'
00D031  2               		;jsr PRINT
00D031  2               
00D031  2  88           		DEY
00D032  2  8C 6A 04     		STY HILF		;NEG.
00D035  2               
00D035  2  A9 0A        GETDIR8:	LDA #EOL
00D037  2               
00D037  2               GETDIR7:
00D037  2               	.IF PLATFORM > 0
00D037  2               		CMP #$7E		; "~" in "-"
00D037  2               		BNE GETDIR2
00D037  2               		LDA #'-'
00D037  2               	.ENDIF
00D037  2               GETDIR2:	;pha
00D037  2               		;lda #'#'
00D037  2               		;jsr PRINT
00D037  2               		;pla
00D037  2  A0 01        		LDY #1
00D039  2  60           		RTS
00D03A  2               
00D03A  2               ;
00D03A  2               ;	     1234567890123
00D03A  2               ;DIRLINE	.byte "             "
00D03A  2               ;DIRLENG	.byte "           "
00D03A  2               ;	.byte EOL
00D03A  2               ;		      "0123456789"
00D03A  2  20 20 20 20  DIRTXT:		.byte "       DIR"
00D03E  2  20 20 20 44  
00D042  2  49 52        
00D044  2               ;
00D044  2               NEXTDIR:	;lda #'N'
00D044  2               		;jsr PRINT
00D044  2               
00D044  2  20 70 D2     		JSR READDIR
00D047  2  B0 3E        		BCS NEXTDIR9	;No further Dir, RTS
00D049  2               
00D049  2               CHECKDIR:
00D049  2               ;		jsr NEWLINE
00D049  2               ;
00D049  2               ;		ldy #0
00D049  2               ;ch1:		lda (FATPTRS),Y
00D049  2               ;		jsr PUTHEX
00D049  2               ;		lda #' '
00D049  2               ;		jsr PRINT
00D049  2               ;		iny
00D049  2               ;		cpy #16
00D049  2               ;		bne ch1
00D049  2               ;
00D049  2               ;		lda #' '
00D049  2               ;		jsr PRINT
00D049  2               ;
00D049  2               ;		ldy #0
00D049  2               ;ch2:		lda (FATPTRS),Y
00D049  2               ;		jsr PRINT
00D049  2               ;		iny
00D049  2               ;		cpy #8
00D049  2               ;		bne ch2
00D049  2               ;		jsr NEWLINE
00D049  2               
00D049  2  A0 00        		LDY #DNAME
00D04B  2  AE AD 04     		LDX DIRFILE
00D04E  2  B1 06        		LDA (FATPTRS),Y
00D050  2               
00D050  2  C9 E5        		CMP #DEL	;ENTRY
00D052  2  D0 06        		BNE NEXTDIR2	;DELETED?
00D054  2  E0 02        		CPX #2		;AND
00D056  2  D0 EC        		BNE NEXTDIR	;DIRFILE=2
00D058  2  38           		SEC		;END C=1
00D059  2  60           		RTS
00D05A  2               
00D05A  2               NEXTDIR2:	;lda #'2'
00D05A  2               		;jsr PRINT
00D05A  2               
00D05A  2  A0 0B        		LDY #DATTRIB
00D05C  2  B1 06        		LDA (FATPTRS),Y	;SKIP
00D05E  2  29 08        		AND #8		;VOLUME
00D060  2  D0 E2        		BNE NEXTDIR	;LABEL
00D062  2               
00D062  2  B1 06        		LDA (FATPTRS),Y	;DIR?
00D064  2  29 10        		AND #16
00D066  2  E0 00        		CPX #0		;DIRFILE<>0
00D068  2  F0 0C        		BEQ NEXTDIR3	;SKIP DIRS
00D06A  2  E0 03        		CPX #3
00D06C  2  D0 05        		BNE NEXTDIR4
00D06E  2  AA           		TAX
00D06F  2  D0 05        		BNE NEXTDIR3
00D071  2  F0 D1        		BEQ NEXTDIR
00D073  2               NEXTDIR4:
00D073  2  AA           		TAX
00D074  2  D0 CE        		BNE NEXTDIR
00D076  2               
00D076  2               NEXTDIR3:
00D076  2               ;		LDY #0
00D076  2               ;ND1:		LDA (FATPTRS),Y
00D076  2               ;		JSR PRINT
00D076  2               ;		INY
00D076  2               ;		CPY #11
00D076  2               ;		BNE ND1
00D076  2               
00D076  2  A0 1F        		LDY #DLEN+3
00D078  2  A2 03        		LDX #3
00D07A  2               NEXTDIR1:
00D07A  2  B1 06        		LDA (FATPTRS),Y
00D07C  2  9D 28 04     		STA BIN,X
00D07F  2  88           		DEY
00D080  2  CA           		DEX
00D081  2  10 F7        		BPL NEXTDIR1
00D083  2               
00D083  2  20 8F D3     		JSR BIN2DEC
00D086  2               ;		lda #'B'
00D086  2               ;		jsr PRINT
00D086  2  18           		CLC
00D087  2  60           NEXTDIR9:	RTS
00D088  2               
00D088  2  4C 45 D2     STATUSCHA:	JMP OK
00D08B  2               
00D08B  2  A5 22        SPECIAL:	LDA ICCOMZ
00D08D  2  A2 04        		LDX #(XFUNCEND-XFUNC)
00D08F  2  DD B6 D0     SPECIAL2:	CMP XFUNC,X
00D092  2  F0 06        		BEQ SPECIAL1
00D094  2  CA           		DEX
00D095  2  10 F8        		BPL SPECIAL2
00D097  2  A0 84        		LDY #132
00D099  2  60           		RTS
00D09A  2               
00D09A  2  8A           SPECIAL1:	TXA
00D09B  2  0A           		ASL			;* 2
00D09C  2  8D 6A 04     		STA HILF		;store found X-pos
00D09F  2               
00D09F  2  A5 22        		LDA ICCOMZ
00D0A1  2  C9 28        		CMP #CFSTAT		;no OPENFCB for FSTAT
00D0A3  2  F0 05        		BEQ SPECIAL3
00D0A5  2               
00D0A5  2  20 03 CD     		JSR OPENFCB
00D0A8  2  30 0B        		BMI SPECIAL9		;no free FCB
00D0AA  2               SPECIAL3:
00D0AA  2               ;		LDA #$FF
00D0AA  2               ;		STA FBURST
00D0AA  2  AE 6A 04     		LDX HILF		;reload X-pos
00D0AD  2  BD BC D0     		LDA XJMPTAB+1,X		;jump to special-function
00D0B0  2  48           		PHA
00D0B1  2  BD BB D0     		LDA XJMPTAB,X
00D0B4  2  48           		PHA
00D0B5  2               SPECIAL9:
00D0B5  2  60           		RTS
00D0B6  2               
00D0B6  2  21           XFUNC:		.byte CDELETE
00D0B7  2  29           		.byte CCHADIR
00D0B8  2  20           		.byte CRENAME
00D0B9  2  28           		.byte CFSTAT
00D0BA  2  22           XFUNCEND:	.byte CCREDIR
00D0BB  2               
00D0BB  2               
00D0BB  2  0D D2        XJMPTAB:	.word DELETE-1
00D0BD  2  A9 D1        		.word CHADIR-1
00D0BF  2  D4 D0        		.word RENAME-1
00D0C1  2  C4 D0        		.word FSTAT-1
00D0C3  2  25 D1        		.word CREDIR-1
00D0C5  2               ;
00D0C5  2               ;
00D0C5  2               ;
00D0C5  2               
00D0C5  2               ;
00D0C5  2               ;
00D0C5  2               ;
00D0C5  2               FSTAT:		;JSR SETFCB
00D0C5  2               ;		BPL FSTAT2
00D0C5  2               ;		RTS
00D0C5  2               
00D0C5  2  A0 05        FSTAT2:		LDY #5
00D0C7  2  A2 03        		LDX #3
00D0C9  2  BD 83 04     FSTAT1:		LDA FILELEN,X
00D0CC  2  97 24        		sta_icbalz_y
00D0CE  2  88           		DEY
00D0CF  2  CA           		DEX
00D0D0  2  10 F7        		BPL FSTAT1
00D0D2  2  4C 45 D2     		JMP OK
00D0D5  2               
00D0D5  2  A0 00        RENAME:		LDY #0
00D0D7  2  B7 24        RENAME2:	lda_icbalz_y
00D0D9  2               ;		LDA (ICBALZ),Y
00D0D9  2  C9 2C        		CMP #','
00D0DB  2  F0 0A        		BEQ RENAME1	;FOUND
00D0DD  2  C9 0A        		CMP #EOL
00D0DF  2  F0 03        		BEQ RENAME8
00D0E1  2  C8           		INY
00D0E2  2  D0 F3        		BNE RENAME2
00D0E4  2  4C 56 CC     RENAME8:	JMP ERR165
00D0E7  2               
00D0E7  2  C8           RENAME1:	INY
00D0E8  2  20 63 CE     		JSR STR2RAW
00D0EB  2  EE 69 04     		INC VALIDS
00D0EE  2  20 21 CD     		JSR VALIDNAM
00D0F1  2  08           		PHP
00D0F2  2  CE 69 04     		DEC VALIDS
00D0F5  2  28           		PLP
00D0F6  2  10 03        		BPL RENAME4
00D0F8  2  4C 56 CC     		JMP ERR165
00D0FB  2               
00D0FB  2  A2 0A        RENAME4:	LDX #10
00D0FD  2  BD 9C 04     RENAME3:	LDA DIRTEXT,X
00D100  2  9D 43 04     		STA DIRRENA,X
00D103  2  CA           		DEX
00D104  2  10 F7        		BPL RENAME3
00D106  2               
00D106  2  A9 01        		LDA #1
00D108  2  20 5C CC     		JSR GETFILE
00D10B  2  30 16        		BMI RENAME9
00D10D  2               
00D10D  2  A0 0A        RENAME7:	LDY #10
00D10F  2  B9 43 04     RENAME6:	LDA DIRRENA,Y
00D112  2  C9 3F        		CMP #'?'
00D114  2  F0 05        		BEQ RENAME5
00D116  2               
00D116  2               ;		TAX
00D116  2               ;		LDA (FATPTRS),Y
00D116  2               ;		JSR PRINT
00D116  2               ;		TXA
00D116  2               
00D116  2  91 06        		STA (FATPTRS),Y
00D118  2  8D 3D 04     		STA DDIRTY
00D11B  2  88           RENAME5:	DEY
00D11C  2  10 F1        		BPL RENAME6
00D11E  2               
00D11E  2  20 78 CC     		JSR NEXTFILE
00D121  2  10 EA        		BPL RENAME7
00D123  2               
00D123  2  4C 3F D2     RENAME9:	JMP DELETE8
00D126  2               ;
00D126  2               ;
00D126  2               ;
00D126  2  A9 03        CREDIR:		LDA #3
00D128  2  20 5C CC     		JSR GETFILE
00D12B  2  30 03        		BMI CREDIR1
00D12D  2  4C D7 CD     		JMP OPEN170
00D130  2               
00D130  2  20 21 CD     CREDIR1:	JSR VALIDNAM
00D133  2  10 03        		BPL CREDIR3
00D135  2  4C 56 CC     		JMP ERR165
00D138  2               
00D138  2  A9 08        CREDIR3:	LDA #8
00D13A  2  85 2A        		STA ICAX1Z
00D13C  2  20 67 CD     		JSR INITDIR
00D13F  2               
00D13F  2  A0 0B        		LDY #DATTRIB
00D141  2  A9 10        		LDA #16		;ATTR-DIR
00D143  2  91 06        		STA (FATPTRS),Y
00D145  2               
00D145  2  A9 00        		LDA #0
00D147  2  8D 95 04     		STA FCURSEC
00D14A  2  20 89 D7     		JSR CLU2SEC
00D14D  2               
00D14D  2  20 EE D8     CREDIR2:	JSR READSEC
00D150  2  20 65 D4     		JSR CLEARBUF
00D153  2               
00D153  2  AD 95 04     		LDA FCURSEC
00D156  2  D0 38        		BNE CREDIR5
00D158  2               
00D158  2  A2 0A        		LDX #10
00D15A  2  A9 20        		LDA #32
00D15C  2  9D 00 06     CREDIR6:	STA BUFFER,X
00D15F  2  9D 20 06     		STA BUFFER+32,X
00D162  2  CA           		DEX
00D163  2  10 F7        		BPL CREDIR6
00D165  2               
00D165  2  A9 2E        		LDA #'.'
00D167  2  8D 00 06     		STA BUFFER
00D16A  2  8D 20 06     		STA BUFFER+32
00D16D  2  8D 21 06     		STA BUFFER+33
00D170  2               
00D170  2  A9 10        		LDA #16
00D172  2  8D 0B 06     		STA BUFFER+DATTRIB
00D175  2  8D 2B 06     		STA BUFFER+DATTRIB+32
00D178  2               
00D178  2  AD 91 04     		LDA FCURCLUS
00D17B  2  8D 1A 06     		STA BUFFER+DCLUS
00D17E  2  AD 92 04     		LDA FCURCLUS+1
00D181  2  8D 1B 06     		STA BUFFER+DCLUS+1
00D184  2               
00D184  2  AD 41 04     		LDA DIRCLUS
00D187  2  8D 3A 06     		STA BUFFER+DCLUS+32
00D18A  2  AD 42 04     		LDA DIRCLUS+1
00D18D  2  8D 3B 06     		STA BUFFER+DCLUS+33
00D190  2               
00D190  2  EE 95 04     CREDIR5:	INC FCURSEC
00D193  2  AD 95 04     		LDA FCURSEC
00D196  2  CD 00 04     		CMP SECCLUS
00D199  2  F0 06        		BEQ CREDIR4
00D19B  2               
00D19B  2  20 7C D3     		JSR INCSECTO
00D19E  2  4C 4D D1     		JMP CREDIR2
00D1A1  2               
00D1A1  2  20 D4 D8     CREDIR4:	JSR WRITESEC
00D1A4  2  20 84 D8     		JSR WRITEFAT
00D1A7  2  4C 3F D2     		JMP DELETE8
00D1AA  2               ;
00D1AA  2               ;
00D1AA  2               ;
00D1AA  2  20 49 CC     CHADIR:		JSR CHECKHAN
00D1AD  2  10 01        		BPL CHADIR2
00D1AF  2  60           		RTS
00D1B0  2               
00D1B0  2  AD 41 04     CHADIR2:	LDA DIRCLUS		;push DIRCLUS to stack
00D1B3  2  48           		PHA
00D1B4  2  AD 42 04     		LDA DIRCLUS+1
00D1B7  2  48           		PHA
00D1B8  2  C8           		INY
00D1B9  2  B7 24        		lda_icbalz_y		;is '/' access from ROOT?
00D1BB  2               ;		LDA (ICBALZ),Y
00D1BB  2  C9 2F        		CMP #'/'
00D1BD  2  D0 0B        		BNE CHADIR3		;no
00D1BF  2               
00D1BF  2  A9 00        		LDA #0			;set DIRCLUS to 0
00D1C1  2  8D 41 04     		STA DIRCLUS
00D1C4  2  8D 42 04     		STA DIRCLUS+1
00D1C7  2  C8           		INY			;yes
00D1C8  2  B7 24        		lda_icbalz_y		;get next char
00D1CA  2               ;		LDA (ICBALZ),Y
00D1CA  2               
00D1CA  2  C9 0A        CHADIR3:	CMP #EOL		;end of filename?
00D1CC  2  D0 05        		BNE CHADIR3C		;no
00D1CE  2  68           		PLA			;otherwise pop DIRCLUS from stack
00D1CF  2  68           		PLA			;and exit
00D1D0  2  4C 42 D2     CHADIREND:	JMP DELETE9		;EXIT
00D1D3  2               
00D1D3  2  A9 03        CHADIR3C:	LDA #3			;read only dirs
00D1D5  2  20 39 CC     		JSR DIRSTART		;copy DIRCLUS to FSTRTCL
00D1D8  2  20 63 CE     		JSR STR2RAW
00D1DB  2  88           		DEY
00D1DC  2  8C 68 04     		STY SAVEY
00D1DF  2               
00D1DF  2  20 49 D2     		JSR OPENDIR
00D1E2  2  90 0B        		BCC CHADIR3A
00D1E4  2  68           CHADIR3B:	PLA
00D1E5  2  8D 42 04     		STA DIRCLUS+1
00D1E8  2  68           		PLA
00D1E9  2  8D 41 04     		STA DIRCLUS
00D1EC  2  4C D7 CD     		JMP OPEN170
00D1EF  2  20 6B CC     CHADIR3A:	JSR FINDFIL1
00D1F2  2  30 F0        		BMI CHADIR3B
00D1F4  2               
00D1F4  2  A0 1A        CHADIR1:	LDY #DCLUS
00D1F6  2  B1 06        		LDA (FATPTRS),Y
00D1F8  2               ;		JSR PUTHEX
00D1F8  2  8D 41 04     		STA DIRCLUS
00D1FB  2  C8           		INY
00D1FC  2  B1 06        		LDA (FATPTRS),Y
00D1FE  2               ;		JSR PUTHEX
00D1FE  2  8D 42 04     		STA DIRCLUS+1
00D201  2               ;		JSR KBGETC
00D201  2               
00D201  2  AC 68 04     CHADIR4:	LDY SAVEY
00D204  2  B7 24        CHADIR5:	lda_icbalz_y
00D206  2               ;		LDA (ICBALZ),Y
00D206  2  C9 2F        		CMP #'/'
00D208  2  D0 C0        		BNE CHADIR3
00D20A  2  C8           		INY
00D20B  2  4C 04 D2     		JMP CHADIR5
00D20E  2               ;
00D20E  2               ;
00D20E  2               ;
00D20E  2  A9 00        DELETE:		LDA #0
00D210  2  20 5C CC     		JSR GETFILE
00D213  2  30 2D        		BMI DELETE9
00D215  2               
00D215  2  A5 06        DELETE2:	LDA FATPTRS
00D217  2  48           		PHA
00D218  2  A5 07        		LDA FATPTRS+1
00D21A  2  48           		PHA
00D21B  2               
00D21B  2  A0 1A        		LDY #DCLUS
00D21D  2  B1 06        		LDA (FATPTRS),Y
00D21F  2  AA           		TAX
00D220  2  C8           		INY
00D221  2  B1 06        		LDA (FATPTRS),Y
00D223  2               
00D223  2  A0 00        		LDY #0
00D225  2  20 2D CE     		JSR DELCLUS
00D228  2               
00D228  2  68           		PLA
00D229  2  85 07        		STA FATPTRS+1
00D22B  2  68           		PLA
00D22C  2  85 06        		STA FATPTRS
00D22E  2               
00D22E  2  A0 00        		LDY #DNAME
00D230  2  A9 E5        		LDA #$E5
00D232  2  91 06        		STA (FATPTRS),Y
00D234  2  8D 3D 04     		STA DDIRTY
00D237  2               
00D237  2  20 78 CC     		JSR NEXTFILE
00D23A  2  10 D9        		BPL DELETE2
00D23C  2               
00D23C  2  20 84 D8     		JSR WRITEFAT
00D23F  2  20 D4 D8     DELETE8:	JSR WRITESEC
00D242  2               
00D242  2  20 B8 CC     DELETE9:	JSR CLOSEFCB
00D245  2               ;		JMP OK
00D245  2               
00D245  2  A0 01        OK:		LDY #1
00D247  2  18           		CLC
00D248  2  60           NOTOK:		RTS
00D249  2               
00D249  2               ;IODUMP:		LDX ICIDNO
00D249  2               ;		LDY #0
00D249  2               ;IODUMP1:	LDA IOCB,X
00D249  2               ;		JSR PUTHEX
00D249  2               ;		INX
00D249  2               ;		INY
00D249  2               ;		CPY #16
00D249  2               ;		BNE IODUMP1
00D249  2               ;		LDA #$9B
00D249  2               ;		JSR PRINT
00D249  2               ;		LDY #EOF
00D249  2               ;		RTS
00D249  2               
00D249  2               ;
00D249  2               ;
00D249  2               ;
00D249  2  AD 81 04     OPENDIR:	LDA FSTRTCL
00D24C  2  8D 91 04     		STA FCURCLUS
00D24F  2  0D 82 04     		ORA FSTRTCL+1
00D252  2  D0 06        		BNE OPENDIR1
00D254  2               
00D254  2  20 AA D2     		JSR CROOT
00D257  2  4C 49 D0     		JMP CHECKDIR
00D25A  2               
00D25A  2  AD 82 04     OPENDIR1:	LDA FSTRTCL+1
00D25D  2  8D 92 04     		STA FCURCLUS+1
00D260  2  A9 00        		LDA #0
00D262  2  A2 03        		LDX #3
00D264  2  9D 8D 04     OPENDIR2:	STA FVAR32,X
00D267  2  CA           		DEX
00D268  2  10 FA        		BPL OPENDIR2
00D26A  2               
00D26A  2               ;		LDA FSTRTCL
00D26A  2               ;		JSR PUTHEX
00D26A  2               ;		LDA FSTRTCL+1
00D26A  2               ;		JSR PUTHEX
00D26A  2               ;		JSR KBGETC
00D26A  2               
00D26A  2  20 AD D4     		JSR FSEEK1
00D26D  2  4C 49 D0     		JMP CHECKDIR
00D270  2               ;
00D270  2               ;
00D270  2               ;
00D270  2               READDIR:	;lda FATPTRS+1
00D270  2               		;jsr PUTHEX
00D270  2               		;lda FATPTRS
00D270  2               		;jsr PUTHEX
00D270  2               		;lda #' '
00D270  2               		;jsr PRINT
00D270  2               
00D270  2  A0 00        		LDY #DNAME
00D272  2  B1 06        		LDA (FATPTRS),Y
00D274  2  F0 32        		BEQ READDIR9
00D276  2               
00D276  2  18           CDIR3:		CLC
00D277  2  A5 06        		LDA FATPTRS
00D279  2  69 20        		ADC #32
00D27B  2  85 06        		STA FATPTRS
00D27D  2  A5 07        		LDA FATPTRS+1
00D27F  2  69 00        		ADC #0
00D281  2  85 07        		STA FATPTRS+1
00D283  2  C9 08        		CMP #(>BUFFER)+2
00D285  2  D0 1F        		BNE READDIR8		;OK => CLC,RTS
00D287  2               
00D287  2  AD 81 04     		LDA FSTRTCL
00D28A  2  0D 82 04     		ORA FSTRTCL+1
00D28D  2  F0 11        		BEQ CDIR4
00D28F  2               
00D28F  2  20 FA D3     		JSR INCSEC
00D292  2               
00D292  2               ;		LDA #'I
00D292  2               ;		JSR PRINT
00D292  2               ;		LDA FCURCLUS
00D292  2               ;		JSR PUTHEX
00D292  2               ;		LDA FCURCLUS+1
00D292  2               ;		JSR PUTHEX
00D292  2               
00D292  2  A9 FF        		LDA #$FF
00D294  2  CD 92 04     		CMP FCURCLUS+1
00D297  2  D0 0D        		BNE READDIR8
00D299  2  CD 91 04     		CMP FCURCLUS
00D29C  2  D0 08        		BNE READDIR8
00D29E  2  F0 08        		BEQ READDIR9
00D2A0  2               
00D2A0  2  20 7C D3     CDIR4:		JSR INCSECTO
00D2A3  2  20 BC D2     		JSR CROOT2
00D2A6  2  18           READDIR8:	CLC
00D2A7  2  60           		RTS
00D2A8  2  38           READDIR9:	SEC
00D2A9  2  60           		RTS
00D2AA  2               ;
00D2AA  2               ;
00D2AA  2               ;
00D2AA  2  A2 03        CROOT:		LDX #3
00D2AC  2  BD 14 04     CROOT1:		LDA DIRBASE,X
00D2AF  2  9D 0C 04     		STA SECTOR,X
00D2B2  2  CA           		DEX
00D2B3  2  10 F7        		BPL CROOT1
00D2B5  2  E8           		INX
00D2B6  2  8E 81 04     		STX FSTRTCL
00D2B9  2  8E 82 04     		STX FSTRTCL+1
00D2BC  2  A9 00        CROOT2:		LDA #<BUFFER
00D2BE  2  85 06        		STA FATPTRS
00D2C0  2  A9 06        		LDA #>BUFFER
00D2C2  2  85 07        		STA FATPTRS+1
00D2C4  2  4C EE D8     		JMP READSEC
00D2C7  2               
00D2C7  2               CHECKLEN:
00D2C7  2               ;		LDX #3
00D2C7  2               ;CL1:		LDA FRPOS,X
00D2C7  2               ;		JSR PUTHEX
00D2C7  2               ;		DEX
00D2C7  2               ;		BPL CL1
00D2C7  2               ;		LDA #EOL
00D2C7  2               ;		JSR PRINT
00D2C7  2               
00D2C7  2  A2 03        		LDX #3
00D2C9  2  BD 89 04     CHECKL2:	LDA FRPOS,X
00D2CC  2  DD 83 04     		CMP FILELEN,X
00D2CF  2  90 03        		BCC CHECKL1
00D2D1  2  CA           		DEX
00D2D2  2  10 F5        		BPL CHECKL2
00D2D4  2               CHECKL1:
00D2D4  2  60           		RTS
00D2D5  2               ;
00D2D5  2               ;
00D2D5  2               ;
00D2D5  2               READSLOW:
00D2D5  2               ;		BIT FBURST	;burst off?
00D2D5  2               ;		BMI READSLO1	;yes
00D2D5  2               ;		DEC FBURST	;turn it off
00D2D5  2               
00D2D5  2               ;		JSR READSEC	;read sector
00D2D5  2               
00D2D5  2               READSLO1:
00D2D5  2               ;		LDA FATPTRS
00D2D5  2               ;		JSR PUTHEX
00D2D5  2               ;		LDA FATPTRS+1
00D2D5  2               ;		JSR PUTHEX
00D2D5  2  A0 00        		LDY #0
00D2D7  2  B1 06        		LDA (FATPTRS),Y
00D2D9  2  85 2F        		STA CIOCHR
00D2DB  2               
00D2DB  2  20 69 D3     		JSR INCRPOS
00D2DE  2  20 EE D3     		JSR INCPTR
00D2E1  2               
00D2E1  2               READBYT4:
00D2E1  2               ;		JSR CHECKLEN
00D2E1  2  A5 2F        		LDA CIOCHR
00D2E3  2               ;		BCS READBYT3
00D2E3  2  A0 01        READBYT5:	LDY #1
00D2E5  2  60           		RTS
00D2E6  2               ;READBYT3:	LDY #3
00D2E6  2               ;		RTS
00D2E6  2               
00D2E6  2  20 C7 D2     READBYTE:	JSR CHECKLEN
00D2E9  2  90 03        		BCC READBYT1
00D2EB  2               ;		LDX ICIDNO
00D2EB  2               ;		LDA FRPOS
00D2EB  2               ;		JSR PUTHEX
00D2EB  2               ;		STA ICBLLZ
00D2EB  2               ;		STA ICBLL,X
00D2EB  2               ;		LDA FRPOS+1
00D2EB  2               ;		JSR PUTHEX
00D2EB  2               ;		STA ICBLHZ
00D2EB  2               ;		STA ICBLH,X
00D2EB  2               
00D2EB  2  A0 88        		LDY #EOF
00D2ED  2  60           		RTS
00D2EE  2               
00D2EE  2  A4 06        READBYT1:	LDY FATPTRS	;FATPTRS must point to begin of buffer, check LO-byte=0
00D2F0  2  D0 E3        		BNE READSLOW
00D2F2  2               ;		TAY		;Y=0
00D2F2  2  A5 28        		LDA ICBLHZ	;still >= 512 bytes to be read?
00D2F4  2  C9 02        		CMP #2
00D2F6  2  90 DD        		BCC READSLOW
00D2F8  2  A5 22        		LDA ICCOMZ	;only GETCHAR allowed
00D2FA  2  C9 07        		CMP #GETCHR
00D2FC  2  D0 D7        		BNE READSLOW
00D2FE  2  A5 07        		LDA FATPTRS+1
00D300  2  C9 06        		CMP #>BUFFER	;FATPTRS must point to begin of buffer
00D302  2  D0 D1        		BNE READSLOW
00D304  2               
00D304  2               ;		SEC		;still more than 512 bytes in the files available?
00D304  2  AD 83 04     		LDA FILELEN	;filelen can't be greater then 64k
00D307  2  ED 89 04     		SBC FRPOS
00D30A  2  AD 84 04     		LDA FILELEN+1
00D30D  2  ED 8A 04     		SBC FRPOS+1
00D310  2  C9 02        		CMP #2
00D312  2  90 C1        		BCC READSLOW
00D314  2               
00D314  2               ;		JSR IODUMP
00D314  2               
00D314  2               READFAST:
00D314  2               ;		BIT FBURST	;Burst OFF?
00D314  2               ;		BMI READFA2	;yes
00D314  2               
00D314  2               ;		STY FBURST	;Y=0
00D314  2               
00D314  2               ;		JSR INITLSEC
00D314  2               
00D314  2               ;		LDA ICBALZ
00D314  2               ;		STA BUFADRL
00D314  2               ;		LDA ICBAHZ
00D314  2               ;		STA BUFADRH
00D314  2               ;		JSR READSECF
00D314  2               ;		LDA #<BUFFER
00D314  2               ;		STA BUFADRL
00D314  2               ;		LDA #>BUFFER
00D314  2               ;		STA BUFADRH
00D314  2               
00D314  2               ;		INC ICBAHZ
00D314  2               ;		LDY #$FF
00D314  2               ;		LDA (ICBALZ),Y
00D314  2               ;		JMP READFA3
00D314  2               
00D314  2  B9 00 06     READFA2:	LDA BUFFER,Y
00D317  2  97 24        		sta_icbalz_y
00D319  2               ;		STA (ICBALZ),Y
00D319  2  88           		DEY
00D31A  2  D0 F8        		BNE READFA2
00D31C  2  E6 25        		INC ICBAHZ
00D31E  2               	.IF PLATFORM=0
00D31E  2  D0 02        		bne READFA1
00D320  2  E6 26        		inc ICBABZ
00D322  2               	.ENDIF
00D322  2  B9 00 07     READFA1:	LDA BUFFER+$100,Y
00D325  2  97 24        		sta_icbalz_y
00D327  2               ;		STA (ICBALZ),Y
00D327  2  C8           		INY
00D328  2  D0 F8        		BNE READFA1
00D32A  2               
00D32A  2  85 2F        READFA3:	STA CIOCHR
00D32C  2  E6 25        		INC ICBAHZ
00D32E  2               	.IF PLATFORM=0
00D32E  2  D0 02        		bne READFA3A
00D330  2  E6 26        		inc ICBABZ
00D332  2               	.ENDIF
00D332  2               
00D332  2               READFA3A:
00D332  2               	.IF PLATFORM=0
00D332  2  A5 28        		lda ICBLHZ
00D334  2  D0 02        		bne READFA3B
00D336  2  C6 29        		dec ICBLBZ
00D338  2  C6 28        READFA3B:	dec ICBLHZ
00D33A  2  D0 02        		bne READFA3C
00D33C  2  C6 29        		dec ICBLBZ
00D33E  2  C6 28        READFA3C:	dec ICBLHZ
00D340  2               	.ELSE
00D340  2               		DEC ICBLHZ
00D340  2               		DEC ICBLHZ
00D340  2               	.ENDIF
00D340  2  20 6E D3     		JSR INCRPOS2
00D343  2  20 6E D3     		JSR INCRPOS2
00D346  2               
00D346  2  20 FA D3     		JSR INCSEC
00D349  2               
00D349  2  A5 28        		LDA ICBLHZ
00D34B  2  05 27        		ORA ICBLLZ
00D34D  2               	.IF PLATFORM=0
00D34D  2  05 29        		ora ICBLBZ
00D34F  2               	.ENDIF
00D34F  2  F0 03        		BEQ READFA4
00D351  2  4C E6 D2     		JMP READBYTE
00D354  2               
00D354  2  E6 27        READFA4:	INC ICBLLZ	;set buffer length to 1
00D356  2               
00D356  2  A5 24        		LDA ICBALZ	;decrement buffer address
00D358  2  D0 08        		BNE READFA5
00D35A  2               
00D35A  2               	.IF PLATFORM=0
00D35A  2  A5 25        		lda ICBAHZ
00D35C  2  D0 02        		bne READFA6
00D35E  2  C6 26        		dec ICBABZ
00D360  2               	.ENDIF
00D360  2               
00D360  2  C6 25        READFA6:	DEC ICBAHZ
00D362  2  C6 24        READFA5:	DEC ICBALZ
00D364  2  A5 2F        		LDA CIOCHR
00D366  2  4C E3 D2     		JMP READBYT5	;exit success, Y=1
00D369  2               
00D369  2               
00D369  2  EE 89 04     INCRPOS:	INC FRPOS
00D36C  2  D0 0D        		BNE INCRPOS1
00D36E  2  EE 8A 04     INCRPOS2:	INC FRPOS+1
00D371  2  D0 08        		BNE INCRPOS1
00D373  2  EE 8B 04     		INC FRPOS+2
00D376  2  D0 03        		BNE INCRPOS1
00D378  2  EE 8C 04     		INC FRPOS+3
00D37B  2  60           INCRPOS1:	RTS
00D37C  2               
00D37C  2               
00D37C  2  EE 0C 04     INCSECTO:	INC SECTOR
00D37F  2  D0 0D        		BNE INCSECT1
00D381  2  EE 0D 04     		INC SECTOR+1
00D384  2  D0 08        		BNE INCSECT1
00D386  2  EE 0E 04     		INC SECTOR+2
00D389  2  D0 03        		BNE INCSECT1
00D38B  2  EE 0F 04     		INC SECTOR+3
00D38E  2  60           INCSECT1:	RTS
00D38F  2               ;
00D38F  2               ; convert 32 bit number to 10-byte text
00D38F  2               ;
00D38F  2  A9 00        BIN2DEC:	LDA #0			;clear 5-byte BCD (=10 nibbles)
00D391  2  A2 04        		LDX #4
00D393  2  9D 2C 04     BIN2DEC1:	STA BCD,X
00D396  2  CA           		DEX
00D397  2  10 FA        		BPL BIN2DEC1
00D399  2               
00D399  2  A2 20        		LDX #32
00D39B  2  F8           		SED
00D39C  2               BIN2DEC2:
00D39C  2  0E 28 04     		ASL BIN
00D39F  2  2E 29 04     		ROL BIN+1
00D3A2  2  2E 2A 04     		ROL BIN+2
00D3A5  2  2E 2B 04     		ROL BIN+3
00D3A8  2               
00D3A8  2  A0 05        		LDY #5
00D3AA  2               BIN2DEC3:
00D3AA  2  B9 2B 04     		LDA BCD-1,Y
00D3AD  2  79 2B 04     		ADC BCD-1,Y
00D3B0  2  99 2B 04     		STA BCD-1,Y
00D3B3  2  88           		DEY
00D3B4  2  D0 F4        		BNE BIN2DEC3
00D3B6  2  CA           		DEX
00D3B7  2  D0 E3        		BNE BIN2DEC2
00D3B9  2               
00D3B9  2  D8           		CLD
00D3BA  2  8C 4E 04     		STY NODISPL		;Y = 0
00D3BD  2               BIN2DEC4:
00D3BD  2  BD 2C 04     		LDA BCD,X
00D3C0  2  4A           		LSR
00D3C1  2  4A           		LSR
00D3C2  2  4A           		LSR
00D3C3  2  4A           		LSR
00D3C4  2  20 D5 D3     		JSR BIN2INC
00D3C7  2  BD 2C 04     		LDA BCD,X
00D3CA  2  29 0F        		AND #15
00D3CC  2  20 D5 D3     		JSR BIN2INC
00D3CF  2  E8           		INX
00D3D0  2  E0 05        		CPX #5
00D3D2  2  D0 E9        		BNE BIN2DEC4
00D3D4  2  60           		RTS
00D3D5  2               
00D3D5  2  D0 0D        BIN2INC:	BNE BIN2INC1		; no '0' => print it?
00D3D7  2  2C 4E 04     		BIT NODISPL		; print if nodisplay negativ
00D3DA  2  30 0B        		BMI BIN2INC2
00D3DC  2  C0 09        		CPY #9			; print last digit in any case
00D3DE  2  F0 07        		BEQ BIN2INC2
00D3E0  2  A9 20        		LDA #32			; else print space
00D3E2  2  D0 05        		BNE BIN2INC3
00D3E4  2               
00D3E4  2  CE 4E 04     BIN2INC1:	DEC NODISPL
00D3E7  2  49 30        BIN2INC2:	EOR #'0'
00D3E9  2  99 31 04     BIN2INC3:	STA DECIMAL,Y
00D3EC  2  C8           		INY
00D3ED  2  60           		RTS
00D3EE  2               
00D3EE  2               
00D3EE  2               
00D3EE  2  E6 06        INCPTR:		INC FATPTRS
00D3F0  2  D0 72        		BNE INCPTR9
00D3F2  2  E6 07        		INC FATPTRS+1
00D3F4  2  A5 07        		LDA FATPTRS+1
00D3F6  2  C9 08        		CMP #(>BUFFER)+2
00D3F8  2  D0 6A        		BNE INCPTR9
00D3FA  2               ;
00D3FA  2               ; READ NEXT SECTOR
00D3FA  2               ;
00D3FA  2  EE 95 04     INCSEC:		INC FCURSEC
00D3FD  2  AD 95 04     		LDA FCURSEC
00D400  2  CD 00 04     		CMP SECCLUS
00D403  2  F0 06        		BEQ INCSEC3	;new cluster necessary!
00D405  2               
00D405  2  20 7C D3     		JSR INCSECTO	;just increment sector
00D408  2  4C 57 D4     		JMP INCPTR8	;reset buffer-ptr and read-sector
00D40B  2               
00D40B  2               ;
00D40B  2               ; READ NEXT CLUSTER
00D40B  2               ;
00D40B  2  A9 00        INCSEC3:	LDA #0
00D40D  2  8D 95 04     		STA FCURSEC
00D410  2               
00D410  2  AE 91 04     		LDX FCURCLUS
00D413  2  AD 92 04     		LDA FCURCLUS+1
00D416  2  20 0F D8     		JSR GETCLUST
00D419  2               
00D419  2  C9 FF        		CMP #$FF
00D41B  2  D0 31        		BNE INCSEC4
00D41D  2  E0 FF        		CPX #$FF
00D41F  2  D0 2D        		BNE INCSEC4
00D421  2               
00D421  2  A8           		TAY
00D422  2  A5 2A        		LDA ICAX1Z	;READ ACCESS
00D424  2  29 08        		AND #8
00D426  2  F0 36        		BEQ INCPTR10	;YES, do not acquire new cluster
00D428  2               
00D428  2               ;		LDA ICAX1Z
00D428  2               ;		AND #4		;UPDATE?
00D428  2               ;		BNE INCPTR10
00D428  2               
00D428  2  20 75 D4     		JSR CHAINCLU	;ONLY VALID
00D42B  2               
00D42B  2  AD AD 04     		LDA DIRFILE	;IF
00D42E  2  C9 02        		CMP #2		;GET FREE
00D430  2  D0 22        		BNE INCSEC5	;DIR
00D432  2               
00D432  2  20 89 D7     		JSR CLU2SEC
00D435  2               
00D435  2  AD 00 04     		LDA SECCLUS
00D438  2  8D 95 04     		STA FCURSEC
00D43B  2               
00D43B  2  20 EE D8     INCSEC2:	JSR READSEC
00D43E  2  20 65 D4     		JSR CLEARBUF
00D441  2  20 D4 D8     		JSR WRITESEC
00D444  2               
00D444  2  20 7C D3     		JSR INCSECTO
00D447  2               
00D447  2  CE 95 04     		DEC FCURSEC
00D44A  2  D0 EF        		BNE INCSEC2
00D44C  2  F0 06        		BEQ INCSEC5
00D44E  2               ;
00D44E  2  8E 91 04     INCSEC4:	STX FCURCLUS
00D451  2  8D 92 04     		STA FCURCLUS+1
00D454  2               
00D454  2  20 89 D7     INCSEC5:	JSR CLU2SEC
00D457  2               
00D457  2               ;		BIT FBURST	;burst active?
00D457  2               ;		BPL INCPTR9	;yes ->
00D457  2               
00D457  2  A9 06        INCPTR8:	LDA #>BUFFER
00D459  2  85 07        		STA FATPTRS+1
00D45B  2               
00D45B  2  4C EE D8     		JMP READSEC
00D45E  2               
00D45E  2               INCPTR10:
00D45E  2  8E 91 04     		STX FCURCLUS
00D461  2  8C 92 04     		STY FCURCLUS+1
00D464  2  60           INCPTR9:	RTS
00D465  2               ;
00D465  2               ;
00D465  2               ;
00D465  2  A9 00        CLEARBUF:	LDA #0
00D467  2  AA           		TAX
00D468  2  9D 00 06     CLEARBU1:	STA BUFFER,X
00D46B  2  9D 00 07     		STA BUFFER+$100,X
00D46E  2  E8           		INX
00D46F  2  D0 F7        		BNE CLEARBU1
00D471  2  EE 3D 04     		INC DDIRTY
00D474  2  60           		RTS
00D475  2               ;
00D475  2               ; GET FREE CLUSTER
00D475  2               ; INIT TO $FFFF
00D475  2               ; CHAIN WITH CURCLUS
00D475  2               ;
00D475  2  AE 91 04     CHAINCLU:	LDX FCURCLUS
00D478  2  AD 92 04     		LDA FCURCLUS+1
00D47B  2  20 61 D5     		JSR GETFCLUS
00D47E  2               
00D47E  2  20 FF D7     		JSR GETNEXTC
00D481  2               
00D481  2  8C 3E 04     		STY FDIRTY	;Y IS ODD
00D484  2  AD 3C 04     		LDA NEWCLUS+1
00D487  2  8D 92 04     		STA FCURCLUS+1
00D48A  2  91 06        		STA (FATPTRS),Y
00D48C  2  88           		DEY
00D48D  2  AD 3B 04     		LDA NEWCLUS
00D490  2  8D 91 04     		STA FCURCLUS
00D493  2  91 06        		STA (FATPTRS),Y
00D495  2  60           		RTS
00D496  2               ;
00D496  2               ;
00D496  2               ;
00D496  2  AD 81 04     FSEEK:		LDA FSTRTCL
00D499  2  8D 91 04     		STA FCURCLUS
00D49C  2  AD 82 04     		LDA FSTRTCL+1
00D49F  2  8D 92 04     		STA FCURCLUS+1
00D4A2  2               
00D4A2  2  A2 03        		LDX #3
00D4A4  2  BD 89 04     FSEEK2:		LDA FRPOS,X
00D4A7  2  9D 8D 04     		STA FVAR32,X
00D4AA  2  CA           		DEX
00D4AB  2  10 F7        		BPL FSEEK2
00D4AD  2               
00D4AD  2  A9 8D        FSEEK1:		LDA #<FVAR32
00D4AF  2  85 08        		STA FATPTRD
00D4B1  2  A9 04        		LDA #>FVAR32
00D4B3  2  85 09        		STA FATPTRD+1
00D4B5  2  A9 24        		LDA #<BYTCLUS
00D4B7  2  85 06        		STA FATPTRS
00D4B9  2  A9 04        		LDA #>BYTCLUS
00D4BB  2  85 07        		STA FATPTRS+1
00D4BD  2               
00D4BD  2  20 5C D8     		JSR CMP32	; FATPTRD < FATPTRS?
00D4C0  2  90 40        		BCC FSEEKS	; ja
00D4C2  2               
00D4C2  2  20 4C D8     		JSR SBC32
00D4C5  2               
00D4C5  2  AD 91 04     		LDA FCURCLUS
00D4C8  2  48           		PHA
00D4C9  2  AD 92 04     		LDA FCURCLUS+1
00D4CC  2  48           		PHA
00D4CD  2  20 FF D7     		JSR GETNEXTC
00D4D0  2               
00D4D0  2  C9 FF        		CMP #$FF
00D4D2  2  D0 12        		BNE FSEEK3
00D4D4  2  E0 FF        		CPX #$FF
00D4D6  2  D0 0E        		BNE FSEEK3
00D4D8  2               
00D4D8  2  68           		PLA
00D4D9  2  8D 92 04     		STA FCURCLUS+1
00D4DC  2  68           		PLA
00D4DD  2  8D 91 04     		STA FCURCLUS
00D4E0  2  20 75 D4     		JSR CHAINCLU
00D4E3  2  4C AD D4     		JMP FSEEK1
00D4E6  2               
00D4E6  2  68           FSEEK3:		PLA
00D4E7  2  68           		PLA
00D4E8  2  4C AD D4     		JMP FSEEK1
00D4EB  2               
00D4EB  2  48           DUMPSEC:	pha
00D4EC  2  8A           		txa
00D4ED  2  48           		pha
00D4EE  2  A2 03        		ldx #3
00D4F0  2  BD 0C 04     DUMPSEC1:	lda SECTOR,x
00D4F3  2  20 53 D9     		jsr PUTHEX
00D4F6  2  CA           		dex
00D4F7  2  10 F7        		bpl DUMPSEC1
00D4F9  2  A9 0A        		lda #EOL
00D4FB  2  20 79 D9     		jsr PRINT
00D4FE  2  68           		pla
00D4FF  2  AA           		tax
00D500  2  68           		pla
00D501  2  60           		rts
00D502  2               ;
00D502  2               ; INSIDE CLUSTER
00D502  2               ; SECTOR+OFFSET
00D502  2               ;
00D502  2  A9 00        FSEEKS:		LDA #0
00D504  2  8D 95 04     		STA FCURSEC
00D507  2  20 89 D7     		JSR CLU2SEC
00D50A  2               
00D50A  2               ;		jsr DUMPSEC
00D50A  2               
00D50A  2  AD 8E 04     		LDA FVAR32+1
00D50D  2  4A           		LSR
00D50E  2  8D 95 04     		STA FCURSEC
00D511  2  18           		CLC
00D512  2  6D 0D 04     		ADC SECTOR+1
00D515  2  8D 0D 04     		STA SECTOR+1
00D518  2  90 08        		BCC FSEEKS1
00D51A  2  EE 0E 04     		INC SECTOR+2
00D51D  2  D0 03        		BNE FSEEKS1
00D51F  2  EE 0F 04     		INC SECTOR+3
00D522  2               
00D522  2               ;		jsr DUMPSEC
00D522  2               
00D522  2               
00D522  2  AD 8E 04     FSEEKS1:	LDA FVAR32+1
00D525  2  29 01        		AND #1
00D527  2  18           		CLC
00D528  2  69 06        		ADC #>BUFFER
00D52A  2  85 07        		STA FATPTRS+1
00D52C  2  AD 8D 04     		LDA FVAR32
00D52F  2  85 06        		STA FATPTRS
00D531  2               
00D531  2               ;		jsr DUMPSEC
00D531  2               ;		JSR SEC2FSEC
00D531  2               
00D531  2  20 EE D8     		JSR READSEC
00D534  2               ;		JSR KBGETC
00D534  2  60           		RTS
00D535  2               ;
00D535  2               SEC2FSEC:
00D535  2               ;		LDA #'S'
00D535  2               ;		JSR PRINT
00D535  2               
00D535  2  A2 03        		LDX #3
00D537  2  BD 0C 04     SEC2FSE1:	LDA SECTOR,X
00D53A  2  9D 98 04     		STA FSECTOR,X
00D53D  2  CA           		DEX
00D53E  2  10 F7        		BPL SEC2FSE1
00D540  2               
00D540  2  A5 06        PTR2FPTR:	LDA FATPTRS
00D542  2  8D 96 04     		STA FCURPTR
00D545  2  A5 07        		LDA FATPTRS+1
00D547  2  8D 97 04     		STA FCURPTR+1
00D54A  2  60           		RTS
00D54B  2               ;
00D54B  2               ;
00D54B  2               ;
00D54B  2               FSEC2SEC:
00D54B  2               ;		LDA #'F'
00D54B  2               ;		JSR PRINT
00D54B  2               
00D54B  2  A2 03        		LDX #3
00D54D  2  BD 98 04     FSEC2SE1:	LDA FSECTOR,X
00D550  2  9D 0C 04     		STA SECTOR,X
00D553  2  CA           		DEX
00D554  2  10 F7        		BPL FSEC2SE1
00D556  2               
00D556  2  AD 96 04     FPTR2PTR:	LDA FCURPTR
00D559  2  85 06        		STA FATPTRS
00D55B  2  AD 97 04     		LDA FCURPTR+1
00D55E  2  85 07        		STA FATPTRS+1
00D560  2  60           		RTS
00D561  2               
00D561  2               ;
00D561  2               ; GET FREE CLUSTER SEARCHING FROM
00D561  2               ;
00D561  2               ; X:CLUST:L
00D561  2               ; A:CLUST:H
00D561  2               ;
00D561  2               ; AND INITIALIZE TO $FFFF
00D561  2               ;
00D561  2               ; FATPTRD	: POINTER TO PAGE OF FAT-BUF
00D561  2               ; Y	: POINTS TO CLUSTER IN PAGE
00D561  2               ; NEWCLUS: HOLDS NEW CLUSTER-NO.
00D561  2               ;
00D561  2  8E 3B 04     GETFCLUS:	STX NEWCLUS
00D564  2  8D 3C 04     		STA NEWCLUS+1
00D567  2               
00D567  2  20 0F D8     		JSR GETCLUST
00D56A  2  88           		DEY
00D56B  2  84 08        		STY FATPTRD
00D56D  2  A5 07        		LDA FATPTRS+1
00D56F  2  85 09        		STA FATPTRD+1
00D571  2               
00D571  2  EE 3B 04     GETFCLU3:	INC NEWCLUS
00D574  2  D0 03        		BNE GETFCLU4
00D576  2  EE 3C 04     		INC NEWCLUS+1
00D579  2               
00D579  2  E6 08        GETFCLU4:	INC FATPTRD
00D57B  2  E6 08        		INC FATPTRD
00D57D  2  D0 12        		BNE GETFCLU1
00D57F  2  E6 09        		INC FATPTRD+1
00D581  2  A5 09        		LDA FATPTRD+1
00D583  2  C9 0A        		CMP #(>FATBUF)+2
00D585  2  D0 0A        		BNE GETFCLU1
00D587  2               
00D587  2  20 7C D3     		JSR INCSECTO
00D58A  2               
00D58A  2  20 9E D8     		JSR READFAT
00D58D  2  A9 08        		LDA #>FATBUF
00D58F  2  85 09        		STA FATPTRD+1
00D591  2  A0 00        GETFCLU1:	LDY #0
00D593  2  B1 08        		LDA (FATPTRD),Y
00D595  2  C8           		INY
00D596  2  11 08        		ORA (FATPTRD),Y
00D598  2  D0 D7        		BNE GETFCLU3
00D59A  2  A9 FF        		LDA #$FF
00D59C  2  8D 3E 04     		STA FDIRTY
00D59F  2  91 08        		STA (FATPTRD),Y
00D5A1  2  88           		DEY
00D5A2  2  91 08        		STA (FATPTRD),Y
00D5A4  2               
00D5A4  2               ;		LDA NEWCLUS
00D5A4  2               ;		JSR PUTHEX
00D5A4  2               ;		LDA NEWCLUS+1
00D5A4  2               ;		JSR PUTHEX
00D5A4  2  60           		RTS
00D5A5  2               
00D5A5  2               DIE:	.IF PLATFORM <= 1
00D5A5  2  38           		SEC
00D5A6  2  60           		RTS
00D5A7  2               	.ELSE
00D5A7  2               		BRK
00D5A7  2               	.ENDIF
00D5A7  2               
00D5A7  2  A9 FF        INITLSEC:	LDA #$FF
00D5A9  2  A2 03        		LDX #3
00D5AB  2  9D 1C 04     INITLSEC1:	STA LASTSEC,X
00D5AE  2  CA           		DEX
00D5AF  2  10 FA        		BPL INITLSEC1
00D5B1  2  60           		RTS
00D5B2  2               
00D5B2  2  A9 FF        INITFSEC:	LDA #$FF
00D5B4  2  A2 03        		LDX #3
00D5B6  2  9D 20 04     INITFSEC1:	STA LASTFAT,X
00D5B9  2  CA           		DEX
00D5BA  2  10 FA        		BPL INITFSEC1
00D5BC  2  60           		RTS
00D5BD  2               
00D5BD  2               INITFAT:
00D5BD  2               ;	.IF PLATFORM=1
00D5BD  2               ;		jsr jSDInit
00D5BD  2               ;	.ENDIF
00D5BD  2  A2 00        		LDX #0
00D5BF  2  8A           		TXA
00D5C0  2  9D 00 04     VCLEAR:		STA V,X
00D5C3  2  9D 00 05     		STA V+256,X
00D5C6  2  CA           		DEX
00D5C7  2  D0 F7        		BNE VCLEAR
00D5C9  2               
00D5C9  2  20 A7 D5     		JSR INITLSEC
00D5CC  2  20 B2 D5     		JSR INITFSEC
00D5CF  2               
00D5CF  2  8D 7F 04     		STA FIOCBNR
00D5D2  2  8D 00 05     		STA FCB0
00D5D5  2  8D 40 05     		STA FCB1
00D5D8  2  8D 80 05     		STA FCB2
00D5DB  2  8D C0 05     		STA FCB3
00D5DE  2               
00D5DE  2  A9 00        		LDA #0		;initialise offset
00D5E0  2  AA           VSET2:		TAX		;into FCB
00D5E1  2  9D 01 05     		STA FCB0+1,X	; 0, 64, 128, 192
00D5E4  2  18           		CLC
00D5E5  2  69 40        		ADC #64
00D5E7  2  D0 F7        		BNE VSET2
00D5E9  2               
00D5E9  2  A9 00        		LDA #<BUFFER
00D5EB  2  8D 3F 04     		STA BUFADRL
00D5EE  2  A9 06        		LDA #>BUFFER
00D5F0  2  8D 40 04     		STA BUFADRH
00D5F3  2               
00D5F3  2  A9 0B        		LDA #VALIDNA2-VALIDCHA-2
00D5F5  2  8D 69 04     		STA VALIDS
00D5F8  2               
00D5F8  2               ;		LDA #'/
00D5F8  2               ;		STA PATH
00D5F8  2               
00D5F8  2  20 32 D7     		JSR READBOOT
00D5FB  2  30 A8        		BMI DIE
00D5FD  2  C9 03        		CMP #3
00D5FF  2  D0 A4        		BNE DIE
00D601  2               
00D601  2  A2 0A        		LDX #10
00D603  2  BD 0D 06     VCOPY:		LDA BUFFER+13,X
00D606  2  9D 00 04     		STA V,X
00D609  2  CA           		DEX
00D60A  2  10 F7        		BPL VCOPY
00D60C  2               
00D60C  2  AD 00 04     		LDA SECCLUS
00D60F  2  0A           		ASL
00D610  2  8D 25 04     		STA BYTCLUS+1
00D613  2               
00D613  2  18           		CLC
00D614  2  AD 0C 04     		LDA SECTOR
00D617  2  6D 01 04     		ADC RESSEC
00D61A  2  8D 10 04     		STA FATBASE
00D61D  2  8D 14 04     		STA DIRBASE
00D620  2  AD 0D 04     		LDA SECTOR+1
00D623  2  6D 02 04     		ADC RESSEC+1
00D626  2  8D 11 04     		STA FATBASE+1
00D629  2  8D 15 04     		STA DIRBASE+1
00D62C  2  90 0E        		BCC DIRBAS
00D62E  2  EE 12 04     		INC FATBASE+2
00D631  2  EE 16 04     		INC DIRBASE+2
00D634  2  D0 06        		BNE DIRBAS
00D636  2  EE 13 04     		INC FATBASE+3
00D639  2  EE 17 04     		INC DIRBASE+3
00D63C  2               
00D63C  2  18           DIRBAS:		CLC
00D63D  2  AE 03 04     		LDX NUMFATS
00D640  2  AD 14 04     DIRBAS2:	LDA DIRBASE
00D643  2  6D 09 04     		ADC SECSFAT
00D646  2  8D 14 04     		STA DIRBASE
00D649  2  AD 15 04     		LDA DIRBASE+1
00D64C  2  6D 0A 04     		ADC SECSFAT+1
00D64F  2  8D 15 04     		STA DIRBASE+1
00D652  2  90 08        		BCC DIRBAS1
00D654  2  EE 16 04     		INC DIRBASE+2
00D657  2  D0 03        		BNE DIRBAS1
00D659  2  EE 17 04     		INC DIRBASE+3
00D65C  2  CA           DIRBAS1:	DEX
00D65D  2  D0 E1        		BNE DIRBAS2
00D65F  2               
00D65F  2               ;		LDY #<DIRBASE	;COPY DIRBASE
00D65F  2               ;		LDA #>DIRBASE	;TO SECTOR
00D65F  2               ;		JSR COPY32
00D65F  2               
00D65F  2  AD 04 04     		LDA NUMDIR	;#ROOTDIRS
00D662  2  8D 18 04     		STA DATBASE
00D665  2  AD 05 04     		LDA NUMDIR+1
00D668  2  8D 19 04     		STA DATBASE+1
00D66B  2               
00D66B  2  A2 04        		LDX #4
00D66D  2  4E 19 04     DATBAS1:	LSR DATBASE+1
00D670  2  6E 18 04     		ROR DATBASE
00D673  2  CA           		DEX
00D674  2  D0 F7        		BNE DATBAS1
00D676  2               
00D676  2  18           		CLC
00D677  2  AD 18 04     		LDA DATBASE
00D67A  2  6D 14 04     		ADC DIRBASE
00D67D  2  8D 18 04     		STA DATBASE
00D680  2  AD 19 04     		LDA DATBASE+1
00D683  2  6D 15 04     		ADC DIRBASE+1
00D686  2  8D 19 04     		STA DATBASE+1
00D689  2               
00D689  2               
00D689  2               PRINTINFO:
00D689  2               	.IF PLATFORM = 2
00D689  2               		LDA #4
00D689  2               		BIT SKSTAT
00D689  2               		BNE PRINTINFO4
00D689  2               		LDA KBCODE
00D689  2               		CMP #17
00D689  2               		BEQ PRINTINFO6
00D689  2               PRINTINFO4:	RTS
00D689  2               	.ENDIF
00D689  2               
00D689  2  38           PRINTINFO6:	SEC
00D68A  2  A2 B4        		LDX #<MSG0
00D68C  2  A9 D9        		LDA #>MSG0
00D68E  2  20 91 D9     		JSR PRINTSTR
00D691  2  AD 00 04     		LDA SECCLUS
00D694  2  20 53 D9     		JSR PUTHEX
00D697  2               
00D697  2  38           		SEC
00D698  2  A2 CB        		LDX #<MSG1
00D69A  2  A9 D9        		LDA #>MSG1
00D69C  2  20 91 D9     		JSR PRINTSTR
00D69F  2  AD 02 04     		LDA RESSEC+1
00D6A2  2  20 53 D9     		JSR PUTHEX
00D6A5  2  AD 01 04     		LDA RESSEC
00D6A8  2  20 53 D9     		JSR PUTHEX
00D6AB  2               
00D6AB  2  38           		SEC
00D6AC  2  A2 E2        		LDX #<MSG2
00D6AE  2  A9 D9        		LDA #>MSG2
00D6B0  2  20 91 D9     		JSR PRINTSTR
00D6B3  2  AD 03 04     		LDA NUMFATS
00D6B6  2  20 53 D9     		JSR PUTHEX
00D6B9  2               
00D6B9  2  38           		SEC
00D6BA  2  A2 F9        		LDX #<MSG3
00D6BC  2  A9 D9        		LDA #>MSG3
00D6BE  2  20 91 D9     		JSR PRINTSTR
00D6C1  2  AD 05 04     		LDA NUMDIR+1
00D6C4  2  20 53 D9     		JSR PUTHEX
00D6C7  2  AD 04 04     		LDA NUMDIR
00D6CA  2  20 53 D9     		JSR PUTHEX
00D6CD  2               
00D6CD  2  38           		SEC
00D6CE  2  A2 10        		LDX #<MSG4
00D6D0  2  A9 DA        		LDA #>MSG4
00D6D2  2  20 91 D9     		JSR PRINTSTR
00D6D5  2  AD 0A 04     		LDA SECSFAT+1
00D6D8  2  20 53 D9     		JSR PUTHEX
00D6DB  2  AD 09 04     		LDA SECSFAT
00D6DE  2  20 53 D9     		JSR PUTHEX
00D6E1  2               
00D6E1  2  38           		SEC
00D6E2  2  A2 27        		LDX #<MSG5
00D6E4  2  A9 DA        		LDA #>MSG5
00D6E6  2  20 91 D9     		JSR PRINTSTR
00D6E9  2  A2 03        		LDX #3
00D6EB  2  BD 0C 04     PRINTINFO7:	LDA SECTOR,X
00D6EE  2  20 53 D9     		JSR PUTHEX
00D6F1  2  CA           		DEX
00D6F2  2  10 F7        		BPL PRINTINFO7
00D6F4  2               
00D6F4  2  38           		SEC
00D6F5  2  A2 3E        		LDX #<MSG6
00D6F7  2  A9 DA        		LDA #>MSG6
00D6F9  2  20 91 D9     		JSR PRINTSTR
00D6FC  2  A2 03        		LDX #3
00D6FE  2  BD 10 04     PRINTINFO1:	LDA FATBASE,X
00D701  2  20 53 D9     		JSR PUTHEX
00D704  2  CA           		DEX
00D705  2  10 F7        		BPL PRINTINFO1
00D707  2               
00D707  2  38           		SEC
00D708  2  A2 55        		LDX #<MSG7
00D70A  2  A9 DA        		LDA #>MSG7
00D70C  2  20 91 D9     		JSR PRINTSTR
00D70F  2  A2 03        		LDX #3
00D711  2  BD 14 04     PRINTINFO2:	LDA DIRBASE,X
00D714  2  20 53 D9     		JSR PUTHEX
00D717  2  CA           		DEX
00D718  2  10 F7        		BPL PRINTINFO2
00D71A  2               
00D71A  2  38           		SEC
00D71B  2  A2 6C        		LDX #<MSG8
00D71D  2  A9 DA        		LDA #>MSG8
00D71F  2  20 91 D9     		JSR PRINTSTR
00D722  2  A2 03        		LDX #3
00D724  2  BD 18 04     PRINTINFO3:	LDA DATBASE,X
00D727  2  20 53 D9     		JSR PUTHEX
00D72A  2  CA           		DEX
00D72B  2  10 F7        		BPL PRINTINFO3
00D72D  2               
00D72D  2               	.IF PLATFORM = 2
00D72D  2               		LDA #4
00D72D  2               PRINTINFO5:	BIT SKSTAT
00D72D  2               		BEQ PRINTINFO5
00D72D  2               	.ENDIF
00D72D  2               
00D72D  2  20 89 D9     		JSR NEWLINE
00D730  2  18           		CLC
00D731  2  60           		RTS
00D732  2               ;
00D732  2               ;
00D732  2               ;
00D732  2               READBOOT:
00D732  2  A0 0C        		LDY #<SECTOR	;Clear SECTOR via
00D734  2  A9 04        		LDA #>SECTOR	;FATPTRD
00D736  2  20 76 D8     		JSR CLEAR32
00D739  2               
00D739  2  20 EE D8     		JSR READSEC
00D73C  2  30 0B        		BMI READB2
00D73E  2               
00D73E  2  20 56 D7     		JSR CHECKFAT
00D741  2  F0 07        		BEQ READB3
00D743  2  C9 03        		CMP #3
00D745  2  D0 02        		BNE READB2
00D747  2  A9 00        READB1:		LDA #0
00D749  2  60           READB2:		RTS
00D74A  2               
00D74A  2  A0 C6        READB3:		LDY #<(BUFFER+PART1)
00D74C  2  A9 07        		LDA #>(BUFFER+PART1)
00D74E  2  20 68 D8     		JSR COPY32
00D751  2               
00D751  2  20 EE D8     		JSR READSEC
00D754  2  30 F3        		BMI READB2
00D756  2               ;
00D756  2               ; 0:FAT16 MBR
00D756  2               ; 1:NO BOOTSEC/MBR
00D756  2               ; 2:BOOTSEC, NO FAT16
00D756  2               ; 3:BOOTSEC, FAT16
00D756  2               ;
00D756  2  AD FE 07     CHECKFAT:	LDA BUFFER+$1FE
00D759  2  C9 55        		CMP #$55
00D75B  2  F0 03        		BEQ CHKFAT1
00D75D  2  A9 01        CHKFAT2:	LDA #1
00D75F  2  60           		RTS
00D760  2  AD FF 07     CHKFAT1:	LDA BUFFER+$1FF
00D763  2  C9 AA        		CMP #$AA
00D765  2  D0 F6        		BNE CHKFAT2
00D767  2  AD C2 07     		LDA BUFFER+$1C2
00D76A  2  C9 0E        		CMP #$0E
00D76C  2  F0 18        		BEQ CHKFAT3
00D76E  2  C9 06        		CMP #$06
00D770  2  F0 14        		BEQ CHKFAT3
00D772  2  AD 36 06     		LDA BUFFER+$36
00D775  2  C9 46        		CMP #'F'
00D777  2  D0 0A        		BNE CHKFAT4
00D779  2  AD 37 06     		LDA BUFFER+$37
00D77C  2  C9 41        		CMP #'A'
00D77E  2  D0 03        		BNE CHKFAT4
00D780  2  A9 03        		LDA #3
00D782  2  60           		RTS
00D783  2  A9 02        CHKFAT4:	LDA #2
00D785  2  60           		RTS
00D786  2  A9 00        CHKFAT3:	LDA #0
00D788  2  60           		RTS
00D789  2               
00D789  2               ;
00D789  2               ;
00D789  2               ;
00D789  2  38           CLU2SEC:	SEC
00D78A  2  AD 91 04     		LDA FCURCLUS
00D78D  2  E9 02        		SBC #2
00D78F  2  8D 0C 04     		STA SECTOR
00D792  2  AD 92 04     		LDA FCURCLUS+1
00D795  2  E9 00        		SBC #0
00D797  2  8D 0D 04     		STA SECTOR+1
00D79A  2  A9 00        		LDA #0
00D79C  2  8D 0E 04     		STA SECTOR+2
00D79F  2  8D 0F 04     		STA SECTOR+3
00D7A2  2               
00D7A2  2  AD 00 04     		LDA SECCLUS
00D7A5  2  4A           CL2SEC2:	LSR
00D7A6  2  F0 0C        		BEQ CL2SEC1
00D7A8  2  0E 0C 04     		ASL SECTOR
00D7AB  2  2E 0D 04     		ROL SECTOR+1
00D7AE  2  2E 0E 04     		ROL SECTOR+2
00D7B1  2  4C A5 D7     		JMP CL2SEC2
00D7B4  2               
00D7B4  2  18           CL2SEC1:	CLC
00D7B5  2  AD 0C 04     		LDA SECTOR
00D7B8  2  6D 18 04     		ADC DATBASE
00D7BB  2  8D 0C 04     		STA SECTOR
00D7BE  2  AD 0D 04     		LDA SECTOR+1
00D7C1  2  6D 19 04     		ADC DATBASE+1
00D7C4  2  8D 0D 04     		STA SECTOR+1
00D7C7  2  AD 0E 04     		LDA SECTOR+2
00D7CA  2  AD 0E 04     		LDA SECTOR+2
00D7CD  2  6D 1A 04     		ADC DATBASE+2
00D7D0  2  8D 0E 04     		STA SECTOR+2
00D7D3  2  AD 0F 04     		LDA SECTOR+3
00D7D6  2  6D 1B 04     		ADC DATBASE+3
00D7D9  2  8D 0F 04     		STA SECTOR+3
00D7DC  2               
00D7DC  2  18           		CLC
00D7DD  2  AD 0C 04     		LDA SECTOR
00D7E0  2  6D 95 04     		ADC FCURSEC
00D7E3  2  8D 0C 04     		STA SECTOR
00D7E6  2  AD 0D 04     		LDA SECTOR+1
00D7E9  2  69 00        		ADC #0
00D7EB  2  8D 0D 04     		STA SECTOR+1
00D7EE  2  AD 0E 04     		LDA SECTOR+2
00D7F1  2  69 00        		ADC #0
00D7F3  2  8D 0E 04     		STA SECTOR+2
00D7F6  2  AD 0F 04     		LDA SECTOR+3
00D7F9  2  69 00        		ADC #0
00D7FB  2  8D 0F 04     		STA SECTOR+3
00D7FE  2               
00D7FE  2  60           		RTS
00D7FF  2               
00D7FF  2               GETNEXTC:
00D7FF  2  AE 91 04     		LDX FCURCLUS
00D802  2  AD 92 04     		LDA FCURCLUS+1
00D805  2  20 0F D8     		JSR GETCLUST
00D808  2  8E 91 04     		STX FCURCLUS
00D80B  2  8D 92 04     		STA FCURCLUS+1
00D80E  2  60           		RTS
00D80F  2               ;
00D80F  2               ; X:CLUST:L
00D80F  2               ; A:CLUST:H
00D80F  2               ;
00D80F  2  18           GETCLUST:	CLC
00D810  2  8D 0C 04     		STA SECTOR
00D813  2  6D 10 04     		ADC FATBASE
00D816  2  8D 0C 04     		STA SECTOR
00D819  2  AD 11 04     		LDA FATBASE+1
00D81C  2  69 00        		ADC #0
00D81E  2  8D 0D 04     		STA SECTOR+1
00D821  2  AD 12 04     		LDA FATBASE+2
00D824  2  69 00        		ADC #0
00D826  2  8D 0E 04     		STA SECTOR+2
00D829  2  AD 13 04     		LDA FATBASE+3
00D82C  2  69 00        		ADC #0
00D82E  2  8D 0F 04     		STA SECTOR+3
00D831  2  8A           		TXA
00D832  2  48           		PHA
00D833  2  20 9E D8     		JSR READFAT
00D836  2               
00D836  2  A9 00        		LDA #<FATBUF
00D838  2  85 06        		STA FATPTRS
00D83A  2  A9 08        		LDA #>FATBUF
00D83C  2  85 07        		STA FATPTRS+1
00D83E  2               
00D83E  2  68           		PLA
00D83F  2  0A           		ASL
00D840  2  90 02        		BCC GETCLUS1
00D842  2  E6 07        		INC FATPTRS+1
00D844  2  A8           GETCLUS1:	TAY
00D845  2  B1 06        		LDA (FATPTRS),Y
00D847  2  AA           		TAX
00D848  2  C8           		INY
00D849  2  B1 06        		LDA (FATPTRS),Y
00D84B  2  60           		RTS
00D84C  2               ;
00D84C  2               ;
00D84C  2               ;
00D84C  2  A0 00        SBC32:		LDY #0
00D84E  2  A2 03        		LDX #3
00D850  2  38           		SEC
00D851  2  B1 08        SBC32A:		LDA (FATPTRD),Y
00D853  2  F1 06        		SBC (FATPTRS),Y
00D855  2  91 08        		STA (FATPTRD),Y
00D857  2  C8           		INY
00D858  2  CA           		DEX
00D859  2  10 F6        		BPL SBC32A
00D85B  2  60           		RTS
00D85C  2               ;
00D85C  2               ; FATPTRD - FATPTRS (compare)
00D85C  2               ;
00D85C  2  A0 03        CMP32:		LDY #3
00D85E  2  B1 08        CMP32A:		LDA (FATPTRD),Y
00D860  2  D1 06        		CMP (FATPTRS),Y
00D862  2  D0 03        		BNE CMP32B
00D864  2  88           		DEY
00D865  2  10 F7        		BPL CMP32A
00D867  2  60           CMP32B:		RTS
00D868  2               
00D868  2  84 06        COPY32:		STY FATPTRS
00D86A  2  85 07        		STA FATPTRS+1
00D86C  2  A0 03        COPY32B:	LDY #3
00D86E  2  B1 06        COPY32A:	LDA (FATPTRS),Y
00D870  2  91 08        		STA (FATPTRD),Y
00D872  2  88           		DEY
00D873  2  10 F9        		BPL COPY32A
00D875  2  60           		RTS
00D876  2               
00D876  2  84 08        CLEAR32:	STY FATPTRD
00D878  2  85 09        		STA FATPTRD+1
00D87A  2  A0 03        		LDY #3
00D87C  2  A9 00        		LDA #0
00D87E  2  91 08        CL32A:		STA (FATPTRD),Y
00D880  2  88           		DEY
00D881  2  10 FB        		BPL CL32A
00D883  2  60           		RTS
00D884  2               
00D884  2  AD 3E 04     WRITEFAT:	LDA FDIRTY
00D887  2  F0 09        		BEQ WRITEFA9
00D889  2               
00D889  2  A2 20        		LDX #<LASTFAT
00D88B  2  A9 04        		LDA #>LASTFAT
00D88D  2  20 50 D9     		JSR SETSEC
00D890  2  10 01        		BPL WRITEFA1
00D892  2  60           WRITEFA9:	RTS
00D893  2               
00D893  2  20 4D D9     WRITEFA1:	JSR SETWRITE
00D896  2  A9 00        		LDA #0
00D898  2  8D 3E 04     		STA FDIRTY
00D89B  2  4C C7 D8     		JMP RWFAT
00D89E  2               
00D89E  2  A2 03        READFAT:	LDX #3
00D8A0  2  BD 0C 04     READFAT3:	LDA SECTOR,X
00D8A3  2  DD 20 04     		CMP LASTFAT,X
00D8A6  2  D0 04        		BNE READFAT2
00D8A8  2  CA           		DEX
00D8A9  2  10 F5        		BPL READFAT3
00D8AB  2  60           		RTS
00D8AC  2               
00D8AC  2  20 84 D8     READFAT2:	JSR WRITEFAT
00D8AF  2               
00D8AF  2  A2 03        		LDX #3
00D8B1  2  BD 0C 04     READFAT4:	LDA SECTOR,X
00D8B4  2  9D 20 04     		STA LASTFAT,X
00D8B7  2  CA           		DEX
00D8B8  2  10 F7        		BPL READFAT4
00D8BA  2               
00D8BA  2  A2 0C        		LDX #<SECTOR
00D8BC  2  A9 04        		LDA #>SECTOR
00D8BE  2  20 50 D9     		JSR SETSEC
00D8C1  2  10 01        		BPL READFAT1
00D8C3  2  60           		RTS
00D8C4  2               
00D8C4  2  20 4A D9     READFAT1:	JSR SETREAD
00D8C7  2  A9 00        RWFAT:		LDA #<FATBUF
00D8C9  2  8D 50 02     		STA DBUFLO
00D8CC  2  A9 08        		LDA #>FATBUF
00D8CE  2  8D 51 02     		STA DBUFLO+1
00D8D1  2  4C 3A D9     		JMP RWSEC1
00D8D4  2               ;
00D8D4  2               ;
00D8D4  2               ;
00D8D4  2  AD 3D 04     WRITESEC:	LDA DDIRTY
00D8D7  2  F0 09        		BEQ WRITESE9
00D8D9  2               
00D8D9  2  A2 1C        		LDX #<LASTSEC
00D8DB  2  A9 04        		LDA #>LASTSEC
00D8DD  2  20 50 D9     		JSR SETSEC
00D8E0  2  10 01        		BPL WRITESE1
00D8E2  2  60           WRITESE9:	RTS
00D8E3  2               
00D8E3  2  20 4D D9     WRITESE1:	JSR SETWRITE
00D8E6  2  A9 00        		LDA #0
00D8E8  2  8D 3D 04     		STA DDIRTY
00D8EB  2  4C 2E D9     		JMP RWSEC
00D8EE  2               
00D8EE  2  A2 03        READSEC:	LDX #3
00D8F0  2  BD 0C 04     READSEC3:	LDA SECTOR,X
00D8F3  2  DD 1C 04     		CMP LASTSEC,X
00D8F6  2  D0 04        		BNE READSEC2
00D8F8  2  CA           		DEX
00D8F9  2  10 F5        		BPL READSEC3
00D8FB  2  60           		RTS
00D8FC  2               
00D8FC  2  20 D4 D8     READSEC2:	JSR WRITESEC
00D8FF  2               
00D8FF  2  A2 03        		LDX #3
00D901  2  BD 0C 04     READSEC4:	LDA SECTOR,X
00D904  2  9D 1C 04     		STA LASTSEC,X
00D907  2  CA           		DEX
00D908  2  10 F7        		BPL READSEC4
00D90A  2               
00D90A  2  A2 00        READSECF:	LDX #0
00D90C  2  AD 87 04     		LDA FWBURST		;write Burst active?
00D90F  2  8E 87 04     		STX FWBURST
00D912  2  F0 0D        		BEQ READSECF1		;no ->
00D914  2  A5 28        		LDA ICBLHZ		;still $200 to read?
00D916  2  C9 02        		CMP #2
00D918  2  90 07        		BCC READSECF1		;no ->
00D91A  2  D0 04        		BNE READSECF2		;greater, no read
00D91C  2  A5 27        		LDA ICBLLZ		;we have substracted only $1ff
00D91E  2  F0 01        		BEQ READSECF1		;so, if lenght-LO = 0 then end is reached.
00D920  2  60           READSECF2:	RTS
00D921  2               
00D921  2  A2 0C        READSECF1:	LDX #<SECTOR
00D923  2  A9 04        		LDA #>SECTOR
00D925  2  20 50 D9     		JSR SETSEC
00D928  2  10 01        		BPL READSEC1
00D92A  2  60           		RTS
00D92B  2               
00D92B  2  20 4A D9     READSEC1:	JSR SETREAD
00D92E  2               
00D92E  2  AD 3F 04     RWSEC:		LDA BUFADRL
00D931  2  8D 50 02     		STA DBUFLO
00D934  2  AD 40 04     		LDA BUFADRH
00D937  2  8D 51 02     		STA DBUFLO+1
00D93A  2               
00D93A  2               	.IF PLATFORM <= 1
00D93A  2  AE 50 02     RWSEC1:		LDX DBUFLO
00D93D  2  AD 51 02     		LDA DBUFLO+1
00D940  2  C0 80        		CPY #$80		; $40 = read; $80 = write
00D942  2  F0 03        		beq RWSEC2
00D944  2  4C 23 C1     		jmp readSector
00D947  2  4C 33 C1     RWSEC2:		jmp writeSector
00D94A  2               	.ELSE
00D94A  2               RWSEC1:		LDA #0			; 512 bytes
00D94A  2               		STA DBYTLO
00D94A  2               		LDA #2
00D94A  2               		STA DBYTLO+1
00D94A  2               		JMP SIOV
00D94A  2               	.ENDIF
00D94A  2               
00D94A  2               SETREAD:
00D94A  2               	.IF PLATFORM <= 1
00D94A  2  A0 40        		LDY #$40
00D94C  2               	.ELSE
00D94C  2               		LDA #$40
00D94C  2               		STA DSTATS
00D94C  2               		LDA #'R'
00D94C  2               		STA DCOMND
00D94C  2               	.ENDIF
00D94C  2  60           		RTS
00D94D  2               
00D94D  2               SETWRITE:
00D94D  2               	.IF PLATFORM <= 1
00D94D  2  A0 80        		LDY #$80
00D94F  2               	.ELSE
00D94F  2               		LDA #$80
00D94F  2               		STA DSTATS
00D94F  2               		LDA #'P'
00D94F  2               		STA DCOMND
00D94F  2               	.ENDIF
00D94F  2  60           		RTS
00D950  2               ;
00D950  2               ;
00D950  2               ;
00D950  2               	.IF PLATFORM <= 1
00D950  2  4C FA C0     SETSEC:		jmp setSector
00D953  2               	.ELSE
00D953  2               SETSEC:		STX DBUFLO
00D953  2               		STA DBUFLO+1
00D953  2               		LDA #$31
00D953  2               		STA DDEVIC
00D953  2               		LDA #1
00D953  2               		STA DUNIT
00D953  2               
00D953  2               		JSR SETWRITE
00D953  2               
00D953  2               		LDA #4
00D953  2               		STA DBYTLO
00D953  2               		STA DTIMLO
00D953  2               		LDA #0
00D953  2               		STA DBYTLO+1
00D953  2               		STA DAUX1
00D953  2               		STA DAUX2
00D953  2               		JMP SIOV
00D953  2               
00D953  2               	.ENDIF
00D953  2               ;
00D953  2  48           PUTHEX:		PHA
00D954  2  8A           		TXA
00D955  2  48           		PHA
00D956  2  98           		TYA
00D957  2  48           		PHA
00D958  2               
00D958  2               	.IF PLATFORM = 2
00D958  2               		TSX
00D958  2               		LDA $103,X
00D958  2               	.ELSE
00D958  2  A3 03        		LDA 3,s
00D95A  2               	.ENDIF
00D95A  2  48           		PHA
00D95B  2  4A           		LSR
00D95C  2  4A           		LSR
00D95D  2  4A           		LSR
00D95E  2  4A           		LSR
00D95F  2  20 6E D9     		JSR PUTNIB
00D962  2               
00D962  2  68           		PLA
00D963  2  29 0F        		AND #15
00D965  2  20 6E D9     		JSR PUTNIB
00D968  2               
00D968  2  68           		PLA
00D969  2  A8           		TAY
00D96A  2  68           		PLA
00D96B  2  AA           		TAX
00D96C  2  68           		PLA
00D96D  2  60           		RTS
00D96E  2               
00D96E  2  C9 0A        PUTNIB:		CMP #10
00D970  2  90 02        		BCC PUTNIB1
00D972  2  69 06        		ADC #6
00D974  2  69 30        PUTNIB1:	ADC #48
00D976  2  4C 83 DA     		JMP EOUTCH
00D979  2               
00D979  2  48           PRINT:		PHA
00D97A  2  8A           		TXA
00D97B  2  48           		PHA
00D97C  2  98           		TYA
00D97D  2  48           		PHA
00D97E  2               	.IF PLATFORM = 2
00D97E  2               		TSX
00D97E  2               		LDA $103,X
00D97E  2               		CMP #$0A
00D97E  2               		BNE PR1
00D97E  2               		LDA #EOL
00D97E  2               	.ELSE
00D97E  2  A3 03        		lda 3,s
00D980  2               	.ENDIF
00D980  2  20 83 DA     PR1:		JSR EOUTCH
00D983  2  68           		PLA
00D984  2  A8           		TAY
00D985  2  68           		PLA
00D986  2  AA           		TAX
00D987  2  68           		PLA
00D988  2  60           		RTS
00D989  2               
00D989  2  48           NEWLINE:	PHA
00D98A  2  A9 0A        		LDA #EOL
00D98C  2  20 79 D9     		JSR PRINT
00D98F  2  68           		PLA
00D990  2  60           		RTS
00D991  2               ;
00D991  2               ;
00D991  2               ;
00D991  2  A8           PRINTSTR:	TAY
00D992  2  A5 06        		LDA FATPTRS
00D994  2  48           		PHA
00D995  2  A5 07        		LDA FATPTRS+1
00D997  2  48           		PHA
00D998  2               
00D998  2  86 06        		STX FATPTRS
00D99A  2  84 07        		STY FATPTRS+1
00D99C  2  A0 00        		LDY #0
00D99E  2  90 03        		BCC PRINTSTR2
00D9A0  2               
00D9A0  2  20 89 D9     		JSR NEWLINE
00D9A3  2               
00D9A3  2  B1 06        PRINTSTR2:	LDA (FATPTRS),Y
00D9A5  2  F0 06        		BEQ PRINTSTR1
00D9A7  2  20 79 D9     		JSR PRINT
00D9AA  2  C8           		INY
00D9AB  2  D0 F6        		BNE PRINTSTR2	;do not print more than 256 chars
00D9AD  2  68           PRINTSTR1:	PLA
00D9AE  2  85 07        		STA FATPTRS+1
00D9B0  2  68           		PLA
00D9B1  2  85 06        		STA FATPTRS
00D9B3  2  60           		RTS
00D9B4  2               
00D9B4  2               
00D9B4  2  53 65 63 74  MSG0:		.byte "Sectors per cluster: $",0
00D9B8  2  6F 72 73 20  
00D9BC  2  70 65 72 20  
00D9CB  2  52 65 73 65  MSG1:		.byte "Reserved sectors   : $",0
00D9CF  2  72 76 65 64  
00D9D3  2  20 73 65 63  
00D9E2  2  4E 75 6D 62  MSG2:		.byte "Number of FATs     : $",0
00D9E6  2  65 72 20 6F  
00D9EA  2  66 20 46 41  
00D9F9  2  4E 75 6D 62  MSG3:		.byte "Number of root-entr: $",0
00D9FD  2  65 72 20 6F  
00DA01  2  66 20 72 6F  
00DA10  2  53 65 63 74  MSG4:		.byte "Sectors per FAT    : $",0
00DA14  2  6F 72 73 20  
00DA18  2  70 65 72 20  
00DA27  2  46 41 54 2D  MSG5:		.byte "FAT-16 boot sector : $",0
00DA2B  2  31 36 20 62  
00DA2F  2  6F 6F 74 20  
00DA3E  2  46 41 54 20  MSG6:		.byte "FAT base           : $",0
00DA42  2  62 61 73 65  
00DA46  2  20 20 20 20  
00DA55  2  44 49 52 20  MSG7:		.byte "DIR base           : $",0
00DA59  2  62 61 73 65  
00DA5D  2  20 20 20 20  
00DA6C  2  44 41 54 20  MSG8:		.byte "DAT base           : $",0
00DA70  2  62 61 73 65  
00DA74  2  20 20 20 20  
00DA83  2               
00DA83  2  AA           EOUTCH:		TAX
00DA84  2  A9 C5        		LDA #>(EPB-1)
00DA86  2  48           		PHA
00DA87  2  A9 2F        		LDA #<(EPB-1)
00DA89  2  48           		PHA
00DA8A  2  8A           		TXA
00DA8B  2  60           		RTS
00DA8C  2               
00DA8C  1               
