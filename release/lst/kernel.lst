ca65 V2.17 - Git 59ab140
Main file   : ..\src\kernel.a65
Current file: ..\src\kernel.a65

000000r 1               		.include "homebrew.inc"
000000r 2               ;
000000r 2               ; PLATFORM = 0 : Homebrew - FPGA
000000r 2               ; PLATFORM = 1 : Homebrew - Hardware
000000r 2               ; PLATFORM = 2 : Atari XL/XE
000000r 2               ;
000000r 2               IO		= $FFFF00
000000r 2               ROMSTART	= $E000		;$8000 = Test, $E000 = Prod
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Kernel jumptable
000000r 2               ;--------------------------------------------------------------
000000r 2               jkernel		= ROMSTART
000000r 2               jchrin		= ROMSTART + $3
000000r 2               jchrout		= ROMSTART + $6
000000r 2               jprint		= ROMSTART + $9
000000r 2               jprinthex	= ROMSTART + $C
000000r 2               jgetupper	= ROMSTART + $F
000000r 2               jgethex		= ROMSTART + $12
000000r 2               jgetadr		= ROMSTART + $15
000000r 2               jnewline	= ROMSTART + $18
000000r 2               jspace		= ROMSTART + $1B
000000r 2               jhexdownload	= ROMSTART + $1E
000000r 2               jmemdump	= ROMSTART + $21
000000r 2               jinputhex	= ROMSTART + $24
000000r 2               jchangemem	= ROMSTART + $27
000000r 2               jfillmem	= ROMSTART + $2A
000000r 2               jfill		= ROMSTART + $2D
000000r 2               jnmin		= ROMSTART + $30
000000r 2               jirqn		= ROMSTART + $33
000000r 2               jbrk		= ROMSTART + $36
000000r 2               jtime		= ROMSTART + $39
000000r 2               jmenu		= ROMSTART + $3C
000000r 2               jdisass		= ROMSTART + $3F
000000r 2               jdisone		= ROMSTART + $42
000000r 2               jrs232v		= ROMSTART + $45
000000r 2               jsetaddress	= ROMSTART + $48
000000r 2               jmemdump16	= ROMSTART + $4B
000000r 2               jkgbirq		= ROMSTART + $4E	;(4-bytes !!)
000000r 2               jdisass24	= ROMSTART + $52
000000r 2               jcopn		= ROMSTART + $55
000000r 2               
000000r 2               ;
000000r 2               ; Dummy vectors
000000r 2               ;
000000r 2               jcope		= ROMSTART + $30
000000r 2               jaborte		= ROMSTART + $30
000000r 2               jabortn		= ROMSTART + $30
000000r 2               jirqe		= ROMSTART + $30
000000r 2               jnmie		= ROMSTART + $30
000000r 2               
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; SD CARD constants
000000r 2               ;--------------------------------------------------------------
000000r 2               CMD0		= $40 +  0	;GO_IDLE_STATE	0x40, 64
000000r 2               CMD1		= $40 +  1	;reset
000000r 2               CMD8		= $40 +  8	;SEND_IF_COND	0x48, 72
000000r 2               CMD9		= $40 +  9	;SEND_CSD	0x49, 73
000000r 2               CMD13		= $40 + 13	;get_status	0x4D, 77
000000r 2               CMD17		= $40 + 17	;read  sector 	0x51, 81
000000r 2               CMD24		= $40 + 24	;write sector 	0x58, 88
000000r 2               CMD41		= $40 + 41	;SEND_OP_COND	0x69, 105 (leave idle state)
000000r 2               CMD55		= $40 + 55	;ACMD 		0x77, 119
000000r 2               CMD58		= $40 + 58	;READ_OCR	0x7A, 122
000000r 2               
000000r 2               DATA_START_BLOCK	= $FE
000000r 2               DATA_RES_MASK		= $1F
000000r 2               DATA_RES_ACCEPTED	= $05
000000r 2               
000000r 2               CMD0CHK		= $95
000000r 2               CMD1CHK		= $F9
000000r 2               CMD8CHK		= $87
000000r 2               
000000r 2               R1_IDLE_STATE	= 1
000000r 2               R1_ILLEGAL_COMMAND = 4
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; MISC constants
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               NEGATIVE	= $80
000000r 2               OVERFLOW	= $40		;
000000r 2               M		= $20		; Accu 8/16-bit
000000r 2               IX		= $10		; Index 8/16-bit
000000r 2               DECIMAL_FLAG	= $08		; Decimal Flag
000000r 2               ID		= $04		; IRQ disable
000000r 2               ZERO		= $02		; zero flag
000000r 2               CARRY		= $01		; Carry
000000r 2               
000000r 2               CHARS40		= 40
000000r 2               CHARS80		= 80
000000r 2               NUMROWS		= 25
000000r 2               
000000r 2               ;	special key scan-codes
000000r 2               ALTGR		= $11	;extended!
000000r 2               ALR		= $11
000000r 2               CLSHIFT		= $12
000000r 2               CLSTRG		= $14
000000r 2               CRSHIFT		= $59
000000r 2               CCAPS		= $58
000000r 2               
000000r 2               CCHARLINE	= 80	;80 chars per line
000000r 2               
000000r 2               	.if PLATFORM = 0
000000r 2               SCRSTRT		= $F000
000000r 2               SCRBANK		= $7F
000000r 2               	.else
000000r 2               SCRSTRT		= $C000
000000r 2               	.endif
000000r 2               charset		= $F800
000000r 2               
000000r 2               jusermenu	= $0400
000000r 2               juserkeys	= $0403
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; ATARI constants
000000r 2               ;--------------------------------------------------------------
000000r 2               LEDGE	= 	0	;left edge
000000r 2               
000000r 2               MAXDEV	=	33	;offset to last possible entry of HATABS
000000r 2               
000000r 2               IOCBSZ	=	16	;length of IOCB
000000r 2               IOCFRE	=	$FF	;IOCB free indicator
000000r 2               
000000r 2               SEIOCB	=	0*IOCBSZ	;screen editor IOCB index
000000r 2               MAXIOC	=	8*IOCBSZ	;first invalid IOCB index
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Device Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               CASSET	=	'C'	;cassette
000000r 2               DISK	=	'D'	;disk
000000r 2               SCREDT	=	'E'	;screen editor
000000r 2               KBD	=	'K'	;keyboard
000000r 2               PRINTR	=	'P'	;printer
000000r 2               DISPLY	=	'S'	;screen display
000000r 2               RS232D	=	'R'	;RS232 serial interface
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	IOCB Command Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               OPEN	=	$03	;open
000000r 2               GETREC	=	$05	;get record
000000r 2               GETCHR	=	$07	;get character(s) (binary)
000000r 2               PUTREC	=	$09	;put record
000000r 2               PUTCHR	=	$0B	;put character(s)
000000r 2               CLOSE	=	$0C	;close
000000r 2               STATUS	=	$0D	;status
000000r 2               SPECIL	=	$0E	;special
000000r 2               
000000r 2               CXIO36	= 	36
000000r 2               CXIO38	=	38
000000r 2               CXIO40	=	40
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Character and Key Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               			;SUPERF <>  0
000000r 2               
000000r 2               CCHM	=	$1C	;move cursor home
000000r 2               CCBT	=	$1D	;move cursor to bottom
000000r 2               CCLM	=	$1E	;move cursor to left margin
000000r 2               CCRM	=	$1F	;move cursor to right margin
000000r 2               
000000r 2               			;SUPERF = 0
000000r 2               
000000r 2               CLS	=	$01	;clear screen
000000r 2               BACK	=	$08	;backspace
000000r 2               EOL	=	$0A	;$9B	;end of line (RETURN)
000000r 2               ESC	=	$1B	;escape key
000000r 2               CCUP	=	$1C	;cursor up
000000r 2               CCDN	=	$1D	;cursor down
000000r 2               CCLF	=	$1E	;cursor left
000000r 2               CCRT	=	$1F	;cursor right
000000r 2               CSPACE	=	$20	;space
000000r 2               TABU	=	$7F	;tabulator
000000r 2               CILN	=	$9D	;insert line
000000r 2               CDCH	=	$FE	;delete character
000000r 2               CICH	=	$FF	;insert character
000000r 2               
000000r 2               HELP	=	$11	;key code for HELP
000000r 2               CNTLF1	=	$83	;key code for CTRL-F1
000000r 2               CNTLF2	=	$84	;key code for CTRL-F2
000000r 2               CNTLF3	=	$93	;key code for CTRL-F3
000000r 2               CNTLF4	=	$94	;key code for CTRL-F4
000000r 2               CNTL1	=	$9F	;key code for CTRL-1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Status Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               SUCCES	=	1	;successful operation
000000r 2               
000000r 2               BRKABT	=	128	;BREAK key abort
000000r 2               PRVOPN	=	129	;IOCB already open error
000000r 2               NONDEV	=	130	;nonexistent device error
000000r 2               WRONLY	=	131	;IOCB opened for write only error
000000r 2               NVALID	=	132	;invalid command error
000000r 2               NOTOPN	=	133	;device/file not open error
000000r 2               BADIOC	=	134	;invalid IOCB index error
000000r 2               RDONLY	=	135	;IOCB opened for read only error
000000r 2               EOFERR	=	136	;end of file error
000000r 2               TRNRCD	=	137	;truncated record error
000000r 2               TIMOUT	=	138	;peripheral device timeout error
000000r 2               DNACK	=	139	;device does not acknowledge command error
000000r 2               FRMERR	=	140	;serial bus framing error
000000r 2               CRSROR	=	141	;cursor overrange error
000000r 2               OVRRUN	=	142	;serial bus data overrun error
000000r 2               CHKERR	=	143	;serial bus checksum error
000000r 2               DERROR	=	144	;device done (operation incomplete) error
000000r 2               BADMOD	=	145	;bad screen mode number error
000000r 2               FNCNOT	=	146	;function not implemented in handler error
000000r 2               SCRMEM	=	147	;insufficient memory for screen mode error
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew variables Zero page
000000r 2               ;--------------------------------------------------------------
000000r 2               ptr		= $00	;2-byte misc. pointer
000000r 2               memptr		= $02	;3-byte pointer
000000r 2               
000000r 2               PCREG		= $02   ;3-byte redefine for disassembler
000000r 2               PCREGH		= PCREG+1
000000r 2               PCREGB		= PCREGH+1
000000r 2               
000000r 2               chksum		= $05	;1-byte checksum
000000r 2               
000000r 2               FATPTRS_	= $06	;2-byte FAT source pointer
000000r 2               FATPTRD_	= $08	;2-byte FAT destination pointer
000000r 2               PTRDUP		= $0A	;2-byte misc. pointer DUP
000000r 2               SECPTR		= $0C	;2-byte sector pointer
000000r 2               CHRPTR		= $0E	;2-byte sector pointer hi-res char handling
000000r 2               DEVICNO		= $10	;1-byte stdout device (0=RS232, 1=CRT)
000000r 2               TEMP		= $11	;3-byte pointer for debug16
000000r 2               TEMPH		= $12
000000r 2               TEMPB		= $13
000000r 2               PREG		= $14	;1-byte P STATUS REGISTER
000000r 2               gethex_A	= $15	;1-byte save accu
000000r 2               
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; ATARI zeropage
000000r 2               ;--------------------------------------------------------------
000000r 2               ZIOCB	=	$0020	;address of page zero IOCB
000000r 2               IOCBAS	=	$0020	;16-byte page zero IOCB
000000r 2               ICHIDZ	=	$0020	;1-byte handler ID ($FF = IOCB free)
000000r 2               ICDNOZ	=	$0021	;1-byte device number
000000r 2               ICCOMZ	=	$0022	;1-byte command code
000000r 2               ICSTAZ	=	$0023	;1-byte status of last action
000000r 2               ICBALZ	=	$0024	;1-byte buffer address low
000000r 2               ICBAHZ	=	$0025	;1-byte buffer address high
000000r 2               ICBABZ	=	$0026	;1-byte buffer address bank
000000r 2               ICBLLZ	=	$0027	;1-byte buffer length low
000000r 2               ICBLHZ	=	$0028	;1-byte buffer length high
000000r 2               ICBLBZ	=	$0029	;1-byte buffer length bank
000000r 2               ICAX1Z	=	$002A	;1-byte first auxiliary information
000000r 2               ICAX2Z	=	$002B	;1-byte second auxiliary information
000000r 2               ICSPRZ	=	$002C	;4-byte spares
000000r 2               ;ENTVEC	=	$002C	;2-byte (not used)
000000r 2               ICIDNO	=	$002E	;1-byte IOCB index (IOCB number times IOCBSZ)
000000r 2               CIOCHR	=	$002F	;1-byte character for current CIO operation
000000r 2               ;ICPTLZ	=	$0026	;1-byte low PUT-BYTE routine address-1
000000r 2               ;ICPTHZ	=	$0027	;1-byte high PUT-BYTE routine address-1
000000r 2               
000000r 2               BRKKEY	=	$0030	;1-byte BREAK key flag (0 = no BREAK)
000000r 2               ICCOMT	=	$0031	;1-byte CIO command table index
000000r 2               DSTAT	=	$0032	;1-byte display status
000000r 2               TMPCHR	=	$0033	;1-byte	temporary character
000000r 2               HOLD1	=	$0034	;1-byte	temporary
000000r 2               LMARGN	=	$0035	;1-byte text column left margin
000000r 2               RMARGN	=	$0036	;1-byte text column right margin
000000r 2               ROWCRS	=	$0037	;1-byte cursor row
000000r 2               COLCRS	=	$0038	;2-byte cursor column
000000r 2               ALTACT	=	$003A	;1-byte ALRGR active --display mode
000000r 2               SAVMSC	=	$003B	;2-byte saved memory scan counter
000000r 2               OLDROW	=	$003D	;1-byte prior row
000000r 2               OLDCOL	=	$003E	;2-byte prior column
000000r 2               OLDCHR	=	$0040	;1-byte saved character under cursor
000000r 2               OLDADR	=	$0041	;3-byte saved cursor memory address
000000r 2               
000000r 2               LOGCOL	=	$0044	;1-byte logical line cursor column
000000r 2               
000000r 2               ;DUMMY	=	$0044	;2-byte temporary address
000000r 2               
000000r 2               ;MLTTMP	=	$0046	;1-byte temporary
000000r 2               ;OPNTMP	=	$0046	;1-byte open temporary
000000r 2               TOADR	=	$0045	;3-byte destination address
000000r 2               
000000r 2               SAVADR	=	$0048	;3-byte saved address
000000r 2               FRMADR	=	$0048	;3-byte source address
000000r 2               
000000r 2               RAMTOP	=	$004B	;1-byte RAM size
000000r 2               BUFCNT	=	$004C	;1-byte buffer count (logical line size)
000000r 2               BUFSTR	=	$004D	;2-byte buffer start pointer
000000r 2               BITMSK	=	$004F	;1-byte bit mask for bit map operation
000000r 2               ;SHFAMT	=	$004F	;1-byte shift amount for pixel justification
000000r 2               ROWAC	=	$0050	;2-byte draw working row
000000r 2               COLAC	=	$0052	;2-byte draw working column
000000r 2               ENDPT	=	$0054	;2-byte end point
000000r 2               DELTAR	=	$0056	;1-byte row difference
000000r 2               DELTAC	=	$0057	;2-byte column difference
000000r 2               SWPFLG	=	$0059	;1-byte split screen swap flag (0 = not swapped)
000000r 2               INSDAT	=	$005A	;1-byte temporary
000000r 2               COUNTR	=	$005B	;2-byte draw iteration count
000000r 2               ADRESS	=	$005D	;3-byte temporary address
000000r 2               
000000r 2               
000000r 2               
000000r 2               XREG	= ADRESS+3       ; X REGISTER
000000r 2               XREGH 	= XREG+1
000000r 2               
000000r 2               YREG	= XREGH+1        ; Y REGISTER
000000r 2               YREGH	= YREG+1
000000r 2               
000000r 2               AREG	= YREGH+1        ; ACCUMULATOR
000000r 2               AREGH	= AREG+1
000000r 2               
000000r 2               STACK	= AREGH+1        ; STACK POINTER
000000r 2               STACKH	= STACK+1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 2
000000r 2               ;--------------------------------------------------------------
000000r 2               TXTROW	=	$0200	;1-byte split screen text cursor row
000000r 2               TXTCOL	=	$0201	;2-byte split screen text cursor column
000000r 2               TINDEX	=	$0203	;1-byte split scree text mode
000000r 2               TXTMSC	=	$0204	;2-byte split screen memory scan counter
000000r 2               TXTOLD	=	$0206	;6-byte OLDROW, OLDCOL, OLDCHR, OLDADR for text
000000r 2               HOLD3	=	$020C	;1-byte temporary
000000r 2               SUBTMP	=	$020D	;1-byte temporary
000000r 2               HOLD2	=	$020E	;1-byte (not used)
000000r 2               ;DMASK	=	$020F	;1-byte display (pixel location) mask
000000r 2               ;TMPLBT	=	$0210	;1-byte (not used)
000000r 2               RASVEC	=	$020F	;raster interrupt vector
000000r 2               ESCFLG	=	$0211	;1-byte escape flag ($80 = ESC detected)
000000r 2               TABMAP	=	$0212	;15-byte (120-bit) tab stop bit map
000000r 2               LOGMAP	=	$0221	;8-byte (32-bit) logical line bit map
000000r 2               CLSFLG	=	$0229	;1-byte clear screen flag
000000r 2               FILFLG	=	$022A	;1-byte right fill flag (0 = no fill)
000000r 2               TMPROW	=	$022B	;1-byte temporary row
000000r 2               TMPCOL	=	$022C	;2-byte temporary column
000000r 2               SCRFLG	=	$022E	;1-byte scroll occurence flag (0 = not occurred)
000000r 2               HOLD4	=	$022F	;1-byte temporary
000000r 2               DRETRY	=	$0230	;1-byte number of device retries
000000r 2               SHFLOK	=	$0231	;1-byte shift/control lock flags
000000r 2               BOTSCR	=	$0232	;1-byte screen bottom (24 = normal, 4 = split)
000000r 2               
000000r 2               DVSTAT	=	$0233	;4-byte device status buffer
000000r 2               CRSINH	=	$0237	;1-byte cursor inhibit (0 = cursor on)
000000r 2               DUMMY00	=	$0238	;1-byte key debounce delay timer
000000r 2               CH1	=	$0239	;1-byte prior keyboard character
000000r 2               
000000r 2               NEWROW	=	$023A	;1-byte draw destination row
000000r 2               NEWCOL	=	$023B	;2-byte draw destination column
000000r 2               ROWINC	=	$023D	;1-byte draw row increment
000000r 2               COLINC	=	$023E	;1-byte	draw column increment
000000r 2               
000000r 2               CHAR	=	$023F	;1-byte internal character
000000r 2               ATACHR	=	$0240	;1-byte ATASCII character or plot point
000000r 2               FILDAT	=	$0241	;1-byte right fill data
000000r 2               DSPFLG	=	$0242	;1-byte control character display flag (0 = no)
000000r 2               SSFLAG	=	$0243	;1-byte start/stop flag (0 = not stopped)
000000r 2               
000000r 2               SUPERF	=	$0244	;1-byte editor super function flag :
000000r 2               ;DERRF	=	$0245	;1-byte screen OPEN error flag (0 = not)
000000r 2               
000000r 2               skipone	=	$0246	;1-byte
000000r 2               extended=	$0247	;1-byte
000000r 2               ADRCNT	=	$0248	;1-byte counter for setaddress
000000r 2               
000000r 2               IRQVEC	=	$0249	;2-byte
000000r 2               NMIVEC	=	$024B	;2-byte
000000r 2               jmpind	=	$024D	;1-byte $4C = JMP
000000r 2               jmpptr	=	$024E	;2-byte
000000r 2               DBUFLO	=	$0250	;2-byte ;2-byte adr of 512-byte buffer for SD CARD read/Write
000000r 2               sdcmd	=	$0252	;1-byte SD card command
000000r 2               sdadr	=	$0253	;4-byte SD card address
000000r 2               sdchk	=	$0257	;1-byte SD card checksum
000000r 2               sdres	=	$0258	;1-byte SD card R1 result
000000r 2               sddebug =	$0259	;1-byte SD card debug flag
000000r 2               FVEC	=	$025A	;2-byte executable file start vector
000000r 2               FINIT	=	$025C	;2-byte executable file init vector
000000r 2               JSLOP	=	$025E	;1-byte JSL-opcode
000000r 2               JSLADR	=	$025F	;3-byte JSL address
000000r 2               JSLRTS	=	$0262	;1-byte RTS-opcode
000000r 2               JMLOP	=	$0263	;1-byte JML-opcode
000000r 2               JMLADR	=	$0264	;3-byte JML address
000000r 2               DEVSTAT	=	$0269	;4-byte device status
000000r 2               SERCNT0	= 	$026D	;1-byte RS232 0 control bits
000000r 2               SERCNT1	= 	$026E	;1-byte RS232 1 control bits
000000r 2               CONST5MS=	$026F	;2-byte timer const
000000r 2               MSTATE	=	$0270	;1-byte state of mouse protocol (0,1,2)
000000r 2               MPOSX	=	$0271	;2-byte mouse x-pos
000000r 2               MPOSY	=	$0273	;2-byte mouse y-pos
000000r 2               MDXDY	=	$0275	;1-byte mouse 1st byte of protocol
000000r 2               MONACT	=	$027B	;4-byte break-monitor active flags
000000r 2               
000000r 2               IOCBSTRT=	$0280		;start of IOCB
000000r 2               IOCB	=	IOCBSTRT + $0	;128-byte I/O control blocks area
000000r 2               ICHID	=	IOCBSTRT + $0	;1-byte handler ID ($FF = free)
000000r 2               ICDNO	=	IOCBSTRT + $1	;1-byte device number
000000r 2               ICCOM	=	IOCBSTRT + $2	;1-byte command code
000000r 2               ICSTA	=	IOCBSTRT + $3	;1-byte status of last action
000000r 2               ICBAL	=	IOCBSTRT + $4	;1-byte low buffer address
000000r 2               ICBAH	=	IOCBSTRT + $5	;1-byte high buffer address
000000r 2               ICBAB	=	IOCBSTRT + $6	;1-byte bank buffer address
000000r 2               ICBLL	=	IOCBSTRT + $7	;1-byte low buffer length
000000r 2               ICBLH	=	IOCBSTRT + $8	;1-byte high buffer length
000000r 2               ICBLB	=	IOCBSTRT + $9	;1-byte bank buffer length
000000r 2               ICAX1	=	IOCBSTRT + $A	;1-byte first auxiliary information
000000r 2               ICAX2	=	IOCBSTRT + $B	;1-byte second auxiliary information
000000r 2               ICSPR	=	IOCBSTRT + $C	;4-byte work area
000000r 2               ;ICPTL	=	IOCBSTRT + $6	;1-byte low PUT-BYTE routine address-1
000000r 2               ;ICPTH	=	IOCBSTRT + $7	;1-byte high PUT-BYTE routine address-1
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 3
000000r 2               ;--------------------------------------------------------------
000000r 2               HATABS	=	$0300	;12 * 3-byte entries for HATABS
000000r 2               ;MONTAB	=	$0324	;8-byte break-monitor pointer
000000r 2               flags	=	$032C	;1-byte processor flags during IRQ
000000r 2               IRQPS2S	=	$032D	;1-byte PS2-status from IRQ
000000r 2               IRQPS2D =	$032E	;1-byte PS2-data from IRQ
000000r 2               DEVICS	=	$032F	;1-byte DEVICENO SAVE
000000r 2               BRKBRA	=	$0330	;1-byte branch opcode
000000r 2               BRKOFF	=	$0331	;1-byte branch offset (always 3)
000000r 2               BRKNOT	=	$0332	;1-byte jmp branch not taken (always $4c)
000000r 2               BRKJMP0	=	$0333	;2-byte jmp address branch not taken
000000r 2               BRKTAK	=	$0335	;1-byte jmp branch taken (always $4c)
000000r 2               BRKJMP1	=	$0336	;2-byte jmp address branch taken
000000r 2               BRKVEC	=	$0338	;2-byte BRK vector (65816)
000000r 2               WARMFLAG=	$033A	;1-byte Warmstart = $CA
000000r 2               ARGC	=	$033B	;2-byte number of args
000000r 2               ARGV	=	$033D	;8*2-bytes pointer to arg strings
000000r 2               NCODE	= 	$034D	;1-byte NEXT CODE TO BE TRACED
000000r 2               OPCREG	=	$034E	;3-byte OLD PROGRAM COUNTER VALUE
000000r 2               OPCREGH	=	$034F
000000r 2               OPCREGB	=	$0350
000000r 2               CODE	=	$0351	;1-byte CURRENT CODE TO BE TRACED
000000r 2               OPRNDL	=	$0352	;3-byte OPERANDS OF CURRENT INSTRUCTION
000000r 2               OPRNDH	=	$0353
000000r 2               OPRNDB	=	$0354
000000r 2               ADDRMODE=	$0355	; ADDRESS MODE OF CURRENT OPCODE
000000r 2               
000000r 2               MNX	=	$0356 	;2-byte MNEMONIC INDEX
000000r 2                                       ; FROM ATTRIBUTE TABLE
000000r 2               OPLEN 	=	$0358   ;1-byte LENGTH OF OPERATION,
000000r 2                                       ; INCLUDING INSTRUCTION
000000r 2               MOVENEG	=	$0359	;4-byte MVP + operands + RTS
000000r 2               MOVEBNK	=	$035A
000000r 2               MOVERTS	=	$035C	;RTS
000000r 2               
000000r 2               MODBASE	=	$035D	;2-byte base for next module to be loaded
000000r 2               
000000r 2               MONTAB	=	$0360	;4*4-byte break-monitor pointer
000000r 2               
000000r 2               COLCNT	=	$0370	;
000000r 2               COPVEC	=	$0371	;2-byte COP vector
000000r 2               
000000r 2               MOUSEX	=	$0373	;2-byte Mouse-X
000000r 2               MOUSEY	=	$0375	;2-byte Mouse-Y
000000r 2               MOUBUT	=	$0377	;Mouse-Button Bit7:links, Bit6:rechts
000000r 2               
000000r 2               NEXTFRE	=	$0378	;
000000r 2               
000000r 2               FNAME	= 	$0380	;128-byte buffer for line
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 4
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MC6845 graphics
000000r 2               ;--------------------------------------------------------------
000000r 2               crtadr		= $B800
000000r 2               crtdata		= $B801
000000r 2               
000000r 2               crtcol0		= $B880
000000r 2               crtcol1		= $B881
000000r 2               crtcol2		= $B882
000000r 2               crtcol3		= $B883
000000r 2               crtcolb		= crtcol3
000000r 2               
000000r 2               crtcntl		= $B8C0
000000r 2               crtirq		= $B8C1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MOS6551 serial card
000000r 2               ;--------------------------------------------------------------
000000r 2               ;data6551	= $DB00
000000r 2               ;status6551	= $DB01
000000r 2               ;command6551	= $DB02
000000r 2               ;control6551	= $DB03
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew YM2612 registers
000000r 2               ;--------------------------------------------------------------
000000r 2               YMADR0		= $BFB0
000000r 2               YMDAT0		= $BFB1
000000r 2               YMADR1		= $BFB2
000000r 2               YMDAT1		= $BFB3
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew	Memory Control
000000r 2               ;--------------------------------------------------------------
000000r 2               MEMCNTL		= $BFC0
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew PS2-keyboard and SD-Card
000000r 2               ;--------------------------------------------------------------
000000r 2               PS2		= IO + $D0
000000r 2               PS2DATA		= PS2 + 0	; keyboard scancode
000000r 2               PS2STATUS	= PS2 + 1	; read: Bit0 = 0 scancode available
000000r 2               SPIDATA		= PS2 + 2	; read: Bit0 serial data in, write: Bit7 serial data out
000000r 2               SPIMOSI		= PS2 + 3	; write: Bit0: 1 = Mosi always 1, Bit1: write: CS of SDCard
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew Centronics 8-bit latch
000000r 2               ;--------------------------------------------------------------
000000r 2               CENTRONICS	= $BFE0
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MC68681 double serial card
000000r 2               ;--------------------------------------------------------------
000000r 2               SB		= $BFF0
000000r 2               
000000r 2               MODEA		= 0
000000r 2               STATA		= 1
000000r 2               CLOCKA		= 1
000000r 2               COMMA		= 2
000000r 2               RECA		= 3
000000r 2               TRANSA		= 3
000000r 2               IPCHANGE	= 4
000000r 2               AUXCTRL		= 4
000000r 2               ISR		= 5
000000r 2               IMR		= 5
000000r 2               CNTMSB		= 6
000000r 2               CNTLSB		= 7
000000r 2               MODEB		= 8
000000r 2               STATB		= 9
000000r 2               CLOCKB		= 9
000000r 2               COMMB		= 10
000000r 2               RECB		= 11
000000r 2               TRANSB		= 11
000000r 2               IVR		= 12
000000r 2               INPORT		= 13
000000r 2               OPCTRL		= 13
000000r 2               STRTCNT		= 14
000000r 2               OPSET		= 14
000000r 2               STOPCNT		= 15
000000r 2               OPRES		= 15
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 6502 CPU vectors
000000r 2               ;--------------------------------------------------------------
000000r 2               NMI		= $FFFA
000000r 2               RESET		= $FFFC
000000r 2               IRQ		= $FFFE
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; FPGA misc. stuff
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; RESET, TIMER, HARDWARE MULT.
000000r 2               ;--------------------------------------------------------------
000000r 2               SOFTRESET	= IO + $80
000000r 2               TIMERLO 	= IO + $81
000000r 2               TIMERHI		= IO + $82
000000r 2               TIMERST		= IO + $83
000000r 2               WORDLO		= IO + $84
000000r 2               WORDHI		= IO + $85
000000r 2               DOTS		= IO + $86
000000r 2               
000000r 2               CCONST5MS	= 62400-1
000000r 2               ;--------------------------------------------------------------
000000r 2               ; SPI SD-card interface
000000r 2               ;--------------------------------------------------------------
000000r 2               SPI		= IO + $90
000000r 2               SPICNTL		= SPI
000000r 2               SPISS		= SPI + 1
000000r 2               SPIDAT		= SPI + 2
000000r 2               SPISTAT		= SPI + 3
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 16450 ACIA registers (Uart1, Mouse)
000000r 2               ;--------------------------------------------------------------
000000r 2               ACIA1		= IO + $A0
000000r 2               RBR1		= ACIA1
000000r 2               THR1		= ACIA1
000000r 2               IER1		= ACIA1 + 1
000000r 2               IIR1		= ACIA1 + 2
000000r 2               LCR1		= ACIA1 + 3
000000r 2               MCR1		= ACIA1 + 4
000000r 2               LSR1		= ACIA1 + 5
000000r 2               MSR1		= ACIA1 + 6
000000r 2               SCR1		= ACIA1 + 7
000000r 2               DLL1		= ACIA1
000000r 2               DLM1		= ACIA1 + 1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; graphics system
000000r 2               ;--------------------------------------------------------------
000000r 2               DISP			= $FFFE00
000000r 2               colorBorderLo		= DISP + 0
000000r 2               colorBorderHi		= DISP + 1
000000r 2               colorBackgroundLo	= DISP + 2
000000r 2               colorBackgroundHi	= DISP + 3
000000r 2               color00Lo		= DISP + 4
000000r 2               color00Hi		= DISP + 5
000000r 2               screenBaseLo		= DISP + 6
000000r 2               screenBaseHi		= DISP + 7
000000r 2               screenBaseBank		= DISP + 8
000000r 2               control			= DISP + 9
000000r 2               cursorLo		= DISP + 10
000000r 2               cursorHi		= DISP + 11
000000r 2               rasterLo		= DISP + 12
000000r 2               rasterHi		= DISP + 13
000000r 2               dispStatus		= DISP + 14
000000r 2               vcountLo		= DISP + 15
000000r 2               vcountHi		= DISP + 16
000000r 2               ;spriteBaseLo		= DISP + 17
000000r 2               ;spriteBaseHi		= DISP + 18
000000r 2               spriteBaseBank		= DISP + 19
000000r 2               spriteCntl		= DISP + 20
000000r 2               sprite0addr		= DISP + 21
000000r 2               sprite1addr             = DISP + 22
000000r 2               sprite2addr             = DISP + 23
000000r 2               sprite3addr             = DISP + 24
000000r 2               sprite4addr             = DISP + 25
000000r 2               sprite5addr             = DISP + 26
000000r 2               sprite6addr             = DISP + 27
000000r 2               sprite7addr             = DISP + 28
000000r 2               xpos0			= DISP + 32
000000r 2               xpos1			= DISP + 33
000000r 2               xpos2			= DISP + 34
000000r 2               xpos3			= DISP + 35
000000r 2               xpos4			= DISP + 36
000000r 2               xpos5			= DISP + 37
000000r 2               xpos6			= DISP + 38
000000r 2               xpos7			= DISP + 39
000000r 2               xposHi			= DISP + 40
000000r 2               
000000r 2               palette 		= $FFFC00
000000r 2               spritePalette		= $FFFE40
000000r 2               sprite0			= $7E0000
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 16450 ACIA registers (Uart0)
000000r 2               ;--------------------------------------------------------------
000000r 2               ACIA0		= IO + $E0
000000r 2               RBR0		= ACIA0
000000r 2               THR0		= ACIA0
000000r 2               IER0		= ACIA0 + 1
000000r 2               IIR0		= ACIA0 + 2
000000r 2               LCR0		= ACIA0 + 3
000000r 2               MCR0		= ACIA0 + 4
000000r 2               LSR0		= ACIA0 + 5
000000r 2               MSR0		= ACIA0 + 6
000000r 2               SCR0		= ACIA0 + 7
000000r 2               DLL0		= ACIA0
000000r 2               DLM0		= ACIA0 + 1
000000r 2               
000000r 2               SECPTRLO	= ACIA0 + 8
000000r 2               SECPTRHI	= ACIA0 + 9
000000r 2               READWRITE	= ACIA0 + 10
000000r 2               BUFPTRLO	= ACIA0 + 11
000000r 2               BUFPTRHI	= ACIA0 + 12
000000r 2               
000000r 2               
000000r 1               
000000r 1                	.IF PLATFORM <= 1
000000r 1               		.include "myos.inc"
000000r 2               MYOS		= $C000
000000r 2               JMYOSSTART	= MYOS + $00
000000r 2               JREADSECTOR	= MYOS + $03
000000r 2               JSETSECTOR	= MYOS + $06
000000r 2               JWRITESECTOR	= MYOS + $09
000000r 2               JSDINIT		= MYOS + $0C
000000r 2               CIOV		= MYOS + $0F
000000r 2               JSTARTUP	= MYOS + $12
000000r 2               JPRINT		= MYOS + $15
000000r 2               JPUTHEX		= MYOS + $18
000000r 2               JPRINTSTR	= MYOS + $1B
000000r 2               JINITFAT	= MYOS + $1E
000000r 2               CIOV24		= MYOS + $21
000000r 2               
000000r 1               		.include "fat16.inc"
000000r 2               ;
000000r 2               ; PLATFORM = 0 : Homebrew FPGA
000000r 2               ; PLATFORM = 1 : Homebrew Hardware
000000r 2               ; PLATFORM = 2 : Atari XL/XE
000000r 2               ; PLATFORM = 3 : my65816 FPGA
000000r 2               ;
000000r 2               ;
000000r 2               ; FAT-16 defines
000000r 2               ;
000000r 2               DRVCHAR		= 'D'
000000r 2               
000000r 2               	.IF PLATFORM <= 1
000000r 2               FATPTRS		= $0006
000000r 2               FATPTRD		= $0008
000000r 2               	.ELSE
000000r 2               FATPTRS		= $0000
000000r 2               FATPTRD		= $0002
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Memory Setup
000000r 2               ;--------------------------------------------------------------
000000r 2               	.IF PLATFORM <= 1
000000r 2               VBASE		= $400
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;	.IF PLATFORM = 3
000000r 2               ;VBASE		= $400
000000r 2               ;	.ENDIF
000000r 2               
000000r 2               	.IF PLATFORM = 2
000000r 2               VBASE		= $700
000000r 2               FATCODE		= VBASE+$600
000000r 2               DUPCODE		= $1C00
000000r 2               
000000r 2               JSTARTUP	= FATCODE
000000r 2               JPRINT		= FATCODE+3
000000r 2               JPUTHEX		= FATCODE+6
000000r 2               JPRINTSTR	= FATCODE+9
000000r 2               JINITFAT	= FATCODE+12
000000r 2               	.ENDIF
000000r 2               
000000r 2               V		= VBASE
000000r 2               BUFFER		= VBASE+$200
000000r 2               FATBUF		= VBASE+$400
000000r 2               
000000r 2               CRENAME		= 32
000000r 2               CDELETE		= 33
000000r 2               CCREDIR		= 34
000000r 2               CFSTAT		= 40
000000r 2               CCHADIR		= 41
000000r 2               
000000r 2               DEL		= $E5
000000r 2               EOF		= $88
000000r 2               
000000r 2               SECCLUS		= V+0		;1
000000r 2               RESSEC		= V+1		;2
000000r 2               NUMFATS		= V+3		;1
000000r 2               NUMDIR		= V+4		;2
000000r 2               NUMSECS		= V+6		;2
000000r 2               MEDIA		= V+8		;1
000000r 2               SECSFAT		= V+9		;2
000000r 2               FCBCODE		= V+11 		;1
000000r 2               
000000r 2               SECTOR		= V+12		;4
000000r 2               FATBASE		= V+16		;4
000000r 2               DIRBASE		= V+20		;4
000000r 2               DATBASE		= V+24		;4
000000r 2               LASTSEC		= V+28		;4
000000r 2               LASTFAT		= V+32		;4
000000r 2               BYTCLUS		= V+36 		;4
000000r 2               
000000r 2               BIN		= V+40 		;4
000000r 2               BCD		= V+44 		;5
000000r 2               DECIMAL		= V+49 		;10
000000r 2               
000000r 2               NEWCLUS		= V+59		;2
000000r 2               DDIRTY		= V+61 		;1
000000r 2               FDIRTY		= V+62 		;1
000000r 2               BUFADRL		= V+63 		;1
000000r 2               BUFADRH		= V+64 		;1
000000r 2               
000000r 2               DIRCLUS		= V+65		;2
000000r 2               DIRRENA		= V+67 		;11
000000r 2               
000000r 2               NODISPL		= V+78 		;1
000000r 2               WILD		= V+79 		;1
000000r 2               DIRLINE		= V+80 		;13
000000r 2               DIRLENG		= V+93 		;10
000000r 2               DIREOF		= V+103 	;1
000000r 2               SAVEY		= V+104		;1
000000r 2               VALIDS		= V+105		;1-byte number of specials chars to check for
000000r 2               HILF		= V+106		;1-byte aux usage
000000r 2               ASTART		= V+107		;2-byte file load start vector
000000r 2               AEND		= V+109		;2-byte file load end vector
000000r 2               CNT		= V+111		;1-byte adress enter counter DUP
000000r 2               FHEADER		= V+112		;2-byte save file header ($FF)
000000r 2               FSTART		= V+114		;2-byte file load start vector save
000000r 2               FEND		= V+116		;2-byte file load end vector save
000000r 2               FSTARTS		= V+118		;2-byte file load start vector save
000000r 2               FENDS		= V+120		;2-byte file load end vector save
000000r 2               FDIFF		= V+122		;2-byte "into" difference save
000000r 2               JMPIND		= V+124		;1-byte holding $4C for JMP
000000r 2               JMPPTR		= V+125		;2-byte jmp address
000000r 2               
000000r 2               F		= V+127
000000r 2               
000000r 2               FIOCBNR		= F		;1-byte FCB is assigned to this IOCB
000000r 2               FFCBOFF		= F+1		;1-byte Offset of this FCB from FCB0
000000r 2               FSTRTCL		= F+2		;2-byte Start cluster of file
000000r 2               FILELEN		= F+4		;4-byte length of file
000000r 2               FWBURST		= F+8		;1-byte write burst 0=OFF, other=ON
000000r 2               FBURST		= F+9		;1-byte flag indicating burst read ($FF = slow)
000000r 2               FRPOS		= F+10		;4-byte bytes already read
000000r 2               FVAR32		= F+14		;4-byte 32-bit general var
000000r 2               FCURCLUS	= F+18		;4-byte current cluster
000000r 2               FCURSEC		= F+22		;1-byte current sector
000000r 2               FCURPTR		= F+23 		;2-byte current pointer into sector buffer
000000r 2               FSECTOR		= F+25 		;4-byte last sector read
000000r 2               
000000r 2               DIRTEXT		= F+29		;11-byte directory text 8 + 3
000000r 2               DIRPTR		= F+40		;2-byte pointer into directory sector
000000r 2               DIRSEC		= F+42		;4-byte directory sector
000000r 2               DIRFILE		= F+46		;1-byte dir or file to search for
000000r 2               FBLKEND		= F+46
000000r 2               
000000r 2               FCB0		= V+256
000000r 2               FCB1		= FCB0+64
000000r 2               FCB2		= FCB1+64
000000r 2               FCB3		= FCB2+64
000000r 2               
000000r 2               DNAME		= 0
000000r 2               DEXT		= 8
000000r 2               DATTRIB		= 11
000000r 2               DCLUS		= $1A
000000r 2               DLEN		= $1C
000000r 2               PART1		= $1C6
000000r 2               
000000r 1               		.A8
000000r 1               		.I8
000000r 1               		.smart
000000r 1               	.ENDIF
000000r 1               		.org	ROMSTART
00E000  1               
00E000  1  4C 94 E2     		jmp	kernel
00E003  1  4C 78 E1     		jmp	chrin
00E006  1  4C 9F E1     		jmp	chrout
00E009  1  4C 4C E1     		jmp	print
00E00C  1  4C 2F E1     		jmp	printhex
00E00F  1  4C 0F E1     		jmp	getupper
00E012  1  4C EA E0     		jmp	gethex
00E015  1  4C DF E0     		jmp	getadr
00E018  1  4C 22 E1     		jmp	newline
00E01B  1  4C 27 E1     		jmp	space
00E01E  1  4C 58 E0     		jmp	hexdownload
00E021  1  4C 24 E5     		jmp	memdump
00E024  1  4C 68 E6     		jmp	inputhex
00E027  1  4C 55 E6     		jmp	changemem
00E02A  1  4C E1 E5     		jmp	fillmem
00E02D  1  4C 0A E6     		jmp	fill
00E030  1  6C 4B 02     		jmp	(NMIVEC)
00E033  1  6C 49 02     		jmp	(IRQVEC)
00E036  1  6C 38 03     		jmp	(BRKVEC)
00E039  1  4C 89 E6     		jmp	time
00E03C  1  4C 4A E3     		jmp	menu
00E03F  1  4C 6B EA     		jmp	disass
00E042  1  4C 6E EA     		jmp	DISSone
00E045  1  4C D9 F7     		jmp	RS232V
00E048  1  4C FD E4     		jmp	setaddress
00E04B  1  4C 30 E5     		jmp	memdump16
00E04E  1  20 F4 E7     		jsr	KGBIRQ
00E051  1  6B           		rtl
00E052  1  4C 51 EA     		jmp	disass24
00E055  1  6C 71 03     		jmp	(COPVEC)
00E058  1               
00E058  1               ;
00E058  1               ;
00E058  1               ;
00E058  1               	.IF 1=0
00E058  1               compare:	sei
00E058  1               		lda	DEVICNO
00E058  1               		pha
00E058  1               		stz	DEVICNO
00E058  1               		ldx	#<MSGCOMP
00E058  1               		ldy	#>MSGCOMP
00E058  1               		jsr	print
00E058  1               
00E058  1               compare1:	jsr	getbyte		; wait for leading ":"
00E058  1               		cmp	#':'
00E058  1               		bne	compare1
00E058  1               
00E058  1               		stz	chksum
00E058  1               
00E058  1               		jsr	gethex		; number of bytes in line
00E058  1               		tax
00E058  1               		jsr	getadr		; addess in ptr
00E058  1               		jsr	gethex		; record-type 0=data record
00E058  1               		bne	compare3
00E058  1               
00E058  1               		tay			; A = 0!
00E058  1               compare2:	jsr	gethex		; read byte
00E058  1               		cmp	(ptr),y		; compare at address
00E058  1               		bne	compare4	; not equal -> error
00E058  1               		iny
00E058  1               		dex			; decement length
00E058  1               		bne	compare2	; line not completely read
00E058  1               
00E058  1               		jsr	gethex		; line finished
00E058  1               		lda	chksum		; read checksum
00E058  1               		beq	compare1	; checksum OK, next line
00E058  1               compare4:	jsr	debug		; print debug
00E058  1               		jmp	compare1	; read next line
00E058  1               
00E058  1               compare3:	jsr	jtime		; read last checksum and return
00E058  1               		ldx	#<MSGFINISH
00E058  1               		ldy	#>MSGFINISH
00E058  1               		jsr	print
00E058  1               
00E058  1               		pla
00E058  1               		sta	DEVICNO
00E058  1               		cli
00E058  1               		rts
00E058  1               
00E058  1               MSGCOMP:	.byte	"comparing...",EOL,0
00E058  1               
00E058  1               	.ENDIF
00E058  1               
00E058  1               ;
00E058  1               ;
00E058  1               ;
00E058  1  78           hexdownload:	sei
00E059  1  A5 10        		lda	DEVICNO
00E05B  1  48           		pha
00E05C  1  A9 00        		lda	#0
00E05E  1  85 10        		sta	DEVICNO
00E060  1  A2 C0        		ldx	#<MSGDOWNL
00E062  1  A0 E0        		ldy	#>MSGDOWNL
00E064  1  20 4C E1     		jsr	print
00E067  1               
00E067  1  20 1F E1     download:	jsr	getbyte		; wait for leading ":"
00E06A  1  C9 3A        		cmp	#':'
00E06C  1  D0 F9        		bne	download
00E06E  1               
00E06E  1  A9 00        		lda	#0
00E070  1  85 05        		sta	chksum
00E072  1               
00E072  1  20 EA E0     		jsr	gethex		; number of bytes in line
00E075  1  AA           		tax
00E076  1  20 DF E0     		jsr	getadr		; addess in ptr
00E079  1  20 EA E0     		jsr	gethex		; record-type 0=data record
00E07C  1  D0 17        		bne	download1
00E07E  1               
00E07E  1  A8           		tay			; A = 0!
00E07F  1  20 EA E0     download2:	jsr	gethex		; read byte
00E082  1  91 00        		sta	(ptr),y		; store at address
00E084  1  C8           		iny
00E085  1  CA           		dex			; decement length
00E086  1  D0 F7        		bne	download2	; line not completely read
00E088  1               
00E088  1  20 EA E0     		jsr	gethex		; line finished
00E08B  1  A5 05        		lda	chksum		; read checksum
00E08D  1  F0 D8        		beq	download	; checksum OK, next line
00E08F  1  20 AB E0     		jsr	debug		; print debug
00E092  1  4C 67 E0     		jmp	download	; read next line
00E095  1               
00E095  1  20 39 E0     download1:	jsr	jtime		; read last checksum and return
00E098  1  A2 D0        		ldx	#<MSGFINISH
00E09A  1  A0 E0        		ldy	#>MSGFINISH
00E09C  1  20 4C E1     		jsr	print
00E09F  1               
00E09F  1  68           		pla
00E0A0  1  85 10        		sta	DEVICNO
00E0A2  1               
00E0A2  1               ;		jsr	chrin
00E0A2  1               ;		jsr	chrin
00E0A2  1               
00E0A2  1               	.IF PLATFORM = 0
00E0A2  1  A9 80        reset:		lda	#$80
00E0A4  1  8F 80 FF FF  		sta	SOFTRESET
00E0A8  1  4C 94 E2     		jmp	kernel
00E0AB  1               ;		stz	RESET
00E0AB  1               	.ENDIF
00E0AB  1               
00E0AB  1               	.IF PLATFORM = 1
00E0AB  1               reset:		lda	SB+COMMA
00E0AB  1               		jmp	kernel
00E0AB  1               	.ENDIF
00E0AB  1               
00E0AB  1               
00E0AB  1  A5 01        debug:		lda	ptr+1
00E0AD  1  20 2F E1     		jsr	printhex
00E0B0  1  A5 00        		lda	ptr
00E0B2  1  20 2F E1     		jsr	printhex
00E0B5  1  20 27 E1     		jsr	space
00E0B8  1  A5 05        		lda	chksum
00E0BA  1  20 2F E1     		jsr	printhex
00E0BD  1  4C 22 E1     		jmp	newline
00E0C0  1               
00E0C0  1  64 6F 77 6E  MSGDOWNL:	.byte	"downloading...",EOL ,0
00E0C4  1  6C 6F 61 64  
00E0C8  1  69 6E 67 2E  
00E0D0  1  2E 2E 2E 20  MSGFINISH:	.byte	"... finished.", EOL ,0
00E0D4  1  66 69 6E 69  
00E0D8  1  73 68 65 64  
00E0DF  1               ;
00E0DF  1               ;
00E0DF  1               ;
00E0DF  1  20 EA E0     getadr:		jsr	gethex
00E0E2  1  85 01        		sta	ptr+1
00E0E4  1  20 EA E0     		jsr	gethex
00E0E7  1  85 00        		sta	ptr
00E0E9  1  60           		rts
00E0EA  1               
00E0EA  1  20 02 E1     gethex:		jsr	getnibble
00E0ED  1  0A           		asl
00E0EE  1  0A           		asl
00E0EF  1  0A           		asl
00E0F0  1  0A           		asl
00E0F1  1  85 15        		sta	gethex_A
00E0F3  1  20 02 E1     		jsr	getnibble
00E0F6  1  05 15        		ora	gethex_A
00E0F8  1  85 15        		sta	gethex_A
00E0FA  1               
00E0FA  1  18           		clc
00E0FB  1  65 05        		adc	chksum
00E0FD  1  85 05        		sta	chksum
00E0FF  1  A5 15        		lda	gethex_A
00E101  1  60           		rts
00E102  1               
00E102  1  20 0F E1     getnibble:	jsr	getupper
00E105  1  38           		sec
00E106  1  E9 30        		sbc	#48
00E108  1  C9 0A        		cmp	#10
00E10A  1  90 02        		bcc	getnibble1
00E10C  1  E9 07        		sbc	#7
00E10E  1  60           getnibble1:	rts
00E10F  1               
00E10F  1  20 1F E1     getupper:	jsr	getbyte
00E112  1  C9 61        		cmp	#97
00E114  1  B0 01        		bcs	getupper1
00E116  1  60           		rts
00E117  1  C9 7B        getupper1:	cmp	#123
00E119  1  90 01        		bcc	getupper2
00E11B  1  60           		rts
00E11C  1  E9 1F        getupper2:	sbc	#31
00E11E  1  60           		rts
00E11F  1               
00E11F  1  4C 78 E1     getbyte:	jmp	chrin
00E122  1               
00E122  1  48           newline:	pha
00E123  1  A9 0A        		lda	#EOL
00E125  1  D0 03        		bne	space1
00E127  1               
00E127  1  48           space:		pha
00E128  1  A9 20        		lda	#32
00E12A  1               
00E12A  1  20 9F E1     space1:		jsr	chrout
00E12D  1  68           		pla
00E12E  1  60           		rts
00E12F  1               
00E12F  1  48           printhex:	pha
00E130  1  48           		pha
00E131  1  4A           		lsr
00E132  1  4A           		lsr
00E133  1  4A           		lsr
00E134  1  4A           		lsr
00E135  1  20 40 E1     		jsr	printnibble
00E138  1  68           		pla
00E139  1  29 0F        		and	#15
00E13B  1  20 40 E1     		jsr	printnibble
00E13E  1  68           		pla
00E13F  1  60           		rts
00E140  1               
00E140  1  18           printnibble:	clc
00E141  1  69 30        		adc	#48
00E143  1  C9 3A        		cmp	#58
00E145  1  90 02        		bcc	printnibble1
00E147  1  69 06        		adc	#6
00E149  1  4C 9F E1     printnibble1:	jmp	chrout
00E14C  1               
00E14C  1  48           print:		pha
00E14D  1  8A           		txa
00E14E  1  48           		pha
00E14F  1  98           		tya
00E150  1  48           		pha
00E151  1  A5 00        		lda	ptr
00E153  1  48           		pha
00E154  1  A5 01        		lda	ptr+1
00E156  1  48           		pha
00E157  1               
00E157  1  86 00        		stx	ptr
00E159  1  84 01        		sty	ptr+1
00E15B  1  A0 00        		ldy	#0
00E15D  1  B1 00        print2:		lda	(ptr),y
00E15F  1  F0 0B        		beq	print1
00E161  1  20 9F E1     		jsr	chrout
00E164  1  E6 00        		inc	ptr
00E166  1  D0 F5        		bne	print2
00E168  1  E6 01        		inc	ptr+1
00E16A  1  D0 F1        		bne	print2
00E16C  1               
00E16C  1  68           print1:		pla
00E16D  1  85 01        		sta	ptr+1
00E16F  1  68           		pla
00E170  1  85 00        		sta	ptr
00E172  1  68           		pla
00E173  1  A8           		tay
00E174  1  68           		pla
00E175  1  AA           		tax
00E176  1  68           		pla
00E177  1  60           		rts
00E178  1               
00E178  1               chrin:
00E178  1  A5 10        		lda	DEVICNO
00E17A  1  F0 16        		beq	uart0in
00E17C  1               
00E17C  1  8A           		txa
00E17D  1  48           		pha
00E17E  1  98           		tya
00E17F  1  48           		pha
00E180  1               
00E180  1  A2 70        		ldx	#$70
00E182  1  A9 07        		lda	#GETCHR
00E184  1  9D 82 02     		sta	ICCOM,x
00E187  1  20 0F C0     		jsr	CIOV
00E18A  1               ;		sta	CIOCHR
00E18A  1               
00E18A  1  68           		pla
00E18B  1  A8           		tay
00E18C  1  68           		pla
00E18D  1  AA           		tax
00E18E  1  A5 2F        		lda	CIOCHR
00E190  1  60           		rts
00E191  1               
00E191  1               
00E191  1  4B           KEYBOARD:	.byte "K"
00E192  1               
00E192  1               uart0in:
00E192  1               	.IF PLATFORM=0
00E192  1  AF E5 FF FF  chrin1:		lda	LSR0
00E196  1  29 01        		and	#1
00E198  1  F0 F8        		beq	chrin1
00E19A  1  AF E0 FF FF  		lda	RBR0
00E19E  1               	.ELSE
00E19E  1               ;		lda	#8
00E19E  1               ;chrin1:		bit status6551
00E19E  1               ;		beq	chrin1
00E19E  1               ;		lda	data6551
00E19E  1               		LDA	#1
00E19E  1               chrin1:		BIT	SB+STATA
00E19E  1               		BEQ	chrin1
00E19E  1               		LDA	SB+RECA
00E19E  1               	.ENDIF
00E19E  1  60           		rts
00E19F  1               
00E19F  1  48           chrout:		pha
00E1A0  1               ;		sta	charz
00E1A0  1  A5 10        		lda	DEVICNO
00E1A2  1  F0 04        		beq	uart0out
00E1A4  1  68           		pla
00E1A5  1  4C 15 C0     		jmp	JPRINT
00E1A8  1               
00E1A8  1               uart0out:
00E1A8  1               	.IF PLATFORM=0
00E1A8  1  AF E5 FF FF  chrout1:	lda	LSR0
00E1AC  1  29 40        		and 	#64
00E1AE  1  F0 F8        		beq	chrout1
00E1B0  1  68           		pla
00E1B1  1  8F E0 FF FF  		sta	THR0
00E1B5  1               ;		pha
00E1B5  1               ;		lda	#127
00E1B5  1               ;chrout2:	dea
00E1B5  1               ;		bne	chrout2
00E1B5  1               ;		pla
00E1B5  1               	.ELSE
00E1B5  1               ;		lda	#$10
00E1B5  1               ;chrout1:	bit	status6551
00E1B5  1               ;		beq	chrout1
00E1B5  1               ;		lda	charz
00E1B5  1               ;		sta	data6551
00E1B5  1               		LDA	#4
00E1B5  1               chrout1:	BIT	SB+STATA
00E1B5  1               		BEQ	chrout1
00E1B5  1               		PLA
00E1B5  1               		STA	SB+TRANSA
00E1B5  1               	.ENDIF
00E1B5  1  60           		rts
00E1B6  1               
00E1B6  1               	.IF PLATFORM=99
00E1B6  1               crtout:		tya
00E1B6  1               		pha
00E1B6  1               		ldy	#0
00E1B6  1               		lda	charz
00E1B6  1               		cmp	#EOL
00E1B6  1               		beq	crtout1
00E1B6  1               		sta	(chrpos),y
00E1B6  1               		clc
00E1B6  1               		lda	chrcol
00E1B6  1               		adc	#1
00E1B6  1               		cmp	charsline
00E1B6  1               		bcc	crtincx
00E1B6  1               crtout1:	lda	chrrow
00E1B6  1               		cmp	#24
00E1B6  1               		bcc	crtNoScrol
00E1B6  1               
00E1B6  1               crtNoScrol:	inc	chrrow
00E1B6  1               		lda	#0
00E1B6  1               		sta	chrcol
00E1B6  1               		lda	chrrow
00E1B6  1               		asl
00E1B6  1               		tay
00E1B6  1               		lda	Dcontrol
00E1B6  1               		and	#1
00E1B6  1               		bne	crtNoScrol80
00E1B6  1               		lda	mul40,y
00E1B6  1               		sta	chrpos
00E1B6  1               		clc
00E1B6  1               		lda	mul40+1,y
00E1B6  1               		adc	#>SCRSTRT
00E1B6  1               crtNoScrol1:
00E1B6  1               		sta	chrpos+1
00E1B6  1               		jmp	crtoutEnd
00E1B6  1               
00E1B6  1               crtNoScrol80:	lda	mul80,y
00E1B6  1               		sta	chrpos
00E1B6  1               		clc
00E1B6  1               		lda	mul80+1,y
00E1B6  1               		adc	#>SCRSTRT
00E1B6  1               		jmp	crtNoScrol1
00E1B6  1               
00E1B6  1               crtincx:	inc	chrpos
00E1B6  1               		bne	crtincx1
00E1B6  1               		inc	chrpos+1
00E1B6  1               crtincx1:	inc	chrcol
00E1B6  1               
00E1B6  1               crtoutEnd:	pla
00E1B6  1               		tay
00E1B6  1               		lda	charz
00E1B6  1               		rts
00E1B6  1               
00E1B6  1               crtCls:		lda	#0
00E1B6  1               		tax
00E1B6  1               crtCls1:	sta	SCRSTRT,x
00E1B6  1               		sta	SCRSTRT+$100,x
00E1B6  1               		sta	SCRSTRT+$200,x
00E1B6  1               		sta	SCRSTRT+$300,x
00E1B6  1               		inx
00E1B6  1               		bne	crtCls1
00E1B6  1               
00E1B6  1               		lda	Dcontrol
00E1B6  1               		and	#1
00E1B6  1               		beq	crtCls2
00E1B6  1               
00E1B6  1               		lda	#0
00E1B6  1               crtCls3:	sta	SCRSTRT+$400,x
00E1B6  1               		sta	SCRSTRT+$500,x
00E1B6  1               		sta	SCRSTRT+$600,x
00E1B6  1               		sta	SCRSTRT+$700,x
00E1B6  1               		inx
00E1B6  1               		bne	crtCls3
00E1B6  1               
00E1B6  1               crtCls2:	lda	#0
00E1B6  1               		sta	chrcol
00E1B6  1               		sta	chrrow
00E1B6  1               		sta	chrpos
00E1B6  1               		lda	#>SCRSTRT
00E1B6  1               		sta	chrpos+1
00E1B6  1               		rts
00E1B6  1               
00E1B6  1               mul40:		.word	0*40,1*40,2*40,3*40,4*40,5*40,6*40,7*40
00E1B6  1               		.word	8*40,9*40,10*40,11*40,12*40,13*40,14*40,15*40
00E1B6  1               		.word	16*40,17*40,18*40,19*40,20*40,21*40,22*40,23*40
00E1B6  1               		.word	24*40
00E1B6  1               
00E1B6  1               mul80:		.word	0*80,1*80,2*80,3*80,4*80,5*80,6*80,7*80
00E1B6  1               		.word	8*80,9*80,10*80,11*80,12*80,13*80,14*80,15*80
00E1B6  1               		.word	16*80,17*80,18*80,19*80,20*80,21*80,22*80,23*80
00E1B6  1               		.word	24*80
00E1B6  1               	.ENDIF
00E1B6  1               
00E1B6  1               ;------------------------------------------------------------------
00E1B6  1               ;
00E1B6  1               ;------------------------------------------------------------------
00E1B6  1               mybrk:
00E1B6  1  C2 30        		REP	#M+IX
00E1B8  1               
00E1B8  1  48           		PHA
00E1B9  1  DA           		PHX
00E1BA  1  5A           		PHY
00E1BB  1  8B           		PHB			; 1-byte, SAVE DATA BANK
00E1BC  1  0B           		PHD			; 2-byte, DIRECT PAGE
00E1BD  1               
00E1BD  1  F4 00 00     		PEA	DPAGE		; SWITCH TO APPLICATION
00E1C0  1  2B           		PLD			; DIRECT PAGE
00E1C1  1               
00E1C1  1               					;STACK: DIRECT L 	1	$1f0
00E1C1  1               					;	DIRECT H	2	$1f1
00E1C1  1               					;	DATA BANK	3
00E1C1  1               					;	Y L		4
00E1C1  1               					;	Y H		5
00E1C1  1               					;	X L		6
00E1C1  1               					;	X H		7
00E1C1  1               					;	A L		8
00E1C1  1               					;	A H		9
00E1C1  1               					;	PREGS		10	pushed by BRK intruction
00E1C1  1               					;	PC L		11	pushed by BRK intruction
00E1C1  1               					;	PC H		12	pushed by BRK intruction
00E1C1  1               					;	PROGRAM BANK	13	pushed by BRK intruction
00E1C1  1               					;	RETURN-1 L 	14	e.g. pushed by JSR
00E1C1  1               					;	RETURN-H H 	15
00E1C1  1               
00E1C1  1  4B           		phk			; data bank = program bank
00E1C2  1  AB           		plb
00E1C3  1  A3 0B        		lda	11,S
00E1C5  1               		;dea
00E1C5  1               		;dea
00E1C5  1  83 0B        		sta	11,S
00E1C7  1               
00E1C7  1  85 02        		sta	PCREG
00E1C9  1  8D 4E 03     		sta	OPCREG
00E1CC  1               
00E1CC  1  E2 30        		sep	#M+IX
00E1CE  1  64 10        		stz	DEVICNO
00E1D0  1  A9 41        		lda	#$41
00E1D2  1  20 06 E0     		jsr	jchrout
00E1D5  1               
00E1D5  1  C2 30        		rep	#M+IX
00E1D7  1  2B           		pld
00E1D8  1  AB           		plb
00E1D9  1  7A           		ply
00E1DA  1  FA           		plx
00E1DB  1  68           		pla
00E1DC  1  40           		rti
00E1DD  1               
00E1DD  1               		.a8
00E1DD  1               		.i8
00E1DD  1               
00E1DD  1               
00E1DD  1               copproc:
00E1DD  1  C2 30        		rep	#M+IX
00E1DF  1  48           		pha
00E1E0  1  DA           		phx
00E1E1  1  5A           		phy
00E1E2  1  8B           		phb
00E1E3  1  0B           		phd
00E1E4  1               
00E1E4  1  F4 00 00     		pea	0
00E1E7  1  2B           		pld
00E1E8  1  4B           		phk
00E1E9  1  AB           		plb
00E1EA  1               
00E1EA  1  E2 20        		sep	#M
00E1EC  1  64 10        		stz	DEVICNO
00E1EE  1               
00E1EE  1  A9 41        		lda	#'A'
00E1F0  1  20 89 E2     		jsr	printChar
00E1F3  1  A3 09        		lda	9,s
00E1F5  1  20 0C E0     		jsr	jprinthex
00E1F8  1  A3 08        		lda	8,s
00E1FA  1  20 0C E0     		jsr	jprinthex
00E1FD  1               
00E1FD  1  A9 58        		lda	#'X'
00E1FF  1  20 89 E2     		jsr	printChar
00E202  1  A3 07        		lda	7,s
00E204  1  20 0C E0     		jsr	jprinthex
00E207  1  A3 06        		lda	6,s
00E209  1  20 0C E0     		jsr	jprinthex
00E20C  1               
00E20C  1  A9 59        		lda	#'Y'
00E20E  1  20 89 E2     		jsr	printChar
00E211  1  A3 05        		lda	5,s
00E213  1  20 0C E0     		jsr	jprinthex
00E216  1  A3 04        		lda	4,s
00E218  1  20 0C E0     		jsr	jprinthex
00E21B  1               
00E21B  1  A9 53        		lda	#'S'
00E21D  1  20 89 E2     		jsr	printChar
00E220  1  A9 3D        		lda	#'='
00E222  1  C2 20        		rep	#M
00E224  1  3B           		tsc
00E225  1  18           		clc
00E226  1  69 0D 00     		adc	#13
00E229  1  E2 20        		sep	#M
00E22B  1  EB           		xba
00E22C  1  20 0C E0     		jsr	jprinthex
00E22F  1  EB           		xba
00E230  1  20 0C E0     		jsr	jprinthex
00E233  1               
00E233  1  A9 44        		lda	#'D'
00E235  1  20 89 E2     		jsr	printChar
00E238  1  A3 02        		lda	2,s
00E23A  1  20 0C E0     		jsr	jprinthex
00E23D  1  A3 01        		lda	1,s
00E23F  1  20 0C E0     		jsr	jprinthex
00E242  1               
00E242  1  A9 42        		lda	#'B'
00E244  1  20 89 E2     		jsr	printChar
00E247  1  A3 03        		lda	3,s
00E249  1  20 0C E0     		jsr	jprinthex
00E24C  1               
00E24C  1  A9 50        		lda	#'P'
00E24E  1  20 89 E2     		jsr	printChar
00E251  1  A3 0A        		lda	10,s
00E253  1  20 0C E0     		jsr	jprinthex
00E256  1               
00E256  1  20 1B E0     		jsr	jspace
00E259  1  A3 0D        		lda	13,s
00E25B  1  20 0C E0     		jsr	jprinthex
00E25E  1  A9 2F        		lda	#'/'
00E260  1  20 06 E0     		jsr	jchrout
00E263  1  A3 0C        		lda	12,s
00E265  1  20 0C E0     		jsr	jprinthex
00E268  1  A3 0B        		lda	11,s
00E26A  1  20 0C E0     		jsr	jprinthex
00E26D  1               
00E26D  1  20 1B E0     		jsr	jspace
00E270  1               
00E270  1  A0 00 00     		ldy	#0
00E273  1  A3 0D        		lda	13,s
00E275  1  48           		pha
00E276  1  AB           		plb
00E277  1  B3 0B        		lda	(11,s),y
00E279  1               
00E279  1  20 0C E0     		jsr	jprinthex
00E27C  1               
00E27C  1  20 18 E0     		jsr	jnewline
00E27F  1               
00E27F  1  E6 10        		inc	DEVICNO
00E281  1  C2 30        		rep	#M+IX
00E283  1  2B           		pld
00E284  1  AB           		plb
00E285  1  7A           		ply
00E286  1  FA           		plx
00E287  1  68           		pla
00E288  1  40           		rti
00E289  1               
00E289  1               printChar:	.A8
00E289  1  20 1B E0     		jsr	jspace
00E28C  1  20 06 E0     		jsr	jchrout
00E28F  1  A9 3D        		lda	#'='
00E291  1  4C 06 E0     		jmp	jchrout
00E294  1               ;
00E294  1               ;
00E294  1               ;
00E294  1               kernel:
00E294  1  78           		sei			;interrupt disable
00E295  1  18           		clc
00E296  1  FB           		xce			;switch to native mode
00E297  1               
00E297  1  C2 39        		rep	#M+IX+DECIMAL_FLAG+CARRY	;accu + index = 16bit
00E299  1               		.a16
00E299  1               		.I16
00E299  1               
00E299  1               ;		sec			;emulation mode
00E299  1               ;		xce			;StackHi = $01, M=1, I=1, D=0
00E299  1               
00E299  1  A9 FF 01     		lda	#$01FF
00E29C  1  1B           		tcs			;Stack = $01FF
00E29D  1  A9 00 00     		lda	#$0000
00E2A0  1  5B           		tcd			;Direct = $0000
00E2A1  1               
00E2A1  1  4B           		phk			;push Program-bank
00E2A2  1  AB           		plb			;load in Data-Bank
00E2A3  1               
00E2A3  1  AA           		tax			;x = 0
00E2A4  1  A8           		tay
00E2A5  1  C8           		iny			;y = 1
00E2A6  1               
00E2A6  1  64 00        		stz	$0		;clear $0000 - $07ff
00E2A8  1  A9 FE 06     		lda	#$700-2
00E2AB  1  54 00 00     		mvn	$00,$00		;data bank = 0!
00E2AE  1               
00E2AE  1  A9 17 E7     		lda	#rasterProc
00E2B1  1  8D 0F 02     		sta	RASVEC
00E2B4  1               
00E2B4  1  A9 F4 E6     		lda	#irqproc	;register IRQ-procedure
00E2B7  1  8D 49 02     		sta	IRQVEC
00E2BA  1               
00E2BA  1  A9 AD EC     		lda	#NBRKIN		;register BRK-procedure
00E2BD  1               ;		lda	#mybrk		;register BRK-procedure
00E2BD  1  8D 38 03     		sta	BRKVEC
00E2C0  1               
00E2C0  1  A9 DD E1     		lda	#copproc
00E2C3  1  8D 71 03     		sta	COPVEC
00E2C6  1               
00E2C6  1  A9 BF F3     		lda	#CCONST5MS
00E2C9  1  8D 6F 02     		sta	CONST5MS
00E2CC  1  8F 81 FF FF  		sta	TIMERLO
00E2D0  1               
00E2D0  1  E2 30        		sep	#M+IX		;Accu+Index = 8bit
00E2D2  1               		.a8
00E2D2  1               		.i8
00E2D2  1               
00E2D2  1  A9 01        		lda	#1
00E2D4  1  8F A1 FF FF  		sta	IER1		;enable Mouse interrupt
00E2D8  1  8F 83 FF FF  		sta	TIMERST		;enable Timer interrupt
00E2DC  1               
00E2DC  1               
00E2DC  1               
00E2DC  1               	.IF PLATFORM = 1
00E2DC  1               		stz	MEMCNTL
00E2DC  1               	.ENDIF
00E2DC  1               
00E2DC  1  20 FA E4     		jsr	initacia
00E2DF  1               
00E2DF  1               ;		tsc
00E2DF  1               ;		xba
00E2DF  1               ;		jsr printhex
00E2DF  1               ;		xba
00E2DF  1               ;		jsr printhex
00E2DF  1               
00E2DF  1               
00E2DF  1               ;loop:		lda	#'A'
00E2DF  1               ;		jsr	chrout
00E2DF  1               ;		jsr	time
00E2DF  1               ;		jmp	loop
00E2DF  1               
00E2DF  1  A9 4C        		lda	#$4C		;jmp(...)
00E2E1  1  8D 4D 02     		sta	jmpind
00E2E4  1               
00E2E4  1  A9 54        		lda	#$54		;MVN
00E2E6  1  8D 59 03     		sta	MOVENEG
00E2E9  1  A9 60        		lda	#$60
00E2EB  1  8D 5C 03     		sta	MOVERTS		;RTS
00E2EE  1  A9 00        		lda	#$00
00E2F0  1  85 02        		sta	memptr		;bank = 1
00E2F2  1  A9 00        		lda	#$00
00E2F4  1  85 03        		sta	memptr+1
00E2F6  1  A9 01        		lda	#$01
00E2F8  1  85 04        		sta	memptr+2
00E2FA  1               
00E2FA  1  A9 C0        		lda	#$C0
00E2FC  1  8F 00 FC FF  		sta	$FFFC00
00E300  1  A9 FF        		lda	#$FF
00E302  1  8F FE FD FF  		sta	$FFFDFE
00E306  1               
00E306  1               ;		sta	BRKNOT
00E306  1               ;		sta	BRKTAK
00E306  1               ;		lda	#3
00E306  1               ;		sta	BRKOFF
00E306  1               ;		lda	#<IRQGETC
00E306  1               ;		sta	BRKJMP0
00E306  1               ;		lda	#>IRQGETC
00E306  1               ;		sta	BRKJMP0+1
00E306  1               ;		lda	#<BRATAKEN
00E306  1               ;		sta	BRKJMP1
00E306  1               ;		lda	#>BRATAKEN
00E306  1               ;		sta	BRKJMP1+1
00E306  1               
00E306  1               	.IF PLATFORM <= 1
00E306  1  8D 2D 03     		sta	IRQPS2S		;no key available
00E309  1  AF D0 FF FF  		lda	PS2DATA		;reset key input
00E30D  1               
00E30D  1               
00E30D  1               ;key1:		lda	PS2STATUS	;key available?
00E30D  1               ;		bne	key1		;Bit 0 = 0?, no =>
00E30D  1               ;		lda	PS2DATA
00E30D  1               ;		sta	PS2DATA
00E30D  1               ;		jsr	printhex
00E30D  1               ;		cmp	#$E1
00E30D  1               ;		bne	key1
00E30D  1               	.ENDIF
00E30D  1               
00E30D  1               
00E30D  1               	.IF PLATFORM = 99
00E30D  1               		jsr	JMYOSSTART
00E30D  1               ;		inc	DEVICNO
00E30D  1               		jmp	menustart
00E30D  1               	.ELSE
00E30D  1  AD 00 C0     		lda	JMYOSSTART
00E310  1  C9 4C        		cmp	#$4C		;JMP instructr?
00E312  1  D0 2C        		bne	menustart
00E314  1               		;bra	menustart
00E314  1  20 00 C0     		jsr	JMYOSSTART
00E317  1               	.ENDIF
00E317  1               
00E317  1  A2 70        		ldx	#$70	;open channel 01
00E319  1  A9 03        		lda	#OPEN	;with KEYBOARD
00E31B  1  9D 82 02     		sta	ICCOM,x
00E31E  1  A9 91        		lda	#<KEYBOARD
00E320  1  9D 84 02     		sta	ICBAL,x
00E323  1  A9 E1        		lda	#>KEYBOARD
00E325  1  9D 85 02     		sta	ICBAH,x
00E328  1  A9 04        		lda	#4
00E32A  1  9D 8A 02     		sta	ICAX1,x
00E32D  1  A9 00        		lda	#0
00E32F  1  9D 8B 02     		sta	ICAX2,x
00E332  1  9D 87 02     		sta	ICBLL,x
00E335  1  9D 88 02     		sta	ICBLH,x
00E338  1  20 0F C0     		jsr	CIOV
00E33B  1               
00E33B  1  E6 10        		inc	DEVICNO
00E33D  1               
00E33D  1  58           		cli				;enable IRQ
00E33E  1               
00E33E  1  80 0A        		bra	menu			;accu != 0
00E340  1               
00E340  1               ;		jsr	jtime
00E340  1               
00E340  1  A2 03        menustart:	ldx	#3
00E342  1  A9 0A        		lda	#EOL
00E344  1  20 9F E1     @loop:		jsr	chrout
00E347  1  CA           		dex
00E348  1  D0 FA        		bne	@loop
00E34A  1               
00E34A  1  A2 D4        menu:		ldx	#<MSGSTART
00E34C  1  A0 E3        		ldy	#>MSGSTART
00E34E  1  20 4C E1     		jsr	print
00E351  1               
00E351  1  20 22 E1     menuadr:	jsr	newline
00E354  1  A5 04        		lda	memptr+2
00E356  1  20 2F E1     		jsr	printhex
00E359  1  A9 3A        		lda	#':'
00E35B  1  20 06 E0     		jsr	jchrout
00E35E  1  A5 03        		lda	memptr+1
00E360  1  20 2F E1     		jsr	printhex
00E363  1  A5 02        		lda	memptr
00E365  1  20 2F E1     		jsr	printhex
00E368  1  A9 3E        		lda	#'>'
00E36A  1  20 9F E1     		jsr	chrout
00E36D  1  20 27 E1     		jsr	space
00E370  1               
00E370  1  20 0F E1     menuloop:	jsr	getupper
00E373  1               ;		stz	DEVICNO
00E373  1               ;		jsr	jprinthex
00E373  1               ;		inc	DEVICNO
00E373  1               
00E373  1  A2 0D        		ldx	#menuvec-menukey-1
00E375  1               
00E375  1  DD AA E3     menuloop1:	cmp	menukey,x
00E378  1  F0 06        		beq	menufound
00E37A  1  CA           		dex
00E37B  1  10 F8        		bpl	menuloop1
00E37D  1  4C 51 E3     		jmp	menuadr
00E380  1  8A           menufound:	txa
00E381  1  0A           		asl
00E382  1  AA           		tax
00E383  1  FC B8 E3     		jsr	(menuvec,x)
00E386  1  4C 51 E3     		jmp	menuadr
00E389  1               
00E389  1  A9 22        gotoadr:	lda 	#$22		;JSL opcode
00E38B  1  8D 5E 02     		sta	JSLOP
00E38E  1  A9 60        		lda	#$60
00E390  1  8D 62 02     		sta	JSLRTS
00E393  1               
00E393  1  A5 02        		lda	memptr
00E395  1  8D 5F 02     		sta	JSLADR
00E398  1  A5 03        		lda	memptr+1
00E39A  1  8D 60 02     		sta	JSLADR+1
00E39D  1  A5 04        		lda	memptr+2
00E39F  1  8D 61 02     		sta	JSLADR+2
00E3A2  1               
00E3A2  1               		;wdm	6
00E3A2  1  4C 5E 02     		jmp	JSLOP
00E3A5  1               
00E3A5  1  68           prthelp:	pla
00E3A6  1  68           		pla
00E3A7  1  4C 4A E3     		jmp	menu
00E3AA  1               
00E3AA  1  3F 42 43 44  menukey:	.byte	"?BCDFGKLMNSTV"
00E3AE  1  46 47 4B 4C  
00E3B2  1  4D 4E 53 54  
00E3B7  1               ;		.byte	"T"
00E3B7  1               	.IF PLATFORM <= 1
00E3B7  1  4F           		.byte	"O"
00E3B8  1               	.ENDIF
00E3B8  1               menuvec:
00E3B8  1  A5 E3        		.word	prthelp
00E3BA  1  11 E5        		.word	setdatabank
00E3BC  1  55 E6        		.word	changemem
00E3BE  1  58 E0        		.word	hexdownload
00E3C0  1  E1 E5        		.word	fillmem
00E3C2  1  89 E3        		.word	gotoadr
00E3C4  1  63 EA        		.word	disass16
00E3C6  1  67 EA        		.word	disass8
00E3C8  1  24 E5        		.word	memdump
00E3CA  1  FD E4        		.word	setaddress
00E3CC  1  E8 E4        		.word	setbreak
00E3CE  1  94 E5        		.word	copymem
00E3D0  1  95 F8        		.word	VTL02C
00E3D2  1               ;		.word	compare
00E3D2  1               	.IF PLATFORM <= 1
00E3D2  1  96 F2        		.word	DUPINIT
00E3D4  1               	.ENDIF
00E3D4  1               
00E3D4  1  01           MSGSTART:	.byte	CLS
00E3D5  1  2A 2A 2A 20  		.byte	"*** 6502 Homebrew by R. Scholz", EOL, EOL
00E3D9  1  36 35 30 32  
00E3DD  1  20 48 6F 6D  
00E3F5  1  3F 20 2D 20  		.byte	"? - This help list", EOL
00E3F9  1  54 68 69 73  
00E3FD  1  20 68 65 6C  
00E408  1  42 20 2D 20  		.byte	"B - Set data bank", EOL
00E40C  1  53 65 74 20  
00E410  1  64 61 74 61  
00E41A  1  43 20 2D 20  		.byte	"C - Change byte", EOL
00E41E  1  43 68 61 6E  
00E422  1  67 65 20 62  
00E42A  1  44 20 2D 20  		.byte	"D - Download Intel-Hex file", EOL
00E42E  1  44 6F 77 6E  
00E432  1  6C 6F 61 64  
00E446  1  46 20 2D 20  		.byte	"F - Fill memory", EOL
00E44A  1  46 69 6C 6C  
00E44E  1  20 6D 65 6D  
00E456  1  47 20 2D 20  		.byte	"G - Goto address", EOL
00E45A  1  47 6F 74 6F  
00E45E  1  20 61 64 64  
00E467  1  4B 20 2D 20  		.byte	"K - Disassemble 16", EOL
00E46B  1  44 69 73 61  
00E46F  1  73 73 65 6D  
00E47A  1  4C 20 2D 20  		.byte	"L - Disassemble 8", EOL
00E47E  1  44 69 73 61  
00E482  1  73 73 65 6D  
00E48C  1  4D 20 2D 20  		.byte	"M - Memory dump", EOL
00E490  1  4D 65 6D 6F  
00E494  1  72 79 20 64  
00E49C  1  4E 20 2D 20  		.byte	"N - New address", EOL
00E4A0  1  4E 65 77 20  
00E4A4  1  61 64 64 72  
00E4AC  1               	.IF PLATFORM <= 1
00E4AC  1  4F 20 2D 20  		.byte	"O - DOS", EOL
00E4B0  1  44 4F 53 0A  
00E4B4  1               	.ENDIF
00E4B4  1  53 20 2D 20  		.byte 	"S - Set breakpoint", EOL
00E4B8  1  53 65 74 20  
00E4BC  1  62 72 65 61  
00E4C7  1  54 20 2D 20  		.byte	"T - Transfer memory", EOL
00E4CB  1  54 72 61 6E  
00E4CF  1  73 66 65 72  
00E4DB  1  56 20 2D 20  		.byte	"V - VTL-02c", EOL
00E4DF  1  56 54 4C 2D  
00E4E3  1  30 32 63 0A  
00E4E7  1               	;	.byte	"T - Compare Hexdownload",EOL
00E4E7  1  00           		.byte	0
00E4E8  1               ;
00E4E8  1               ;
00E4E8  1               ;
00E4E8  1  20 FD E4     setbreak:	jsr	setaddress
00E4EB  1  C9 78        		cmp	#'x'
00E4ED  1  F0 0A        		beq	setbreak9
00E4EF  1  A0 00        		ldy	#0
00E4F1  1  B7 02        		lda	[memptr],y	; read opcode at address
00E4F3  1  8D 4D 03     		sta	NCODE		; save in opcode
00E4F6  1  98           		tya			; store 0 into
00E4F7  1  97 02        		sta	[memptr],y	; address (BRK-opcode)
00E4F9  1  60           setbreak9:	rts
00E4FA  1               ;
00E4FA  1               ;
00E4FA  1               ;
00E4FA  1               
00E4FA  1  4C E6 F7     initacia:	jmp	SERINIT
00E4FD  1               ;		lda SB+COMMA		;for test with 2nd kernel
00E4FD  1               ;		rts
00E4FD  1               
00E4FD  1               setaddress:
00E4FD  1  A2 07        		ldx	#<MSGADDR
00E4FF  1  A0 E5        		ldy	#>MSGADDR
00E501  1  20 4C E1     		jsr	print
00E504  1  4C BA E8     		jmp	enteradr
00E507  1               
00E507  1  61 64 64 72  MSGADDR:	.byte	"address: ",0
00E50B  1  65 73 73 3A  
00E50F  1  20 00        
00E511  1               
00E511  1               ;
00E511  1               ;
00E511  1               ;
00E511  1  A5 04        setdatabank:	lda	memptr+2
00E513  1  20 0C E0     		jsr	jprinthex
00E516  1  A9 3A        		lda	#':'
00E518  1  20 9F E1     		jsr	chrout
00E51B  1  20 1B E0     		jsr	jspace
00E51E  1  20 68 E6     		jsr	inputhex
00E521  1  85 04        		sta	memptr+2
00E523  1  60           		rts
00E524  1               
00E524  1               memdump:
00E524  1               ;		lda	DEVICNO
00E524  1               ;		beq	memdump6
00E524  1               ;		lda	#CLS
00E524  1               ;		jsr	chrout
00E524  1               
00E524  1  20 22 E1     memdump6:	jsr	newline
00E527  1  A2 10        		ldx	#16
00E529  1  20 30 E5     memdump3:	jsr	memdump16
00E52C  1  CA           		dex
00E52D  1  D0 FA        		bne	memdump3
00E52F  1  60           		rts
00E530  1               
00E530  1  A5 04        memdump16:	lda	memptr+2
00E532  1  20 2F E1     		jsr	printhex
00E535  1  A9 3A        		lda	#':'
00E537  1  20 9F E1     		jsr	chrout
00E53A  1               
00E53A  1  A5 03        		lda	memptr+1
00E53C  1  20 2F E1     		jsr	printhex
00E53F  1  A5 02        		lda	memptr
00E541  1  20 2F E1     		jsr	printhex
00E544  1               
00E544  1  20 27 E1     		jsr	space
00E547  1               
00E547  1  A0 00        		ldy	#0
00E549  1  C0 08        memdump1:	cpy 	#8
00E54B  1  D0 06        		bne	memdump7
00E54D  1  20 27 E1     		jsr 	space
00E550  1  20 27 E1     		jsr	space
00E553  1  B7 02        memdump7:	lda	[memptr],y
00E555  1  20 2F E1     		jsr	printhex
00E558  1  20 27 E1     		jsr	space
00E55B  1  C8           		iny
00E55C  1  C0 10        		cpy	#16
00E55E  1  D0 E9        		bne	memdump1
00E560  1               
00E560  1  20 27 E1     		jsr	space
00E563  1  A9 7C        		lda	#'|'
00E565  1  20 9F E1     		jsr	chrout
00E568  1               
00E568  1  A0 00        		ldy	#0
00E56A  1  B7 02        memdump5:	lda	[memptr],y
00E56C  1  C9 7F        		cmp	#TABU		; if >= TABU
00E56E  1  B0 04        		bcs	memdump4	; print space
00E570  1  C9 20        		cmp	#32		; if < space, print space
00E572  1  B0 02        		bcs	memdump2
00E574  1  A9 20        memdump4:	lda	#' '
00E576  1  20 9F E1     memdump2:	jsr	chrout
00E579  1  C8           		iny
00E57A  1  C0 10        		cpy	#16
00E57C  1  D0 EC        		bne	memdump5
00E57E  1               
00E57E  1  A9 7C        		lda	#'|'
00E580  1  20 9F E1     		jsr	chrout
00E583  1               
00E583  1  18           		clc
00E584  1  98           		tya
00E585  1  65 02        		adc	memptr
00E587  1  85 02        		sta	memptr
00E589  1  90 06        		bcc	memdump8
00E58B  1  E6 03        		inc	memptr+1
00E58D  1  D0 02        		bne	memdump8
00E58F  1  E6 04        		inc	memptr+2
00E591  1  4C 22 E1     memdump8:	jmp	newline
00E594  1               
00E594  1               
00E594  1  A2 41        copymem:	ldx	#<msgcopy1
00E596  1  A0 E6        		ldy	#>msgcopy1
00E598  1  20 09 E0     		jsr	jprint
00E59B  1               
00E59B  1  20 BA E8     		jsr	enteradr
00E59E  1  C9 78        		cmp	#'x'
00E5A0  1  F0 3E        		beq	copyend
00E5A2  1               
00E5A2  1  A2 34        		ldx	#<msgfill2
00E5A4  1  A0 E6        		ldy	#>msgfill2
00E5A6  1  20 09 E0     		jsr	jprint
00E5A9  1               
00E5A9  1  20 68 E6     		jsr	inputhex
00E5AC  1  85 01        		sta	ptr+1
00E5AE  1  20 68 E6     		jsr	inputhex
00E5B1  1  85 00        		sta	ptr
00E5B3  1               
00E5B3  1  A2 4D        		ldx	#<msgcopy2
00E5B5  1  A0 E6        		ldy	#>msgcopy2
00E5B7  1  20 09 E0     		jsr	jprint
00E5BA  1               
00E5BA  1  20 68 E6     		jsr	inputhex
00E5BD  1  85 12        		sta	TEMP+1
00E5BF  1  20 68 E6     		jsr	inputhex
00E5C2  1  85 11        		sta	TEMP
00E5C4  1               
00E5C4  1  A6 04        		ldx	memptr+2
00E5C6  1  8E 5A 03     		stx	MOVEBNK
00E5C9  1  8E 5B 03     		stx	MOVEBNK+1
00E5CC  1               
00E5CC  1  C2 30        		rep	#M+IX
00E5CE  1  38           		sec
00E5CF  1  A5 00        		lda	ptr
00E5D1  1  E5 02        		sbc	memptr
00E5D3  1  90 09        		bcc	copymem2
00E5D5  1               
00E5D5  1  A6 02        		ldx	memptr
00E5D7  1  A4 11        		ldy	TEMP
00E5D9  1  8B           		phb
00E5DA  1  20 59 03     		jsr	MOVENEG
00E5DD  1  AB           		plb
00E5DE  1               
00E5DE  1  E2 30        copymem2:	sep	#M+IX
00E5E0  1  60           copyend:	rts
00E5E1  1               
00E5E1  1               ;
00E5E1  1               ; Routine to fill memory with prior user interaction
00E5E1  1               ; fills from: memptr to: ptr
00E5E1  1               ;
00E5E1  1               fillmem:
00E5E1  1  A2 28        		ldx	#<msgfill1
00E5E3  1  A0 E6        		ldy	#>msgfill1
00E5E5  1  20 09 E0     		jsr	jprint
00E5E8  1               
00E5E8  1  20 BA E8     		jsr	enteradr
00E5EB  1  C9 78        		cmp	#'x'
00E5ED  1  F0 38        		beq	fillend
00E5EF  1               
00E5EF  1  A2 34        		ldx	#<msgfill2
00E5F1  1  A0 E6        		ldy	#>msgfill2
00E5F3  1  20 09 E0     		jsr	jprint
00E5F6  1               
00E5F6  1  20 68 E6     		jsr	inputhex
00E5F9  1  85 01        		sta	ptr+1
00E5FB  1  20 68 E6     		jsr	inputhex
00E5FE  1  85 00        		sta	ptr
00E600  1               
00E600  1  A2 39        		ldx	#<msgfill3
00E602  1  A0 E6        		ldy	#>msgfill3
00E604  1  20 09 E0     		jsr	jprint
00E607  1               
00E607  1  20 68 E6     		jsr	inputhex
00E60A  1               
00E60A  1  87 02        fill:		sta	[memptr]
00E60C  1  A6 04        		ldx	memptr+2
00E60E  1  8E 5A 03     		stx	MOVEBNK
00E611  1  8E 5B 03     		stx	MOVEBNK+1
00E614  1               
00E614  1  C2 31        		rep	#M+IX+CARRY
00E616  1  A5 00        		lda	ptr
00E618  1  E5 02        		sbc	memptr
00E61A  1  90 09        		bcc	fillmem2
00E61C  1               
00E61C  1  A6 02        		ldx	memptr
00E61E  1  9B           		txy
00E61F  1  C8           		iny
00E620  1  8B           		phb
00E621  1  20 59 03     		jsr	MOVENEG
00E624  1  AB           		plb
00E625  1               
00E625  1  E2 30        fillmem2:	sep	#M+IX
00E627  1  60           fillend:	rts
00E628  1               
00E628  1  66 69 6C 6C  msgfill1:	.byte	"fill from: ", 0
00E62C  1  20 66 72 6F  
00E630  1  6D 3A 20 00  
00E634  1  20 74 6F 20  msgfill2:	.byte	" to ", 0
00E638  1  00           
00E639  1  20 77 69 74  msgfill3:	.byte	" with: ",0
00E63D  1  68 3A 20 00  
00E641  1               
00E641  1  63 6F 70 79  msgcopy1:	.byte	"copy from: ", 0
00E645  1  20 66 72 6F  
00E649  1  6D 3A 20 00  
00E64D  1  20 64 65 73  msgcopy2:	.byte	" dest: ", 0
00E651  1  74 3A 20 00  
00E655  1               
00E655  1               ;
00E655  1               ;
00E655  1               ;
00E655  1  A7 02        changemem:	lda	[memptr]
00E657  1  20 0C E0     		jsr	jprinthex
00E65A  1  A9 3A        		lda	#':'
00E65C  1  20 9F E1     		jsr	chrout
00E65F  1  20 1B E0     		jsr	jspace
00E662  1  20 68 E6     		jsr	inputhex
00E665  1  87 02        		sta	[memptr]
00E667  1  60           		rts
00E668  1               
00E668  1               ;
00E668  1               ;
00E668  1               ;
00E668  1  20 79 E6     inputhex:	jsr	inputnibble
00E66B  1  0A           		asl
00E66C  1  0A           		asl
00E66D  1  0A           		asl
00E66E  1  0A           		asl
00E66F  1  85 15        		sta	gethex_A
00E671  1  20 79 E6     		jsr	inputnibble
00E674  1               		;clc
00E674  1  05 15        		ora	gethex_A
00E676  1  85 15        		sta	gethex_A
00E678  1  60           		rts
00E679  1               
00E679  1  20 0F E0     inputnibble:	jsr	jgetupper
00E67C  1  20 9F E1     		jsr	chrout
00E67F  1  38           		sec
00E680  1  E9 30        		sbc	#48
00E682  1  C9 0A        		cmp	#10
00E684  1  90 02        		bcc	inputnibble1
00E686  1  E9 07        		sbc	#7
00E688  1  60           inputnibble1:	rts
00E689  1               
00E689  1               
00E689  1               
00E689  1  48           time:		pha
00E68A  1  8A           		txa
00E68B  1  48           		pha
00E68C  1  98           		tya
00E68D  1  48           		pha
00E68E  1               
00E68E  1  A0 00        		ldy	#0
00E690  1  A2 00        		ldx	#0
00E692  1               
00E692  1  CA           time1:		dex
00E693  1  D0 FD        		bne	time1
00E695  1  88           		dey
00E696  1  D0 FA        		bne	time1
00E698  1               
00E698  1  68           		pla
00E699  1  A8           		tay
00E69A  1  68           		pla
00E69B  1  AA           		tax
00E69C  1  68           		pla
00E69D  1               
00E69D  1  60           		rts
00E69E  1               
00E69E  1               ;43 entries
00E69E  1               COLTAB:
00E69E  1  00 00        		.word 0
00E6A0  1  01 00        		.word 1
00E6A2  1  02 00        		.word 2
00E6A4  1  03 00        		.word 3
00E6A6  1  04 00        		.word 4
00E6A8  1  05 00        		.word 5
00E6AA  1  06 00        		.word 6
00E6AC  1  07 00        		.word 7
00E6AE  1  0F 00        		.word 15
00E6B0  1  17 00        		.word 23
00E6B2  1  1F 00        		.word 31
00E6B4  1  27 00        		.word 39
00E6B6  1  2F 00        		.word 47
00E6B8  1  37 00        		.word 55
00E6BA  1  3F 00        		.word 63
00E6BC  1  3E 00        		.word 62
00E6BE  1  3D 00        		.word 61
00E6C0  1  3C 00        		.word 60
00E6C2  1  3B 00        		.word 59
00E6C4  1  3A 00        		.word 58
00E6C6  1  39 00        		.word 57
00E6C8  1  38 00        		.word 56
00E6CA  1  78 00        		.word 120
00E6CC  1  B8 00        		.word 184
00E6CE  1  F8 00        		.word 248
00E6D0  1  38 01        		.word 312
00E6D2  1  78 01        		.word 376
00E6D4  1  B8 01        		.word 440
00E6D6  1  F8 01        		.word 504
00E6D8  1  F0 01        		.word 496
00E6DA  1  E8 01        		.word 488
00E6DC  1  E0 01        		.word 480
00E6DE  1  D8 01        		.word 472
00E6E0  1  D0 01        		.word 464
00E6E2  1  C8 01        		.word 456
00E6E4  1  C0 01        		.word 448
00E6E6  1  C1 01        		.word 449
00E6E8  1  C2 01        		.word 450
00E6EA  1  C3 01        		.word 451
00E6EC  1  C4 01        		.word 452
00E6EE  1  C5 01        		.word 453
00E6F0  1  C6 01        		.word 454
00E6F2  1  C7 01        		.word 455
00E6F4  1               
00E6F4  1               
00E6F4  1  C2 30        irqproc:	rep	#M+IX		;M=I=0=16bit
00E6F6  1               
00E6F6  1  48           		pha
00E6F7  1  DA           		phx
00E6F8  1  5A           		phy
00E6F9  1               
00E6F9  1  8B           		phb
00E6FA  1  0B           		phd
00E6FB  1               
00E6FB  1  A9 00 00     		lda	#0
00E6FE  1  5B           		tcd
00E6FF  1               
00E6FF  1  E2 30        		sep	#M+IX		;M=I=1=8bit
00E701  1               
00E701  1  48           		pha
00E702  1  AB           		plb			;data bank = 0
00E703  1               
00E703  1  AF 0E FE FF  		lda	dispStatus	;raster interrupt occurred?
00E707  1               ;		bpl	irqps2		;bit7=0? => no
00E707  1  80 41        		bra	irqps2		;bit7=0? => no
00E709  1               
00E709  1  8F 0E FE FF  		sta	dispStatus	;clear status
00E70D  1  C2 30        		rep	#M+IX		;16-bit
00E70F  1  A9 4A E7     		lda 	#irqps2		;load irqps2-1
00E712  1  3A           		dea
00E713  1  48           		pha			;push to stack for RTS
00E714  1  6C 0F 02     		jmp	(RASVEC)
00E717  1               
00E717  1               	.if 0=1
00E717  1               
00E717  1               		lda	vcountLo
00E717  1               		clc
00E717  1               		adc 	#1
00E717  1               		cmp	#200
00E717  1               		bcc	rasterIrq1
00E717  1               		lda	#0
00E717  1               rasterIrq1:	sta	rasterLo
00E717  1               ;		sta	colorBorderLo
00E717  1               		sta	colorBackgroundLo
00E717  1               
00E717  1               		sep	#M+IX		;8-bit
00E717  1               		bra	irqex
00E717  1               	.ENDIF
00E717  1               
00E717  1               	.if 1=1
00E717  1               rasterProc:
00E717  1  AD 70 03     		lda	COLCNT
00E71A  1  1A           		ina
00E71B  1  C9 2B 00     		cmp	#43
00E71E  1  90 03        		bcc	i2
00E720  1  A9 00 00     		lda	#0
00E723  1  8D 70 03     i2:		sta	COLCNT
00E726  1  0A           		asl
00E727  1  AA           		tax
00E728  1  BD 9E E6     		lda	COLTAB,x
00E72B  1  8F 00 FE FF  		sta	colorBorderLo
00E72F  1               		;sta	colorBackgroundLo
00E72F  1  18           		clc
00E730  1  AF 0C FE FF  		lda	rasterLo
00E734  1  69 02 00     		adc	#2
00E737  1  C9 2E 01     		cmp	#256+46
00E73A  1  90 09        		bcc	i1
00E73C  1               
00E73C  1               ;		lda	COLCNT+2
00E73C  1               ;		ina
00E73C  1               ;		cmp	#43
00E73C  1               ;		bcc	i3
00E73C  1  A9 00 00     		lda	#0
00E73F  1               ;i3:		sta	COLCNT+2
00E73F  1  8D 70 03     		sta	COLCNT
00E742  1  A9 1D 00     		lda	#29
00E745  1  8F 0C FE FF  i1:		sta	rasterLo
00E749  1  60           		rts
00E74A  1               
00E74A  1               	.ENDIF
00E74A  1               
00E74A  1               irqps2:
00E74A  1  E2 30        		sep	#M+IX
00E74C  1  AF D1 FF FF  		lda	PS2STATUS	;key available?
00E750  1  D0 03        		bne	irqtimer	;Bit 0 = 0?, no =>
00E752  1  20 F4 E7     		jsr	KGBIRQ
00E755  1               
00E755  1               
00E755  1  AF 83 FF FF  irqtimer:	lda	TIMERST
00E759  1               
00E759  1               ;		bpl	irqmouse
00E759  1               ;		bra	irqmouse
00E759  1               
00E759  1               ;		lda	colorBorderLo
00E759  1               ;		eor	#$ff
00E759  1               ;		sta	colorBorderLo
00E759  1               
00E759  1               ;		lda	#$20
00E759  1               ;		sta	TIMERLO
00E759  1               ;		lda	#$A2
00E759  1               ;		sta	TIMERHI
00E759  1               ;		lda	#3
00E759  1               ;		sta	TIMERST
00E759  1               
00E759  1               ;byte	d6	d5	d4	d3	d2	d1	d0
00E759  1               ;1	1	lb	rb	dy7	dy6	dx7	dx6
00E759  1               ;2	0	dx5	dx4	dx3	dx2	dx1	dx0
00E759  1               ;3	0	dy5	dy4	dy3	dy2	dy1	dy0
00E759  1               
00E759  1  AF A2 FF FF  irqmouse:	lda	IIR1
00E75D  1  29 01        		and	#1
00E75F  1  F0 03        		beq	irqmouse1
00E761  1  4C EC E7     		jmp	irqex		;1 = no int pending
00E764  1               irqmouse1:
00E764  1  AF A0 FF FF  		lda	RBR1
00E768  1               ;		jsr	printhex
00E768  1  89 40        		bit	#$40		;1 = test start of protocol
00E76A  1  F0 08        		beq	irqmousedx
00E76C  1  8D 75 02     		sta	MDXDY
00E76F  1  9C 70 02     		stz	MSTATE
00E772  1  80 78        		bra	irqex
00E774  1               
00E774  1               irqmousedx:
00E774  1  29 3F        		and	#$3f
00E776  1               
00E776  1  AE 70 02     		ldx	MSTATE
00E779  1  D0 2B        		bne	irqmousedy
00E77B  1  EE 70 02     		inc	MSTATE
00E77E  1               
00E77E  1  9C 72 02     		stz	MPOSX+1
00E781  1               
00E781  1  18           		clc
00E782  1  6D 71 02     		adc	MPOSX
00E785  1  8D 71 02     		sta	MPOSX
00E788  1  AD 75 02     		lda	MDXDY
00E78B  1  6A           		ror
00E78C  1  6A           		ror
00E78D  1  8D 75 02     		sta	MDXDY
00E790  1  6A           		ror
00E791  1  29 C0        		and	#%11000000
00E793  1  18           		clc
00E794  1  6D 71 02     		adc	MPOSX
00E797  1  10 02        		bpl	irqmousedx1
00E799  1  A9 00        		lda	#0
00E79B  1  C9 50        irqmousedx1:	cmp	#80
00E79D  1  90 02        		bcc	irqmousedx2
00E79F  1  A9 4F        		lda	#79
00E7A1  1  8D 71 02     irqmousedx2:	sta	MPOSX
00E7A4  1  80 46        		bra	irqex
00E7A6  1               
00E7A6  1               irqmousedy:
00E7A6  1  E0 01        		cpx	#1
00E7A8  1  D0 42        		bne	irqex
00E7AA  1  EE 70 02     		inc	MSTATE
00E7AD  1               
00E7AD  1  9C 74 02     		stz	MPOSY+1
00E7B0  1               
00E7B0  1  18           		clc
00E7B1  1  6D 73 02     		adc	MPOSY
00E7B4  1  8D 73 02     		sta	MPOSY
00E7B7  1  AD 75 02     		lda	MDXDY
00E7BA  1  6A           		ror
00E7BB  1  6A           		ror
00E7BC  1  8D 75 02     		sta	MDXDY
00E7BF  1  6A           		ror
00E7C0  1  29 C0        		and	#%11000000
00E7C2  1  18           		clc
00E7C3  1  6D 73 02     		adc	MPOSY
00E7C6  1  10 02        		bpl	irqmousedy1
00E7C8  1  A9 00        		lda	#0
00E7CA  1  C9 19        irqmousedy1:	cmp	#25
00E7CC  1  90 02        		bcc	irqmousedy2
00E7CE  1  A9 18        		lda	#24
00E7D0  1  8D 73 02     irqmousedy2:	sta	MPOSY
00E7D3  1               
00E7D3  1               		;lda	MPOSY
00E7D3  1               		;jsr	printhex
00E7D3  1               
00E7D3  1  C2 20        		rep	#M
00E7D5  1  AD 73 02     		lda	MPOSY
00E7D8  1  0A           		asl			;*2
00E7D9  1  0A           		asl			;*4
00E7DA  1  6D 73 02     		adc	MPOSY		;*5
00E7DD  1  0A           		asl			;*10
00E7DE  1  0A           		asl			;*20
00E7DF  1  0A           		asl			;*40
00E7E0  1  0A           		asl			;*80
00E7E1  1  6D 71 02     		adc	MPOSX
00E7E4  1  8F 0A FE FF  		sta	cursorLo
00E7E8  1  E2 20        		sep	#M
00E7EA  1               
00E7EA  1  80 00        		bra	irqex
00E7EC  1               
00E7EC  1  C2 30        irqex:		rep	#$30		;M=I=0=16bit
00E7EE  1               
00E7EE  1  2B           		pld
00E7EF  1  AB           		plb
00E7F0  1               
00E7F0  1  7A           		ply
00E7F1  1  FA           		plx
00E7F2  1  68           		pla
00E7F3  1               
00E7F3  1  40           brkproc:	rti
00E7F4  1               
00E7F4  1               KGBIRQ:
00E7F4  1               		.A8
00E7F4  1               		.I8
00E7F4  1               
00E7F4  1               ;		tya
00E7F4  1               ;		pha
00E7F4  1               
00E7F4  1               ;		ldx	#40
00E7F4  1               ;KGB6:		dex		;wait some time for parity and stop bit to arrive
00E7F4  1               ;		bne	KGB6
00E7F4  1               
00E7F4  1               ;		lda	skipone
00E7F4  1               ;		jsr	printhex
00E7F4  1               ;		lda	SHFLOK
00E7F4  1               ;		jsr	printhex
00E7F4  1               ;		lda	extended
00E7F4  1               ;		jsr	printhex
00E7F4  1               ;		lda	ALTACT
00E7F4  1               ;		jsr	printhex
00E7F4  1               
00E7F4  1  A2 00        		ldx	#0
00E7F6  1  AF D0 FF FF  		lda	PS2DATA
00E7FA  1               ;		sta	PS2DATA		;reset PS2
00E7FA  1               ;		cmp	#$E1		;pause/break?
00E7FA  1               ;		bne	KGBIRQ1		;no
00E7FA  1               ;
00E7FA  1               ;		tsx
00E7FA  1               ;		clc
00E7FA  1               ;		lda 	$105,X
00E7FA  1               ;		sta 	memptr
00E7FA  1               ;		adc	#2
00E7FA  1               ;		sta	$105,x
00E7FA  1               ;		lda 	$106,X
00E7FA  1               ;		sta	memptr+1
00E7FA  1               ;		adc	#0
00E7FA  1               ;		sta	$106,x
00E7FA  1               ;
00E7FA  1               ;		ldy	#0
00E7FA  1               ;		lda	(memptr),y
00E7FA  1               ;		sta	opcode
00E7FA  1               ;		jmp	BRKENTRY1
00E7FA  1               
00E7FA  1  AC 46 02     KGBIRQ1:	ldy	skipone
00E7FD  1  8E 44 02     		stx	SUPERF	;X = 0
00E800  1               
00E800  1  C9 E1        		cmp	#$E1	;Pause key?
00E802  1  D0 03        		bne  	KGB0
00E804  1  4C A2 E0     		jmp	reset
00E807  1               
00E807  1  C9 F0        KGB0:		cmp	#$F0	;break scancode?
00E809  1  D0 06        		bne	KGB5	;no
00E80B  1  8D 46 02     		sta	skipone	;skipone <> 0 denotes
00E80E  1  4C A8 E8     		jmp	KGBEX	;ignore next key
00E811  1               
00E811  1  C9 12        KGB5:		cmp	#CLSHIFT	;process left-shift
00E813  1  F0 04        		beq	KGB9		;yes =>
00E815  1  C9 59        		cmp	#CRSHIFT	;process right-shift
00E817  1  D0 03        		bne	KGB8		;no =>
00E819  1  8C 31 02     KGB9:		sty	SHFLOK		;Y=skipone, shift = 0 denotes shift pressed!
00E81C  1               
00E81C  1  C9 14        KGB8:		cmp	#CLSTRG
00E81E  1  D0 03        		bne	KGB2
00E820  1  8C 29 02     		sty	CLSFLG		;Y=skipone, CLSFLG = 0 denotes CLS pressed!
00E823  1               
00E823  1  C9 E0        KGB2:		cmp	#$e0		;extended scancode
00E825  1  D0 05        		bne	KGB7		;no =>
00E827  1  8D 47 02     		sta	extended
00E82A  1  F0 7C        		beq	KGBEX
00E82C  1               
00E82C  1  AC 46 02     KGB7:		ldy	skipone		;make-key?
00E82F  1  F0 0A        		beq	KGB3		;yes =>
00E831  1               
00E831  1               ;		ldx #0			;hence break-key, clear break
00E831  1  8E 46 02     		stx	skipone		;X already 0
00E834  1  8E 47 02     		stx	extended
00E837  1  86 3A        		stx	ALTACT
00E839  1  D0 6D        		bne	KGBEX		;read next key
00E83B  1               
00E83B  1  C9 58        KGB3:		cmp	#CCAPS		;CAPS-LOCK?
00E83D  1  F0 25        		beq	KGBCAPS		;yes =>
00E83F  1               
00E83F  1               ;
00E83F  1               ; special keys have been processed, now tranform scancode into ASCII
00E83F  1               ;
00E83F  1  AC 47 02     		ldy	extended
00E842  1  D0 2F        		bne	KGBEXTEND
00E844  1               
00E844  1  AC 31 02     		ldy	SHFLOK		;shift = 0, upper case
00E847  1  F0 14        		beq	KGBUPPER
00E849  1               
00E849  1  A4 3A        		ldy	ALTACT		;ALTGR active?
00E84B  1  D0 5C        		bne	KGBALTGR	;yes, handle ALTGR-keys
00E84D  1               
00E84D  1  A8           		tay			;read ASCII-char lower-case
00E84E  1  B9 FD E8     		lda	CHARTABLE_NOSHIFT,y
00E851  1  F0 55        KGB4:		beq	KGBEX		;if undefined, read next key
00E853  1  AE 29 02     		ldx	CLSFLG		;STRG-pressed?
00E856  1  D0 48        		bne	KGBKEYEX	;no, exit
00E858  1  38           		sec
00E859  1  E9 60        		sbc 	#('a'-1)
00E85B  1  B0 43        		bcs	KGBKEYEX
00E85D  1               
00E85D  1  A8           KGBUPPER:	tay			;read ASCII-char upper-case
00E85E  1  B9 8D E9     		lda	CHARTABLE_SHIFT,y
00E861  1  4C 51 E8     		jmp	KGB4
00E864  1               
00E864  1  AD 31 02     KGBCAPS:	lda	SHFLOK		;shift = 0?
00E867  1  F0 05        		beq	KGBCAPS1
00E869  1  8E 31 02     		stx	SHFLOK		;X = 0
00E86C  1  D0 3A        		bne	KGBEX		;read next key
00E86E  1               
00E86E  1  EE 31 02     KGBCAPS1:	inc	SHFLOK		;shift := 1
00E871  1  D0 35        		bne	KGBEX		;read next key
00E873  1               
00E873  1  C9 11        KGBEXTEND:	cmp	#ALTGR
00E875  1  D0 07        		bne	KGBEXTEND2
00E877  1  85 3A        		sta	ALTACT
00E879  1  8E 47 02     		stx	extended	;X = 0
00E87C  1  F0 2A        		beq	KGBEX
00E87E  1  A0 0B        KGBEXTEND2:	ldy	#(EXT_TABLE - EXT_TABLE_IND - 1)
00E880  1  D9 2D EA     KGBEXTEND1:	cmp	EXT_TABLE_IND,y
00E883  1  F0 05        		beq	KGBEXTFND
00E885  1  88           		dey
00E886  1  10 F8        		bpl	KGBEXTEND1
00E888  1  30 1E        		bmi	KGBEX
00E88A  1               
00E88A  1  B9 39 EA     KGBEXTFND:	lda	EXT_TABLE,y
00E88D  1  C9 1C        		cmp	#CCHM		;cursor home?
00E88F  1  D0 09        		bne	KGBEXTFND1	;no
00E891  1  AE 29 02     		ldx	CLSFLG		;STRG pressed?
00E894  1  D0 04        		bne	KGBEXTFND1	;no
00E896  1  A9 01        		lda	#CLS		;clear screen
00E898  1  D0 06        		bne	KGBKEYEX
00E89A  1               
00E89A  1  BE 45 EA     KGBEXTFND1:	ldx	EXT_TABLE_SUPERF,y
00E89D  1  8E 44 02     		stx	SUPERF
00E8A0  1               
00E8A0  1  8D 2E 03     KGBKEYEX:	sta	IRQPS2D
00E8A3  1  A9 00        		lda	#0
00E8A5  1  8D 2D 03     		sta	IRQPS2S
00E8A8  1  60           KGBEX:		rts
00E8A9  1               
00E8A9  1  A2 07        KGBALTGR:	ldx	#(ALTGR_TABLE - ALTGR_TABLE_IND - 1)
00E8AB  1  DD 1D EA     KGBALTGR1:	cmp	ALTGR_TABLE_IND,x
00E8AE  1  D0 05        		bne	KGBALTGR2
00E8B0  1  BD 25 EA     		lda	ALTGR_TABLE,x
00E8B3  1  D0 EB        		bne	KGBKEYEX	;never 0
00E8B5  1  CA           KGBALTGR2:	dex
00E8B6  1  10 F3        		bpl	KGBALTGR1
00E8B8  1  30 EE        		bmi	KGBEX
00E8BA  1               
00E8BA  1               
00E8BA  1               
00E8BA  1               ;BRKENTRY:	tya
00E8BA  1               ;		pha
00E8BA  1               ;		tsx
00E8BA  1               ;
00E8BA  1               ;BRKENTRY1:	lda	DEVICNO
00E8BA  1               ;		sta	DEVICS
00E8BA  1               ;		lda	#0
00E8BA  1               ;		sta	DEVICNO
00E8BA  1               ;
00E8BA  1               ;IRQBRK:		JSR	IRQDUMP
00E8BA  1               ;
00E8BA  1               ;		LDA	opcode
00E8BA  1               ;		LDY	#0
00E8BA  1               ;		STA	(memptr),Y
00E8BA  1               ;
00E8BA  1               ;		JSR	jdisone
00E8BA  1               ;
00E8BA  1               ;		LDA	opcode
00E8BA  1               ;		CMP	#$4C		;jmp
00E8BA  1               ;		BEQ	IRQJMP
00E8BA  1               ;		CMP	#$6C		;jmp ( )
00E8BA  1               ;		BEQ	IRQJMPI
00E8BA  1               ;		CMP	#$20		;jsr
00E8BA  1               ;		BEQ	IRQJMP
00E8BA  1               ;		CMP	#$40
00E8BA  1               ;		BEQ	IRQRTI
00E8BA  1               ;		CMP	#$60
00E8BA  1               ;		BEQ	IRQRTS
00E8BA  1               ;		AND	#$0F
00E8BA  1               ;		BEQ	IRQREL		; branches
00E8BA  1               ;
00E8BA  1               ;		JMP	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQJMP:		LDY 	#1
00E8BA  1               ;		LDA 	(dbugptro),y
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		INY
00E8BA  1               ;		LDA 	(dbugptro),y
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JMP 	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQRTI:		TSX
00E8BA  1               ;		LDA 	$102,X
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		LDA 	$103,X
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JMP 	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQRTS:		TSX
00E8BA  1               ;		CLC
00E8BA  1               ;		LDA 	$107,X
00E8BA  1               ;		ADC 	#1
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		LDA 	$108,X
00E8BA  1               ;		ADC 	#0
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JMP 	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQJMPI:	LDY 	#1
00E8BA  1               ;		LDA 	(dbugptro),Y
00E8BA  1               ;		STA 	dbugptrx
00E8BA  1               ;		INY
00E8BA  1               ;		LDA 	(dbugptro),Y
00E8BA  1               ;		STA 	dbugptrx+1
00E8BA  1               ;		LDY 	#0
00E8BA  1               ;		LDA 	(dbugptrx),Y
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		INY
00E8BA  1               ;		LDA 	(dbugptrx),Y
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JMP 	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQREL:		LDA 	opcode
00E8BA  1               ;		STA 	BRKBRA
00E8BA  1               ;		LDA 	flags
00E8BA  1               ;		PHA
00E8BA  1               ;		PLP
00E8BA  1               ;		JMP	BRKBRA
00E8BA  1               ;
00E8BA  1               ;BRATAKEN:	LDY 	#1
00E8BA  1               ;		LDA 	(dbugptro),Y
00E8BA  1               ;		BMI 	IRQRELNEG
00E8BA  1               ;		CLC
00E8BA  1               ;		ADC 	memptr
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		LDA 	memptr+1
00E8BA  1               ;		ADC 	#0
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JMP 	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQRELNEG:	CLC
00E8BA  1               ;		ADC 	memptr
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		LDA 	memptr+1
00E8BA  1               ;		SBC 	#0
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JMP 	IRQGETC
00E8BA  1               ;
00E8BA  1               ;IRQGETC:	lda 	#'>'
00E8BA  1               ;		jsr 	jchrout
00E8BA  1               ;		jsr 	jchrin
00E8BA  1               ;		jsr 	jchrout
00E8BA  1               ;		tay
00E8BA  1               ;		cpy	#'r'
00E8BA  1               ;		bne	IRQGETCR
00E8BA  1               ;		lda	SB+COMMA
00E8BA  1               ;		jmp	jkernel
00E8BA  1               ;
00E8BA  1               ;IRQGETCR:	cpy	#'x'
00E8BA  1               ;		beq	IRQEND
00E8BA  1               ;		cpy	#' '
00E8BA  1               ;		bne	irqgetcm
00E8BA  1               ;
00E8BA  1               ;IRQREPEAT:	tsx
00E8BA  1               ;		clc
00E8BA  1               ;		lda	$105,x
00E8BA  1               ;		adc	#2
00E8BA  1               ;		sta	$105,x
00E8BA  1               ;		bcc	irqgetc2
00E8BA  1               ;		inc	$106,x
00E8BA  1               ;irqgetc2:	jmp	IRQBRK
00E8BA  1               ;
00E8BA  1               ;irqgetcm:	cpy	#'m'
00E8BA  1               ;		beq	irqgetd
00E8BA  1               ;		cpy	#'d'
00E8BA  1               ;		beq	irqgetd
00E8BA  1               ;		cpy	#'1'
00E8BA  1               ;		bcc	irqgets
00E8BA  1               ;		cpy	#'4'
00E8BA  1               ;		bcs	irqgets
00E8BA  1               ;
00E8BA  1               ;		jsr	setmonitor
00E8BA  1               ;		jmp	IRQREPEAT
00E8BA  1               ;
00E8BA  1               ;irqgetd:	jsr	enteradr
00E8BA  1               ;		cmp	#'x'
00E8BA  1               ;		beq	IRQGETC
00E8BA  1               ;
00E8BA  1               ;		cpy	#'d'
00E8BA  1               ;		beq	irqgetd1
00E8BA  1               ;		cpy	#'m'
00E8BA  1               ;		bne	irqgets
00E8BA  1               ;		jsr	memdumpx
00E8BA  1               ;		jmp	IRQREPEAT
00E8BA  1               ;
00E8BA  1               ;irqgetd1:	lda	opcode
00E8BA  1               ;		pha
00E8BA  1               ;		jsr	jdisass
00E8BA  1               ;		pla
00E8BA  1               ;		sta	opcode
00E8BA  1               ;		jmp	IRQREPEAT
00E8BA  1               ;
00E8BA  1               ;irqgets:	cpy	#'s'			; skip jsr
00E8BA  1               ;		bne	irqSetBreak
00E8BA  1               ;
00E8BA  1               ;		lda 	opcode
00E8BA  1               ;		cmp 	#$20
00E8BA  1               ;		bne 	irqSetBreak
00E8BA  1               ;
00E8BA  1               ;		lda 	dbugptro
00E8BA  1               ;		adc	#2
00E8BA  1               ;		sta	memptr
00E8BA  1               ;		lda	dbugptro+1
00E8BA  1               ;		adc	#0
00E8BA  1               ;		sta	memptr+1
00E8BA  1               ;
00E8BA  1               ;irqSetBreak:
00E8BA  1               ;		LDY 	#0
00E8BA  1               ;		LDA 	(memptr),y
00E8BA  1               ;		STA 	opcode
00E8BA  1               ;		TYA
00E8BA  1               ;		STA 	(memptr),y
00E8BA  1               ;
00E8BA  1               ;IRQEND:		lda	DEVICS
00E8BA  1               ;		sta	DEVICNO
00E8BA  1               ;		PLA
00E8BA  1               ;		TAY
00E8BA  1               ;		jmp	irqex
00E8BA  1               ;
00E8BA  1               ;
00E8BA  1               ;IRQDUMP:	LDA 	#<BRKSTR	;print headline regs+flags
00E8BA  1               ;		LDY 	#>BRKSTR
00E8BA  1               ;		JSR 	PTEXT
00E8BA  1               ;
00E8BA  1               ;		SEC			;program counter - 2
00E8BA  1               ;		LDA 	$105,X
00E8BA  1               ;		SBC 	#2
00E8BA  1               ;		STA 	$105,X
00E8BA  1               ;		TAY
00E8BA  1               ;		LDA 	$106,X
00E8BA  1               ;		SBC 	#0
00E8BA  1               ;		STA 	$106,X
00E8BA  1               ;
00E8BA  1               ;		JSR 	jprinthex	;print address HI
00E8BA  1               ;		TYA
00E8BA  1               ;		JSR 	PUTHEXC		;print address LO
00E8BA  1               ;		lda	#32
00E8BA  1               ;		jsr	jchrout
00E8BA  1               ;
00E8BA  1               ;		LDA 	$103,X		;A, X, Y
00E8BA  1               ;		JSR 	PUTHEXC
00E8BA  1               ;		LDA 	$102,X
00E8BA  1               ;		JSR 	PUTHEXC
00E8BA  1               ;		LDA 	$101,X
00E8BA  1               ;		JSR 	PUTHEXC
00E8BA  1               ;
00E8BA  1               ;		TXA			;stack pointer
00E8BA  1               ;		CLC
00E8BA  1               ;		ADC 	#6
00E8BA  1               ;		JSR 	PUTHEXC
00E8BA  1               ;
00E8BA  1               ;		LDY 	#7
00E8BA  1               ;		LDA 	$104,X
00E8BA  1               ;		STA 	flags
00E8BA  1               ;IRQBIN:		ASL
00E8BA  1               ;		PHA
00E8BA  1               ;		LDA 	#'0'
00E8BA  1               ;		ADC 	#0
00E8BA  1               ;		JSR 	jchrout
00E8BA  1               ;		PLA
00E8BA  1               ;		DEY
00E8BA  1               ;		BPL 	IRQBIN
00E8BA  1               ;
00E8BA  1               ;		JSR	jnewline
00E8BA  1               ;		JSR 	PRTDASH
00E8BA  1               ;
00E8BA  1               ;		LDX 	#0
00E8BA  1               ;IRQDUMP2:	LDA 	MONACT,x
00E8BA  1               ;		BEQ 	IRQDUMP1
00E8BA  1               ;		TXA
00E8BA  1               ;		ASL
00E8BA  1               ;		TAY
00E8BA  1               ;		LDA 	MONTAB,y
00E8BA  1               ;		STA 	memptr
00E8BA  1               ;		LDA 	MONTAB+1,y
00E8BA  1               ;		STA 	memptr+1
00E8BA  1               ;		JSR 	memdumpx16
00E8BA  1               ;IRQDUMP1:	INX
00E8BA  1               ;		CPX 	#4
00E8BA  1               ;		BNE 	IRQDUMP2
00E8BA  1               ;
00E8BA  1               ;		tsx
00E8BA  1               ;		LDA 	$107,X
00E8BA  1               ;		STA	memptr
00E8BA  1               ;		STA	dbugptro
00E8BA  1               ;		LDA 	$108,X
00E8BA  1               ;		STA	memptr+1
00E8BA  1               ;		sta	dbugptro+1
00E8BA  1               ;
00E8BA  1               ;PRTDASH:	ldx	#73
00E8BA  1               ;		lda	#'-'
00E8BA  1               ;prtdash1:	jsr	jchrout
00E8BA  1               ;		dex
00E8BA  1               ;		bpl	prtdash1
00E8BA  1               ;		jmp	jnewline
00E8BA  1               ;
00E8BA  1               ;setmonitor:	sec
00E8BA  1               ;		sbc	#'1'
00E8BA  1               ;		tay
00E8BA  1               ;		lda	MONACT,y
00E8BA  1               ;		beq	setmonitor1
00E8BA  1               ;		lda	#0
00E8BA  1               ;		sta	MONACT,Y
00E8BA  1               ;		beq	setmonitor9
00E8BA  1               ;setmonitor1:	tya
00E8BA  1               ;		pha
00E8BA  1               ;		jsr	setaddress
00E8BA  1               ;		cmp	#'x'
00E8BA  1               ;		beq	setmonitor9
00E8BA  1               ;		pla
00E8BA  1               ;		tay
00E8BA  1               ;		lda	#1
00E8BA  1               ;		sta	MONACT,y
00E8BA  1               ;		tya
00E8BA  1               ;		asl
00E8BA  1               ;		tay
00E8BA  1               ;		lda	memptr
00E8BA  1               ;		sta	MONTAB,y
00E8BA  1               ;		lda	memptr+1
00E8BA  1               ;		sta	MONTAB+1,y
00E8BA  1               ;setmonitor9:	lda	#0
00E8BA  1               ;		rts
00E8BA  1               ;
00E8BA  1               ;setaddress:	ldx	#<(MSGADDR)
00E8BA  1               ;		ldy	#>(MSGADDR)
00E8BA  1               ;		jsr	print
00E8BA  1               ;		jsr	enteradr
00E8BA  1               ;		cmp	#'x'
00E8BA  1               ;		beq	setaddress1
00E8BA  1               ;setaddress1:	lda	#0
00E8BA  1               ;		rts
00E8BA  1               
00E8BA  1               ;MSGADDR:	.byte "address: ",0
00E8BA  1               
00E8BA  1               ;memdumpx:	ldx	#16
00E8BA  1               ;		jsr	jnewline
00E8BA  1               ;memdumpx3:	jsr	memdumpx16
00E8BA  1               ;		dex
00E8BA  1               ;		bne	memdumpx3
00E8BA  1               ;		lda	#0
00E8BA  1               ;		rts
00E8BA  1               ;
00E8BA  1               ;memdumpx16:	lda	memptr+1
00E8BA  1               ;		jsr	jprinthex
00E8BA  1               ;		lda	memptr
00E8BA  1               ;		jsr	jprinthex
00E8BA  1               ;		lda	#':'
00E8BA  1               ;		jsr	jchrout
00E8BA  1               ;		jsr	jspace
00E8BA  1               ;
00E8BA  1               ;		ldy	#0
00E8BA  1               ;memdumpx1:	lda	(memptr),y
00E8BA  1               ;		jsr	PUTHEXC
00E8BA  1               ;		iny
00E8BA  1               ;		cpy	#8
00E8BA  1               ;		bne	memdumpx6
00E8BA  1               ;		jsr	jspace
00E8BA  1               ;memdumpx6:	cpy	#16
00E8BA  1               ;		bne	memdumpx1
00E8BA  1               ;
00E8BA  1               ;		jsr	jspace
00E8BA  1               ;		lda	#'|'
00E8BA  1               ;		jsr	jchrout
00E8BA  1               ;
00E8BA  1               ;		ldy	#0
00E8BA  1               ;memdumpx5:	lda	(memptr),y
00E8BA  1               ;		and	#127
00E8BA  1               ;		cmp	#127
00E8BA  1               ;		beq	memdumpx4
00E8BA  1               ;		cmp	#32
00E8BA  1               ;		bcs	memdumpx2
00E8BA  1               ;memdumpx4:	lda	#' '
00E8BA  1               ;memdumpx2:	jsr	jchrout
00E8BA  1               ;		iny
00E8BA  1               ;		cpy	#16
00E8BA  1               ;		bne	memdumpx5
00E8BA  1               ;
00E8BA  1               ;		lda	#'|'
00E8BA  1               ;		jsr	jchrout
00E8BA  1               ;
00E8BA  1               ;		clc
00E8BA  1               ;		tya
00E8BA  1               ;		adc	memptr
00E8BA  1               ;		sta	memptr
00E8BA  1               ;		bcc	memdumpx9
00E8BA  1               ;		inc	memptr+1
00E8BA  1               ;memdumpx9:	jmp	jnewline
00E8BA  1               
00E8BA  1               
00E8BA  1               
00E8BA  1               ;PTEXT:		STA 	dbugptrx
00E8BA  1               ;		STY 	dbugptrx+1
00E8BA  1               ;PTEXT2:		LDY 	#0
00E8BA  1               ;		LDA 	(dbugptrx),Y
00E8BA  1               ;		BEQ 	PTEXT1
00E8BA  1               ;		JSR 	jchrout
00E8BA  1               ;		INC 	dbugptrx
00E8BA  1               ;		BNE 	PTEXT2
00E8BA  1               ;		INC 	dbugptrx+1
00E8BA  1               ;		BNE 	PTEXT2
00E8BA  1               ;PTEXT1:		RTS
00E8BA  1               
00E8BA  1               ;
00E8BA  1               ;
00E8BA  1               ;
00E8BA  1  A9 00        enteradr:	lda	#0
00E8BC  1  85 02        		sta	memptr
00E8BE  1  85 03        		sta	memptr+1
00E8C0  1  A9 04        		lda	#4
00E8C2  1  8D 48 02     		sta	ADRCNT
00E8C5  1               
00E8C5  1  20 03 E0     enteradrC:	jsr	jchrin
00E8C8  1  C9 0A        		cmp	#EOL
00E8CA  1  F0 30        		beq	enteradrEnd
00E8CC  1               
00E8CC  1  C9 78        		cmp	#'x'
00E8CE  1  F0 2C        		beq	enteradrEnd
00E8D0  1               
00E8D0  1  20 06 E0     enteradrD:	jsr	jchrout
00E8D3  1  C9 3A        		cmp	#':'
00E8D5  1  B0 08        		bcs	enteradrE
00E8D7  1  C9 30        		cmp	#'0'
00E8D9  1  90 EA        		bcc	enteradrC
00E8DB  1               
00E8DB  1  29 0F        		and	#%00001111
00E8DD  1  B0 0A        		bcs	enteradrF
00E8DF  1               
00E8DF  1  C9 67        enteradrE:	cmp	#'g'
00E8E1  1  B0 E2        		bcs	enteradrC
00E8E3  1  C9 61        		cmp	#'a'
00E8E5  1  90 DE        		bcc	enteradrC
00E8E7  1               
00E8E7  1  E9 37        		sbc	#'7'
00E8E9  1  0A           enteradrF:	asl
00E8EA  1  0A           		asl
00E8EB  1  0A           		asl
00E8EC  1  0A           		asl
00E8ED  1  A2 04        		ldx	#4
00E8EF  1  0A           enteradrG:	asl
00E8F0  1  26 02        		rol	memptr
00E8F2  1  26 03        		rol	memptr+1
00E8F4  1  CA           		dex
00E8F5  1  D0 F8        		bne	enteradrG
00E8F7  1               
00E8F7  1  CE 48 02     		dec	ADRCNT
00E8FA  1  D0 C9        		bne	enteradrC
00E8FC  1  60           enteradrEnd:	rts
00E8FD  1               
00E8FD  1               
00E8FD  1               ;BRKSTR:		.byte	EOL
00E8FD  1               ;		.byte	" PC   A  X  Y  SP NV.BDIZC"
00E8FD  1               ;		.byte	EOL, 0
00E8FD  1               
00E8FD  1               CHARTABLE_NOSHIFT:
00E8FD  1               ;		 	 00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F
00E8FD  1  00 09 00 05  		.byte	  0,   9,   0,   5,   3,   1,   2,  12,   0,  10,   8,   6,   4,TABU, '^',   0	; 00
00E901  1  03 01 02 0C  
00E905  1  00 0A 08 06  
00E90D  1  00 00 00 00  		.byte     0,   0,   0,   0,   0, 'q', '1',   0,   0,   0, 'y', 's', 'a', 'w', '2',   0	; 10
00E911  1  00 71 31 00  
00E915  1  00 00 79 73  
00E91D  1  00 63 78 64  		.byte	  0, 'c', 'x', 'd', 'e', '4', '3',   0,   0, ' ', 'v', 'f', 't', 'r', '5',   0	; 20
00E921  1  65 34 33 00  
00E925  1  00 20 76 66  
00E92D  1  00 6E 62 68  		.byte	  0, 'n', 'b', 'h', 'g', 'z', '6',   0,   0,   0, 'm', 'j', 'u', '7', '8',   0	; 30
00E931  1  67 7A 36 00  
00E935  1  00 00 6D 6A  
00E93D  1  00 2C 6B 69  		.byte	  0, ',', 'k', 'i', 'o', '0', '9',   0,   0, '.', '-', 'l', $94, 'p', '\',   0	; 40
00E941  1  6F 30 39 00  
00E945  1  00 2E 2D 6C  
00E94D  1  00 00 84 58  		.byte	  0,   0, $84,  'X',$81, '`',   0,   0,   0,   0, EOL, '+',   0, '#',   0,   0	; 50
00E951  1  81 60 00 00  
00E955  1  00 00 0A 2B  
00E95D  1  00 3C 00 00  		.byte	  0, '<',   0,   0,   0,   0,BACK,   0,   0, '1',   0, '4', '7',   0,   0,   0	; 60
00E961  1  00 00 08 00  
00E965  1  00 31 00 34  
00E96D  1  30 2E 32 35  		.byte	 '0', '.', '2', '5', '6', '8', 27,   0,  11, '+', '3', '-', '*', '9', CLS,   0	; 70
00E971  1  36 38 1B 00  
00E975  1  0B 2B 33 2D  
00E97D  1  00 00 00 07  		.byte	  0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0	; 80
00E981  1  00 00 00 00  
00E985  1  00 00 00 00  
00E98D  1               
00E98D  1               CHARTABLE_SHIFT:
00E98D  1               ;		 	 00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F
00E98D  1  00 09 00 05  		.byte	  0,   9,   0,   5,   3,   1,   2,  12,   0,  10,   8,   6,   4,TABU, $F8,   0	; 00
00E991  1  03 01 02 0C  
00E995  1  00 0A 08 06  
00E99D  1  00 00 00 00  		.byte     0,   0,   0,   0,   0, 'Q', '!',   0,   0,   0, 'Y', 'S', 'A', 'W', '"',   0	; 10
00E9A1  1  00 51 21 00  
00E9A5  1  00 00 59 53  
00E9AD  1  00 43 58 44  		.byte	  0, 'C', 'X', 'D', 'E', '$', $15,   0,   0, ' ', 'V', 'F', 'T', 'R', '%',   0	; 20
00E9B1  1  45 24 15 00  
00E9B5  1  00 20 56 46  
00E9BD  1  00 4E 42 48  		.byte	  0, 'N', 'B', 'H', 'G', 'Z', '&',   0,   0,   0, 'M', 'J', 'U', '/', '(',   0	; 30
00E9C1  1  47 5A 26 00  
00E9C5  1  00 00 4D 4A  
00E9CD  1  00 3B 4B 49  		.byte	  0, ';', 'K', 'I', 'O', '=', ')',   0,   0, ':', '_', 'L', $99, 'P', '?',   0	; 40
00E9D1  1  4F 3D 29 00  
00E9D5  1  00 3A 5F 4C  
00E9DD  1  00 00 8E 00  		.byte	  0,   0, $8E,   0, $9A, '?',   0,   0,   0,   0,  EOL, '*', 0,  $27,   0,   0	; 50
00E9E1  1  9A 3F 00 00  
00E9E5  1  00 00 0A 2A  
00E9ED  1  00 3E 00 00  		.byte	  0, '>',   0,   0,   0,   0,CDCH,   0,   0, '1',   0, CCLF, '7',   0,  0,   0	; 60
00E9F1  1  00 00 FE 00  
00E9F5  1  00 31 00 1E  
00E9FD  1  30 2E 1D 35  		.byte	'0', '.', CCDN, '5', CCRT, CCUP,  0,   0,  11, '+', '3', '-', '*', '9', 0,   0  ; 70
00EA01  1  1F 1C 00 00  
00EA05  1  0B 2B 33 2D  
00EA0D  1  00 00 00 07  		.byte	  0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,  0,    0,   0	; 80
00EA11  1  00 00 00 00  
00EA15  1  00 00 00 00  
00EA1D  1               
00EA1D  1               ALTGR_TABLE_IND:
00EA1D  1  15           		.byte	$15	; q = @
00EA1E  1  61           		.byte	$61	; <> = |
00EA1F  1  5B           		.byte	$5B	; *+ = ~
00EA20  1  4E           		.byte	$4E	; ?ß = \
00EA21  1  3E           		.byte	$3E	; 8( = [
00EA22  1  46           		.byte	$46	; 9) = ]
00EA23  1  3D           		.byte	$3D	; 7/ = {
00EA24  1  45           		.byte	$45	; 0= = }
00EA25  1               
00EA25  1  40           ALTGR_TABLE:	.byte	'@'
00EA26  1  7C           		.byte	'|'
00EA27  1  7E           		.byte	'~'
00EA28  1  5C           		.byte	'\'
00EA29  1  5B           		.byte	'['
00EA2A  1  5D           		.byte	']'
00EA2B  1  7B           		.byte	'{'
00EA2C  1  7D           		.byte	'}'
00EA2D  1               
00EA2D  1               
00EA2D  1  4A           EXT_TABLE_IND:	.byte	$4A	; /
00EA2E  1  5A           		.byte	$5A	; ENTER
00EA2F  1  69           		.byte	$69	; END
00EA30  1  6B           		.byte	$6B	; LEFT
00EA31  1  6C           		.byte	$6C	; HOME
00EA32  1  70           		.byte	$70	; INS
00EA33  1  71           		.byte	$71	; DEL
00EA34  1  72           		.byte	$72	; DOWN
00EA35  1  74           		.byte	$74	; RIGHT
00EA36  1  75           		.byte	$75	; Up
00EA37  1  7A           		.byte	$7A	; PAGE DOWN
00EA38  1  7D           		.byte	$7D	; PAGE UP
00EA39  1               
00EA39  1  2F           EXT_TABLE:	.byte	'/'	; NumPad division symbol
00EA3A  1  0A           		.byte	EOL	; ENTER
00EA3B  1  1D           		.byte	CCBT	; cursor bottom with SuperFlag
00EA3C  1  1E           		.byte	CCLF	; cursor left
00EA3D  1  1C           		.byte	CCHM	; cursor home with SuperFLag
00EA3E  1  FF           		.byte	CICH	; insert
00EA3F  1  FE           		.byte	CDCH	; delete
00EA40  1  1D           		.byte	CCDN	; cursor down
00EA41  1  1F           		.byte	CCRT	; cursor right
00EA42  1  1C           		.byte	CCUP	; cursor up
00EA43  1  1E           		.byte	CCLM	; left margin with SuperFLag
00EA44  1  1F           		.byte	CCRM	; right margin with SuperFLag
00EA45  1               
00EA45  1               EXT_TABLE_SUPERF:
00EA45  1  00           		.byte	0
00EA46  1  00           		.byte	0
00EA47  1  01           		.byte	1
00EA48  1  00           		.byte	0
00EA49  1  01           		.byte	1
00EA4A  1  00           		.byte	0
00EA4B  1  00           		.byte	0
00EA4C  1  00           		.byte	0
00EA4D  1  00           		.byte	0
00EA4E  1  00           		.byte	0
00EA4F  1  01           		.byte	1
00EA50  1  01           		.byte	1
00EA51  1               
00EA51  1               ;	.IF PLATFORM = 0
00EA51  1               ;		.include "debug16.a65"
00EA51  1               ;		.include "rs232.a65"
00EA51  1               ;	.ENDIF
00EA51  1               
00EA51  1               	.IF PLATFORM <= 1
00EA51  1               		.include "debug16.a65"
00EA51  2               ;		.include "homebrew.inc"
00EA51  2               ;		.include "myos.inc"
00EA51  2               
00EA51  2                .p816
00EA51  2                .smart
00EA51  2               
00EA51  2               ; ***********************************************
00EA51  2               ; *                                             *
00EA51  2               ; *                 DEBUG16                     *
00EA51  2               ; *             A 65816 DEBUGGER                *
00EA51  2               ; *                                             *
00EA51  2               ; *                                             *
00EA51  2               ; ***********************************************
00EA51  2               
00EA51  2               ; .ORG $A00
00EA51  2                DPAGE = $0000          ; LOCATION OF THIS APPLICATION’S
00EA51  2               
00EA51  2               ; DIRECT PAGE STORAGE
00EA51  2               ; TRACE REGISTERS
00EA51  2               
00EA51  2               ; PCREG  = $80           ; PROGRAM COUNTER
00EA51  2               ; PCREGH = PCREG+1
00EA51  2               ; PCREGB = PCREGH+1      ; INCLUDING BANK
00EA51  2               
00EA51  2               ; NCODE = $8000 ;PCREGB+1       ; NEXT CODE TO BE TRACED
00EA51  2               ;
00EA51  2               ; OPCREG = NCODE+1       ; OLD PROGRAM COUNTER VALUE
00EA51  2               ; OPCREGH = OPCREG+1
00EA51  2               ; OPCREGB = OPCREGH+1
00EA51  2               ;
00EA51  2               ; CODE = OPCREGB+1       ; CURRENT CODE TO BE TRACED
00EA51  2               ;
00EA51  2               ; OPRNDL = CODE+1        ; OPERANDS OF CURRENT
00EA51  2               ; OPRNDH = OPRNDL+1      ; INSTRUCTION
00EA51  2               ; OPRNDB = OPRNDH+1
00EA51  2               
00EA51  2               ; XREG = OPRNDB+1        ; X REGISTER
00EA51  2               ; XREGH = XREG+1
00EA51  2               
00EA51  2               ; YREG = XREGH+1         ; Y REGISTER
00EA51  2               ; YREGH = YREG+1
00EA51  2               
00EA51  2               ; AREG = YREGH+1         ; ACCUMULATOR
00EA51  2               ; AREGH = AREG+1
00EA51  2               
00EA51  2               ; STACK = AREGH+1        ; STACK POINTER
00EA51  2               ; STACKH = STACK+1
00EA51  2               
00EA51  2               ; DIRREG = STACKH+1      ; DIRECT PAGE REGISTER
00EA51  2               ; DIRREGH = DIRREG+1
00EA51  2               
00EA51  2               ; DBREG = DIRREGH+1      ; DATA BANK REGISTER
00EA51  2               
00EA51  2               ; PREG = DBREG+1         ; P STATUS REGISTER
00EA51  2               
00EA51  2               ; EBIT = PREG+1          ; E BIT
00EA51  2               
00EA51  2               ; TEMP = EBIT+2          ; TEMPORARY
00EA51  2               ; TEMPH = TEMP+1
00EA51  2               ; TEMPB = TEMPH+1
00EA51  2               
00EA51  2               ; ADDRMODE = TEMPB+1     ; ADDRESS MODE OF CURRENT OPCODE
00EA51  2               
00EA51  2               ; MNX = ADDRMODE+1       ; MNEMONIC INDEX
00EA51  2                                       ; FROM ATTRIBUTE TABLE
00EA51  2               
00EA51  2               ; OPLEN = MNX+2          ; LENGTH OF OPERATION,
00EA51  2                                       ; INCLUDING INSTRUCTION
00EA51  2               
00EA51  2                CR = EOL              ; CARRIAGE RETURN
00EA51  2               
00EA51  2               ; M = $20                ; SYBOLIC NAMES FOR
00EA51  2               ; IX = $10               ; STATUS REGISTER BITS
00EA51  2                C = $01
00EA51  2                                       ; DIRECT PAGE
00EA51  2               
00EA51  2               disass24:
00EA51  2  08           		php
00EA52  2  8B           		phb
00EA53  2  0B           		phd
00EA54  2               
00EA54  2  4B           		phk
00EA55  2  AB           		plb
00EA56  2               
00EA56  2  F4 00 00     		pea DPAGE
00EA59  2  2B           		pld
00EA5A  2               
00EA5A  2  E2 30        		sep #M+IX
00EA5C  2               		.a8
00EA5C  2               		.i8
00EA5C  2               
00EA5C  2  20 63 EA     		jsr disass16
00EA5F  2               
00EA5F  2  2B           		pld
00EA60  2  AB           		plb
00EA61  2  28           		plp
00EA62  2  6B           		rtl
00EA63  2               
00EA63  2               disass16:
00EA63  2  64 14        		stz PREG
00EA65  2  80 04        		bra disass
00EA67  2               
00EA67  2               disass8:
00EA67  2               
00EA67  2  A9 30        		lda #$30
00EA69  2  85 14        		sta PREG
00EA6B  2               
00EA6B  2               disass:
00EA6B  2               
00EA6B  2               ; Default entry point.
00EA6B  2               ; Set address to dissemble as this program, the call LIST to disassemble.
00EA6B  2               
00EA6B  2               ; LDA #0
00EA6B  2               ; STA EBIT
00EA6B  2               ; LDA #CR                ; Print a newline so we start on a new line
00EA6B  2  20 18 E0      jsr jnewline
00EA6E  2               ; LDA #<MAIN             ; Start disassembly at this program
00EA6E  2               ; STA PCREG
00EA6E  2               ; LDA #>MAIN
00EA6E  2               ; STA PCREGH
00EA6E  2               ; STZ PCREGB             ; Set bank to zero
00EA6E  2               ; JSR LIST              ; Call LIST to disassemble
00EA6E  2               ; JSR TRACE              ; Call TRACE to trace
00EA6E  2               ; RTS                    ; Return to caller
00EA6E  2               
00EA6E  2               ; ---------------------------------------L
00EA6E  2               ;
00EA6E  2               ; LIST
00EA6E  2               ; MAIN LOOP OF DISASSEMBLER FUNCTION
00EA6E  2               ;
00EA6E  2               ; ---------------------------------------L
00EA6E  2               
00EA6E  2               LIST:
00EA6E  2               DISSone:
00EA6E  2  08           		PHP                    ; SAVE ORIGINAL FLAGS
00EA6F  2               TOP1:
00EA6F  2  A9 16        		lda #22
00EA71  2  8D 48 02     		sta ADRCNT
00EA74  2               
00EA74  2               		; CLC
00EA74  2               		; XCE                    ; SET NATIVE MODE
00EA74  2               		; PHP                    ; SAVE PREVIOUS MODE
00EA74  2               
00EA74  2               		; PHD                    ; SAVE CURRENT DP
00EA74  2               		; PEA DPAGE
00EA74  2               		; PLD                    ; SET TO NEW DP
00EA74  2               
00EA74  2               TOP:            ; ANOP
00EA74  2               
00EA74  2  C2 20        		REP #M
00EA76  2  E2 10        		SEP #IX
00EA78  2               		.A16
00EA78  2               		.I8
00EA78  2               
00EA78  2  9C 56 03     		STZ MNX                ; CLEAR MNEMONIC INDEX
00EA7B  2  A5 02        		LDA PCREG              ; MOVE PROGRAM COUNTER
00EA7D  2  8D 4E 03     		STA OPCREG             ; TO ‘OLD PROGRAM COUNTER’
00EA80  2  A6 04        		LDX PCREGB             ; INCLUDING BANK
00EA82  2  8E 50 03     		STX OPCREGB
00EA85  2  A7 02        		LDA [PCREG]            ; GET NEXT INSTRUCTION
00EA87  2  AA           		TAX
00EA88  2  8E 51 03     		STX CODE               ; SAVE AS ‘CODE’
00EA8B  2               
00EA8B  2  20 39 EC     		JSR UPDATE             ; UPDATE ATTRIBUTE VARIABLES
00EA8E  2  20 AB EA     		JSR FLIST              ; FORM OBJECT CODE, MNEMONIC
00EA91  2  20 08 EB     		JSR FRMOPRND           ; FORM OPERAND FIELD
00EA94  2               
00EA94  2  20 18 E0     		jsr jnewline
00EA97  2               		; JSR PAUSE              ; CHECK FOR USER PAUSE
00EA97  2               		; BCC @QUIT
00EA97  2               		; BVC @PRINT
00EA97  2  CE 48 02     		dec ADRCNT
00EA9A  2  D0 D8        		bne TOP
00EA9C  2               
00EA9C  2               @LOOP:
00EA9C  2               ; JSR PAUSE
00EA9C  2               		.A8
00EA9C  2  20 03 E0     		jsr jchrin
00EA9F  2               ; lda IRQPS2S		;key pressed?
00EA9F  2               ; bne @LOOP		;no loop
00EA9F  2               
00EA9F  2               ; inc IRQPS2S		;reset key status
00EA9F  2               ; lda IRQPS2D
00EA9F  2  C9 1B        		cmp #ESC
00EAA1  2  F0 06        		beq @QUIT
00EAA3  2  C9 78        		cmp #'x'
00EAA5  2  F0 02        		beq @QUIT
00EAA7  2               
00EAA7  2               ; BCC @QUIT
00EAA7  2               ; BVC @LOOP
00EAA7  2               
00EAA7  2               @PRINT:
00EAA7  2               ; JSR PRINTLN            ; PRINT IT
00EAA7  2               
00EAA7  2  80 C6        		BRA TOP1                ; LOOP TIL END
00EAA9  2               
00EAA9  2               @QUIT:
00EAA9  2  28           		PLP
00EAAA  2  60           		RTS
00EAAB  2               
00EAAB  2               ; -------------------------------------------
00EAAB  2               ;
00EAAB  2               ; FLIST – FORM IMAGE OF PROGRAM COUNTER,
00EAAB  2               ; OBJECT CODE, AND MNEMONIC IN ‘LINE’
00EAAB  2               ;
00EAAB  2               ; REQUIRES ATTRIBUTE VARIABLES TO BE PREVIOUSLY INITIALIZED
00EAAB  2               ; -------------------------------------------
00EAAB  2               ;
00EAAB  2               
00EAAB  2               FLIST:
00EAAB  2               
00EAAB  2               ;		JSR CLRLN              ; BLANK ‘LINE’ VARIABLE
00EAAB  2               
00EAAB  2  E2 30        		SEP #M+IX              ; SHORT REGISTERS
00EAAD  2               		.A8
00EAAD  2               		.I8
00EAAD  2               
00EAAD  2               ;		LDY #0
00EAAD  2  AD 50 03     		LDA OPCREGB            ; GET BANK BYTE, FORM AS HEX
00EAB0  2  20 0C E0     		JSR jprinthex          ; STRING
00EAB3  2  A9 3A        		LDA #':'               ; BANK DELIMITER
00EAB5  2               ;		STA LINE,Y
00EAB5  2               ;		INY
00EAB5  2  20 06 E0     		jsr jchrout
00EAB8  2  AD 4F 03     		LDA OPCREGH            ; GET BYTES OF PROGRAM COUNTER
00EABB  2  20 0C E0     		JSR jprinthex             ; FORM AS HEX STRING IN
00EABE  2  AD 4E 03     		LDA OPCREG             ; LINE
00EAC1  2  20 0C E0     		JSR jprinthex
00EAC4  2  20 1B E0     		jsr jspace
00EAC7  2               
00EAC7  2               ;		LDY #10
00EAC7  2               ;		LDA CODE               ; STORE OPCODE AS HEX STRING
00EAC7  2               ;		JSR jprinthex
00EAC7  2  A2 00        		LDX #0
00EAC9  2               
00EAC9  2  EC 58 03     MORE: 		CPX OPLEN         	; LIST OPERANDS, IF ANY
00EACC  2  90 08        		bcc PRINTOP
00EACE  2  20 1B E0     		jsr jspace
00EAD1  2  20 1B E0     		jsr jspace
00EAD4  2  80 06        		bra PRINTSPACE
00EAD6  2               PRINTOP:
00EAD6  2  BD 51 03     		LDA OPRNDL-1,X
00EAD9  2  20 0C E0     		JSR jprinthex
00EADC  2               PRINTSPACE:
00EADC  2  20 1B E0     		jsr jspace
00EADF  2  E8           		INX
00EAE0  2  E0 04        		cpx #4
00EAE2  2  D0 E5        		BNE MORE
00EAE4  2               
00EAE4  2               DONE:
00EAE4  2  20 1B E0     		jsr jspace
00EAE7  2  C2 30        		REP #M+IX
00EAE9  2               		.A16
00EAE9  2               		.I16
00EAE9  2               
00EAE9  2  AD 56 03     		LDA MNX                ; GET MNEMONIC INDEX,
00EAEC  2  0A           		ASL A                  ; MULTIPLY BY THREE
00EAED  2  18           		CLC                    ; (TIMES TWO PLUS SELF)
00EAEE  2  6D 56 03     		ADC MNX
00EAF1  2  18           		CLC
00EAF2  2  69 32 EF     		ADC #MN
00EAF5  2  85 11        		sta TEMP                   ; INDEX INTO MNEMONIC TABLE
00EAF7  2               
00EAF7  2  E2 30        		sep #M+IX
00EAF9  2               		.A8
00EAF9  2               		.I8
00EAF9  2               
00EAF9  2  A0 00        		ldy #0
00EAFB  2               MOVE:
00EAFB  2  B1 11        		lda (TEMP),y
00EAFD  2  20 06 E0     		jsr jchrout
00EB00  2  C8           		iny
00EB01  2  C0 03        		cpy #3
00EB03  2  D0 F6        		bne MOVE
00EB05  2               
00EB05  2               		; LDY #LINE+20           ; COPY INTO ‘LINE’
00EB05  2               		; LDA #2
00EB05  2               		;MOVE:
00EB05  2               		; MVN 0,0
00EB05  2  4C 1B E0     		jmp jspace
00EB08  2               
00EB08  2               		; RTS
00EB08  2               
00EB08  2               ; ---------------------------------------------
00EB08  2               ;
00EB08  2               ; FRMOPRND – –
00EB08  2               ; FORMS OPERAND FIELD OF DISASSEMBLED INSTRUCTION
00EB08  2               ;
00EB08  2               ; OPLEN, ADDRMODE, AND OPRND MUST HAVE BEEN
00EB08  2               ; INITIALIZED BY ‘UPDATE’
00EB08  2               ; ---------------------------------------------
00EB08  2               ;
00EB08  2               
00EB08  2               FRMOPRND:
00EB08  2  E2 30        		SEP #M+IX
00EB0A  2               		.A8
00EB0A  2               		.I8
00EB0A  2               
00EB0A  2  A0 1C        		LDY #28			; OFF SET INTO ‘LINE’ FOR OPERAND
00EB0C  2               					; TO BEGIN
00EB0C  2  AD 55 03     		LDA ADDRMODE 		; GET ADDRESS MODE, MULTIPLY BY
00EB0F  2  0A           		ASL A        		; TWO, JUMP THROUGH ADDRESS
00EB10  2  AA           		TAX          		; MODE JUMP TABLE TO PROPER
00EB11  2  7C 46 F0     		JMP (MODES,X)		; HANDLER
00EB14  2               
00EB14  2               FIMM:					; IMMEDIATE MODE – –
00EB14  2  A9 23        		LDA #'#'		; OUTPUT POUND SIGN,
00EB16  2               ;		STA LINE,Y		; ONE OR TWO
00EB16  2               ;		INY			; OPERAND BYTES, DEPENDING
00EB16  2  20 06 E0     		jsr jchrout
00EB19  2  AD 58 03     		LDA OPLEN		; ON OPLEN
00EB1C  2  C9 02        		CMP #2
00EB1E  2  F0 03        		BEQ GOSHORT
00EB20  2  4C 1F EC     		JMP PODB
00EB23  2  4C 1B EC     GOSHORT:	JMP POB
00EB26  2               
00EB26  2               FABS:                  			; ABSOLUTE MODE – –
00EB26  2  4C 1F EC     		JMP PODB              	; JUST OUTPUT A DOUBLE BYTE
00EB29  2               
00EB29  2               FABSL:                  		; ABSOLUTE LONG – –
00EB29  2  4C 23 EC     		JMP POTB		; OUTPUT A TRIPLE BYTE
00EB2C  2               
00EB2C  2               FDIR:                   		; DIRECT MODE – –
00EB2C  2  4C 1B EC     		JMP POB			; OUTPUT A SINGLE BYTE
00EB2F  2               
00EB2F  2               FACC:					; ACCUMULATOR – –
00EB2F  2  A9 41        		LDA #'A'		; JUST AN A
00EB31  2               ; STA LINE,Y
00EB31  2  4C 06 E0     		jmp jchrout
00EB34  2               ; RTS
00EB34  2               
00EB34  2               FIMP:                   		; IMPLIED – –
00EB34  2  60           		RTS                    	; NO OPERAND
00EB35  2               
00EB35  2               FINDINX:                ; INDIRECT INDEXED – –
00EB35  2  20 BB EB      JSR FIND               ; CALL ‘INDIRECT’, THEN FALL
00EB38  2                                       ; THROUGH TO INDEXED BY Y
00EB38  2               
00EB38  2               FINY:                   ; INDEXED BY Y MODES – –
00EB38  2  A9 2C         LDA #','               ; TACK ON A ‘COMMA,Y'
00EB3A  2  20 06 E0      jsr jchrout
00EB3D  2               ; STA LINE,Y
00EB3D  2               ; INY
00EB3D  2  A9 59         LDA #'Y'
00EB3F  2               ; STA LINE,Y
00EB3F  2  4C 06 E0      jmp jchrout
00EB42  2               ; RTS
00EB42  2               
00EB42  2               FINDINXL:               ; INDIRECT INDEXED LONG – –
00EB42  2  20 C8 EB      JSR FINDL              ; CALL ‘INDIRECT LONG', THEN
00EB45  2  4C 38 EB      JMP FINY               ; EXIT THROUGH INDEXED BY Y
00EB48  2               
00EB48  2               FINXIND:                ; INDEX INDIRECT – –
00EB48  2  A9 28         LDA #'('               ; PARENTHESIS
00EB4A  2               ; STA LINE,Y
00EB4A  2               ; INY
00EB4A  2  20 06 E0      jsr jchrout
00EB4D  2  20 1B EC      JSR POB                ; A SINGLE BYTE – –
00EB50  2  20 64 EB      JSR FINX               ; COMMA, X
00EB53  2  A9 29         LDA #')'               ; CLOSE.
00EB55  2               ; STA LINE,Y
00EB55  2               ; RTS
00EB55  2  4C 06 E0      jmp jchrout
00EB58  2               
00EB58  2               FDIRINXX:               ; DIRECT INDEXED BY X – –
00EB58  2  20 1B EC      JSR POB                ; OUTPUT A BYTE,
00EB5B  2  4C 64 EB      JMP FINX               ; TACK ON COMMA, X
00EB5E  2               
00EB5E  2               FDIRINXY:               ; DIRECT INDEXED BY Y – –
00EB5E  2  20 1B EC      JSR POB                ; OUTPUT A BYTE,
00EB61  2  4C 38 EB      JMP FINY               ; TACK ON COMMA, Y
00EB64  2               
00EB64  2               FINX:                   ; INDEXED BY X – –
00EB64  2  A9 2C         LDA #','               ; TACK ON A
00EB66  2  20 06 E0      jsr jchrout
00EB69  2               ; STA LINE,Y             ; COMMA, X
00EB69  2               ; INY                    ; (USED BY SEVERAL
00EB69  2  A9 58         LDA #'X'               ; MODES)
00EB6B  2  4C 06 E0      jmp jchrout
00EB6E  2               ; STA LINE,Y
00EB6E  2               ; INY
00EB6E  2               ; RTS
00EB6E  2               
00EB6E  2               FABSX:                  ; ABSOLUTE INDEXED BY X – –
00EB6E  2  20 1F EC      JSR PODB               ; OUTPUT A DOUBLE BYTE,
00EB71  2  4C 64 EB      JMP FINX               ; TACK ON A COMMA, X
00EB74  2               
00EB74  2               FABSLX:                 ; ABSOLUTE LONG BY X – –
00EB74  2  20 23 EC      JSR POTB               ; OUTPUT A TRIPLE BYTE,
00EB77  2  4C 64 EB      JMP FINX               ; TACK ON COMMA, X
00EB7A  2               
00EB7A  2               FABSY:                  ; ABSOLUTE Y – –
00EB7A  2  20 1F EC      JSR PODB               ; OUTPUT A DOUBLE BYTE,
00EB7D  2  4C 38 EB      JMP FINY               ; TACK ON COMMA,Y
00EB80  2               
00EB80  2               FPCRL:
00EB80  2               FPCR:                   ; PROGRAM COUNTER RELATIVE – –
00EB80  2  A9 FF         LDA #$FF               ; SIGN EXTEND OPERAND
00EB82  2  EB            XBA
00EB83  2  AD 52 03      LDA OPRNDL
00EB86  2  C2 21         REP #M+C
00EB88  2               .A16
00EB88  2  30 03         BMI OK
00EB8A  2  29 7F 00      AND #$7F
00EB8D  2  6D 4E 03     OK: ADC OPCREG          ; ADD TO PROGRAM COUNTER
00EB90  2  1A            INC A                  ; ADD TWO, WITHOUT CARRY
00EB91  2  1A            INC A
00EB92  2  8D 52 03      STA OPRNDL             ; STORE AS NEW ‘OPERAND'
00EB95  2               
00EB95  2  E2 20         SEP #M
00EB97  2                .A8
00EB97  2               
00EB97  2  4C 1F EC      JMP PODB ; NOW JUST DISPLAY A DOUBLE BYTE
00EB9A  2               
00EB9A  2               FCPRL:                  ; PROGRAM COUNTER RELATIVE LONG
00EB9A  2               
00EB9A  2  C2 21         REP #M+C
00EB9C  2                .A16
00EB9C  2               
00EB9C  2  AD 52 03      LDA OPRNDL             ; JUST ADD THE OPERAND
00EB9F  2  6D 4E 03      ADC OPCREG
00EBA2  2  18            CLC                    ; BUMP BY THREE, PAST INSTRCTION
00EBA3  2  69 03 00      ADC #3
00EBA6  2  8D 52 03      STA OPRNDL             ; STORE AS NEW ‘OPERAND'
00EBA9  2               
00EBA9  2  E2 20         SEP #M
00EBAB  2                .A8
00EBAB  2               
00EBAB  2  4C 1F EC      JMP PODB               ; PRINT A DOUBLE BYTE
00EBAE  2               
00EBAE  2               FABSIND:                ; ABSOLUTE INDIRECT
00EBAE  2  A9 28         LDA #'('               ; SURROUND A DOUBLE BYTE
00EBB0  2  20 06 E0      jsr jchrout
00EBB3  2               ; STA LINE,Y             ; WITH PARENTHESES
00EBB3  2               ; INY
00EBB3  2  20 1F EC      JSR PODB
00EBB6  2  A9 29         LDA #')'
00EBB8  2               ; STA LINE,Y
00EBB8  2  4C 06 E0      jmp jchrout
00EBBB  2               ; RTS
00EBBB  2               
00EBBB  2               FIND:                   ; INDIRECT – –
00EBBB  2  A9 28         LDA #'('               ; SURROUND A SINGLE BYTE
00EBBD  2  20 06 E0      jsr jchrout
00EBC0  2                ;STA LINE,Y             ; WITH PARENTESES
00EBC0  2                ;INY
00EBC0  2  20 1B EC      JSR POB
00EBC3  2  A9 29         LDA #')'
00EBC5  2  4C 06 E0      jmp jchrout
00EBC8  2               ; STA LINE,Y
00EBC8  2               ; INY
00EBC8  2               ; RTS
00EBC8  2               
00EBC8  2               FINDL:                  ; INDIRECT LONG – –
00EBC8  2  A9 5B         LDA #'['               ; SURROUND A SINGLE BYTE'
00EBCA  2  20 06 E0      jsr jchrout
00EBCD  2               
00EBCD  2               ; STA LINE,Y             ; WITH SQUARE BRACKTS
00EBCD  2               ; INY
00EBCD  2  20 1B EC      JSR POB
00EBD0  2  A9 5D         LDA #']'
00EBD2  2               ; STA LINE,Y
00EBD2  2               ; INY
00EBD2  2  4C 06 E0      jmp jchrout
00EBD5  2               ; RTS
00EBD5  2               
00EBD5  2               FABSINXIND:             ; ABSOLUTE INDIRECT INDEXED
00EBD5  2  A9 28         LDA #'('
00EBD7  2               ; STA LINE,Y             ; SURROUND A CALL TO ‘ABSOLUTE
00EBD7  2               ; INY                    ; INDEXED' WITH PARENTHESES
00EBD7  2  20 06 E0      jsr jchrout
00EBDA  2  20 6E EB      JSR FABSX
00EBDD  2  A9 29         LDA #')'
00EBDF  2               ; STA LINE,Y
00EBDF  2               ; RTS
00EBDF  2  4C 06 E0      jmp jchrout
00EBE2  2               
00EBE2  2               FSTACK:                 ; STACK – – IMPLIED
00EBE2  2  60            RTS
00EBE3  2               
00EBE3  2               FSTACKREL:              ; STACK RELATIVE
00EBE3  2  20 2C EB      JSR FDIR               ; JUST LIKE
00EBE6  2  A9 2C         LDA #','                ; DIRECT INDEXED, BUT WITH
00EBE8  2  20 06 E0      jsr jchrout
00EBEB  2               ; STA LINE,Y             ; AN ‘S'
00EBEB  2               ; INY
00EBEB  2  A9 53         LDA #'S'
00EBED  2               ; STA LINE,Y
00EBED  2               ; INY
00EBED  2               ; RTS
00EBED  2  4C 06 E0      jmp jchrout
00EBF0  2               
00EBF0  2               FSRINDINX:              ; STACK RELATIVE INDIRECT INDEX
00EBF0  2  A9 28         LDA #'('
00EBF2  2               ; STA LINE,Y             ; SURROUND STACK RELATIVE WITH
00EBF2  2               ; INY                    ; PARENTHESES, THEN
00EBF2  2  20 06 E0      jsr jchrout
00EBF5  2  20 E3 EB      JSR FSTACKREL
00EBF8  2  A9 29         LDA #')'
00EBFA  2  20 06 E0      jsr jchrout
00EBFD  2               
00EBFD  2               ; STA LINE,Y
00EBFD  2               ; INY
00EBFD  2  4C 38 EB      JMP FINY               ; TACK ON A COMMA,Y
00EC00  2               
00EC00  2               FBLOCK:                 ; BLOCK MOVE
00EC00  2               
00EC00  2               ; REP #M
00EC00  2               ; LDA OPRNDL             ; MAKE HUMAN-READABLE:
00EC00  2               ; XBA                    ; SWAP SOURCE, DEST
00EC00  2               ; STA OPRNDL
00EC00  2               
00EC00  2  E2 20         SEP #M
00EC02  2               ; jmp PODB
00EC02  2  AD 52 03      LDA OPRNDL
00EC05  2  20 1B EC      JSR POB                ; OUTPUT THE SOURCE
00EC08  2  A9 2C         LDA #','               ; THEN COMMA
00EC0A  2  20 06 E0      jsr jchrout
00EC0D  2               
00EC0D  2               ; STA LINE,Y
00EC0D  2               ; INY
00EC0D  2               
00EC0D  2  C2 20         REP #M
00EC0F  2  AD 52 03      LDA OPRNDL
00EC12  2  EB            XBA                    ; SWAP DEST INTO OPRNDL
00EC13  2  8D 52 03      STA OPRNDL             ; THEN PRINT ONE BYTE
00EC16  2  E2 20         SEP #M
00EC18  2  4C 1B EC      JMP POB
00EC1B  2               
00EC1B  2               ;-----------------------------------------------
00EC1B  2               ;
00EC1B  2               ; POB, PODB, POTB
00EC1B  2               ; PUT OPERAND (DOUBLE, TRIPLE) BYTE
00EC1B  2               ;
00EC1B  2               ; PUTS OPRNDL (OPRNDH, OPRNDB) IN LINE AS HEX VALUE
00EC1B  2               ; WITH ‘$' PREFIX
00EC1B  2               ;
00EC1B  2               ; ASSUMES SHORT ACCUMULATOR AND INSEX REGISTERS
00EC1B  2               ; (CALLED BY FOPRND)
00EC1B  2               ;-----------------------------------------------
00EC1B  2               ;
00EC1B  2               
00EC1B  2               POB:
00EC1B  2                .A8
00EC1B  2                .I8
00EC1B  2               
00EC1B  2               ; PRINT:
00EC1B  2  A2 00         LDX #0                 ; ONE OPERAND BYTE
00EC1D  2  80 06         BRA IN                 ; SKIP
00EC1F  2               PODB:
00EC1F  2  A2 01         LDX #1                 ; TWO OPERAND BYTES
00EC21  2  80 02         BRA IN                 ; SKIP
00EC23  2               POTB:
00EC23  2  A2 02         LDX #2                 ; THREE OPERAND BYTES
00EC25  2                                       ; FALL THROUGH
00EC25  2  A9 24        IN: LDA #'$'            ; PRINT LEAD-IN
00EC27  2               ; STA LINE,Y
00EC27  2               ; INY
00EC27  2  20 06 E0      jsr jchrout
00EC2A  2               
00EC2A  2  BD 52 03     @MORE: LDA OPRNDL,X     ; LOOP THROUGH OPERAND
00EC2D  2  20 0C E0      JSR jprinthex          ; HIGH TO LOW
00EC30  2  CA            DEX
00EC31  2  10 F7         BPL @MORE
00EC33  2  60            RTS
00EC34  2               
00EC34  2               ; ------------------------------------------
00EC34  2               ;
00EC34  2               ; STEP CHECKS FOR USER PAUSE SIGNAL
00EC34  2               ; (KEYSTROKE)
00EC34  2               ;
00EC34  2               ; CONTAINS MACHINE-DEPENDENT CODE
00EC34  2               ; FOR APPLE II
00EC34  2               ; ------------------------------------------
00EC34  2               ;
00EC34  2               
00EC34  2               STEP:
00EC34  2               ; KEYBD = $C000         ; Apple II keyboard
00EC34  2               ; KEYSTB = $C010        ; Apple II keyboard
00EC34  2               
00EC34  2               ; KEYBD = $D011          ; Apple 1/Replica 1 keyboard
00EC34  2               ; KEYSTB = $D010         ; Apple 1/Replica 1 keyboard
00EC34  2               
00EC34  2               ; ESC = $9B              ; ESCAPE KEY (HIGH BIT SET)
00EC34  2                OVL = $40                ; MASK FOR OVERFLOW FLAG
00EC34  2               
00EC34  2               
00EC34  2  08            PHP                    ; SAVE MODES
00EC35  2  E2 30         SEP #M+IX
00EC37  2                .A8
00EC37  2                .I8
00EC37  2  80 00         BRA WAIT
00EC39  2               
00EC39  2               ;PAUSE:                  ; FOR ‘PAUSE' CALL
00EC39  2               ; PHP
00EC39  2               ; SEP #M+IX		;all 8-bit
00EC39  2               
00EC39  2               ; ldy IRQPS2S
00EC39  2               ; bne RETNCR
00EC39  2               
00EC39  2               ; inc IRQPS2S
00EC39  2               
00EC39  2               ; LDA KEYBD              ; CHECK FOR KEYPRESS
00EC39  2               ; BPL RETNCR             ; NONE; DON'T PAUSE
00EC39  2               
00EC39  2               ; LDA KEYSTB             ; CLEAR STROBE
00EC39  2               			 ; IF KEYSTROKE
00EC39  2               WAIT: ;LDA KEYBD         ; LOOP FOR NEXT KEY
00EC39  2               ; BPL WAIT
00EC39  2               ; LDA KEYSTB             ; CLEAR STROBE
00EC39  2               ; lda IRQPS2D
00EC39  2               ; CMP #ESC               ; IF ESC RETURN WITH
00EC39  2               ; beq RETEQ
00EC39  2               ; cmp #'x'
00EC39  2               ; BNE RETNESC
00EC39  2               
00EC39  2               ;RETEQ: PLP              ; CARRY CLEAR (QUIT)
00EC39  2               ; NOP
00EC39  2               ; CLC
00EC39  2               ; RTS
00EC39  2               
00EC39  2               ;RETNESC: CMP #CR
00EC39  2               ; BNE RETNCR
00EC39  2               ; PLP
00EC39  2               ; SEP #C+OVL
00EC39  2               ; RTS
00EC39  2               
00EC39  2               ;RETNCR: ;LDA KEYSTB
00EC39  2               ; PLP                    ; ELSE SET
00EC39  2               ; SEC
00EC39  2               ; CLV
00EC39  2               ; RTS                    ; (CONTINUE)
00EC39  2               
00EC39  2               ; ------------------------------------------
00EC39  2               ; PUTHEX
00EC39  2               ;
00EC39  2               ; CONVERTS NUMBER IN ACCUMULATOR TO HEX STRING
00EC39  2               ; STORED AT LINE,Y
00EC39  2               ;
00EC39  2               ; SAVE AND RESTORED MODE FLAGS
00EC39  2               ; ------------------------------------------
00EC39  2               
00EC39  2               ;PUTHEX:
00EC39  2               ; PHP                    ; SAVE MODE FLAGS
00EC39  2               ; JSR MAKEHEX            ; GET ASCII CODES A, B
00EC39  2               ; REP #M
00EC39  2               ; .A16
00EC39  2               ; STA LINE,Y             ; PUT TWO BYTES AT LINE
00EC39  2               ; INY                    ; INCREMENT Y PAST THEM
00EC39  2               ; INY
00EC39  2               ; PLP                    ; RESTORE MODE
00EC39  2               ; RTS                    ; RETURN
00EC39  2               
00EC39  2               ;MAKEHEX: SEP #M+IX      ; ALL EIGHT BIT
00EC39  2               ; .A8
00EC39  2               ; .I8
00EC39  2               ;
00EC39  2               ; PHA                    ; SAVE VALUE TO BE CONVERTED
00EC39  2               ; AND #$0F               ; MASK OFF LOW NIBBLE
00EC39  2               ; JSR FORMNIB            ; CONVERT TO HEX
00EC39  2               ; XBA                    ; STORE IN B
00EC39  2               ; PLA                    ; RESTORE VALUE
00EC39  2               ; LSR A                  ; SHIFT HIGH NIBBLE
00EC39  2               ; LSR A                  ; TO LOW NIBBLE
00EC39  2               ; LSR A
00EC39  2               ; LSR A
00EC39  2               ;                        ; FALL THROUGH TO CONVERT
00EC39  2               ;
00EC39  2               ;FORMNIB: CMP #$A        ; IF GREATER THAN OR EQUAL TO
00EC39  2               ; BCS HEXDIG             ; 10, USE DIGITS A..F
00EC39  2               ;; CLC                    ; ELSE SIMPLY ADD ‘0' TO
00EC39  2               ; ADC #'0'               ; CONVERT TO ASCII
00EC39  2               ; RTS
00EC39  2               ;
00EC39  2               ;HEXDIG: ADC #'A'-11     ; SUBTRACT 11, ADD ‘A'
00EC39  2               ; RTS                    ; (SORT OF)
00EC39  2               
00EC39  2               ; ---------------------------------------
00EC39  2               ;
00EC39  2               ; CLRLN
00EC39  2               ;
00EC39  2               ; CLEARS ‘LINE' WITH BLANKS
00EC39  2               ;
00EC39  2               ; SAVES AND RESTORES MODE FLAGS
00EC39  2               ;
00EC39  2               ; ---------------------------------------
00EC39  2               ;
00EC39  2               
00EC39  2               ;CLRLN:
00EC39  2               ; PHP
00EC39  2               ; REP #M+IX
00EC39  2               ; .A16
00EC39  2               ; .I16
00EC39  2               ;
00EC39  2               ; LDA #$2020             ; two spaces
00EC39  2               ; LDX #74
00EC39  2               ;
00EC39  2               ;LOOP: STA LINE,X
00EC39  2               ; DEX
00EC39  2               ; DEX
00EC39  2               ; BPL LOOP
00EC39  2               ; PLP
00EC39  2               ; RTS
00EC39  2               
00EC39  2               
00EC39  2               
00EC39  2               ; -----------------------------------------
00EC39  2               ;
00EC39  2               ; UPDATE
00EC39  2               ;
00EC39  2               ; UPDATES ATTRIBUTE VARIABLES BASED ON OPCODE
00EC39  2               ; PASSED IN ACCUMULATOR BY LOOKING IN ATTRIBUTE
00EC39  2               ; TABLES
00EC39  2               ;
00EC39  2               ; SAVES AND RESTORES MODE FLAGS
00EC39  2               ; -----------------------------------------
00EC39  2               
00EC39  2               UPDATE:
00EC39  2               
00EC39  2               		LDYI = $A0           ; OPCODE VALUE TIMES TWO
00EC39  2               		LDXI = $A2
00EC39  2               		CPYI = $C0
00EC39  2               		CPXI = $E0
00EC39  2               		REPI = $C2
00EC39  2               		SEPI = $E2
00EC39  2               
00EC39  2  08           		PHP                    ; SAVE STATE
00EC3A  2               
00EC3A  2  E2 30        		SEP #M+IX
00EC3C  2               		.A8
00EC3C  2               		.I8
00EC3C  2               
00EC3C  2  AA           		tax
00EC3D  2  A0 01        		ldy #1
00EC3F  2  C9 C2        		cmp #REPI		; REP opcode?
00EC41  2  D0 06        		bne UPDATE1
00EC43  2  B7 02        		lda [PCREG],y
00EC45  2  14 14        		trb PREG
00EC47  2  80 08        		bra UPDATE2
00EC49  2               
00EC49  2               UPDATE1:
00EC49  2  C9 E2        		cmp #SEPI		; SEP
00EC4B  2  D0 04        		bne UPDATE2
00EC4D  2  B7 02        		lda [PCREG],y
00EC4F  2  04 14        		tsb PREG
00EC51  2               
00EC51  2               UPDATE2:
00EC51  2  8A           		txa
00EC52  2               
00EC52  2  C2 30        		REP #M+IX
00EC54  2               		.A16
00EC54  2               		.I16
00EC54  2               
00EC54  2  29 FF 00     		AND #$FF               ; MASK HIGH BYTE
00EC57  2  0A           		ASL A                  ; TIMES TWO
00EC58  2               
00EC58  2  A8           		TAY
00EC59  2  B9 90 F0     		LDA ATRIBL,Y           ; INDEX INTO ATTRIBUTE TABLE
00EC5C  2  EB           		XBA                    ; SWAP ORDER OF ENTRIES
00EC5D  2  8D 55 03     		STA ADDRMODE           ; SAVE ADDRMODE, MNEMONIC INDEX
00EC60  2               
00EC60  2  9B           		TXY
00EC61  2  AA           		TAX                    ; ADDRMODE TO X (LOW)
00EC62  2  98           		TYA                    ; OPCODE TO ACCUM
00EC63  2               
00EC63  2  E2 30        		SEP #M+IX
00EC65  2               		.A8
00EC65  2               		.I8
00EC65  2               
00EC65  2  BC 77 F0     		LDY LENS-1,X           ; GET LENGTH OF OPERATION
00EC68  2  8C 58 03     		STY OPLEN
00EC6B  2               
00EC6B  2               ;		pha
00EC6B  2               ;		tya
00EC6B  2               ;		jsr	jprinthex
00EC6B  2               ;		pla
00EC6B  2               
00EC6B  2               
00EC6B  2               
00EC6B  2               		; LDX EBIT               ; EMULATION MODE?
00EC6B  2               		; CPX #1                 ; TEST BIT ZERO
00EC6B  2               		; BEQ SHORT              ; YES ALL IMMEDIATE ARE
00EC6B  2               					; SHORT
00EC6B  2               		; BIT #$10               ; IS BIT 4 EVEN?
00EC6B  2               		; BNE SHORT              ; NO, CAN'T BE IMMEDIATE
00EC6B  2               
00EC6B  2  C9 A2        		CMP #LDXI              ; IS IT LDX #?
00EC6D  2  F0 14        		BEQ CHKX
00EC6F  2  C9 A0        		CMP #LDYI              ; IS IT LDY #?
00EC71  2  F0 10        		BEQ CHKX
00EC73  2  C9 E0        		CMP #CPXI              ; IS IT CPX #?
00EC75  2  F0 0C        		BEQ CHKX
00EC77  2  C9 C0        		CMP #CPYI              ; IS IT CPY #?
00EC79  2  F0 08        		BEQ CHKX
00EC7B  2               
00EC7B  2  29 1F        		AND #$1F               ; IS LSD+2 ZERO?
00EC7D  2  C9 09        		CMP #$09
00EC7F  2  F0 0A        		BEQ CHKA               ; CHECK ACCUMULATOR OPCODES
00EC81  2  D0 11        		BNE SHORT
00EC83  2               
00EC83  2               CHKX:
00EC83  2  A5 14        		LDA PREG               ; IF IT IS, WHAT IS FLAG SETTING?
00EC85  2  29 10        		AND #IX
00EC87  2  F0 08        		BEQ LONG               ; CLEAR – 16 BIT MODE
00EC89  2  D0 09        		BNE SHORT              ; SET – 8 BIT MODE
00EC8B  2               
00EC8B  2               CHKA:
00EC8B  2  A5 14        		LDA PREG		; WHAT IS FLAG SETTING?
00EC8D  2  29 20        		AND #M
00EC8F  2  D0 03        		BNE SHORT		; NO, 8 BIT MODE
00EC91  2               
00EC91  2               LONG:
00EC91  2  EE 58 03     		INC OPLEN		; LONG IMMEDIATE LENGTH IS
00EC94  2               					; ONE MORE THEN FOUND IN TABLE
00EC94  2               
00EC94  2               SHORT:
00EC94  2  C2 20        		REP #M
00EC96  2               		.A16
00EC96  2               
00EC96  2  A0 00        		LDY #0
00EC98  2  80 09        		BRA LOOPIN
00EC9A  2               
00EC9A  2               LOOP1:
00EC9A  2  E2 20        		SEP #M
00EC9C  2  A7 02        		LDA [PCREG]      	; LOAD 8 BITS
00EC9E  2  99 51 03     		STA OPRNDL-1,Y         ; SAVE
00ECA1  2  C2 20        		REP #M
00ECA3  2               
00ECA3  2               LOOPIN:
00ECA3  2  E6 02        		INC PCREG       	; MOVE PC PAST NEXT INSTRUCTION
00ECA5  2  C8           		INY                    ; BYTE
00ECA6  2  CC 58 03     		CPY OPLEN              ; MOVED ALL OPERAND BYTES?
00ECA9  2  D0 EF        		BNE LOOP1              ; NO, CONTINUE
00ECAB  2               
00ECAB  2               ;DONE:
00ECAB  2  28           		PLP
00ECAC  2  60           		RTS
00ECAD  2               
00ECAD  2               ; -----------------------------------------
00ECAD  2               ;
00ECAD  2               ; PRINTLN
00ECAD  2               ;
00ECAD  2               ; MACHINE-DEPENDENT CODE TO OUTPUT
00ECAD  2               ; THE STRING STORED AT ‘LINE'
00ECAD  2               ;
00ECAD  2               ; SAVES AND RESTORED MODE FLAGS
00ECAD  2               ; -----------------------------------------
00ECAD  2               ;
00ECAD  2               
00ECAD  2               ;PRINTLN:
00ECAD  2               ;; COUT = $FDED          ; APPLE II CHARACTER OUTPUT ROUTINE
00ECAD  2               ;;COUT = $FFEF            ; APPLE 1/Replica 1 ROM CHARACTER OUTPUT ROUTINE
00ECAD  2               ;COUT = jchrout
00ECAD  2               ; PHP                    ; SAVE STATUS
00ECAD  2               ;; PHD                    ; SAVE DIRECT PAGE
00ECAD  2               ;; PEA 0                  ; SWITCH TO PAGE ZERO
00ECAD  2               ;; PLD                    ; FOR EMULATION
00ECAD  2               ;
00ECAD  2               ; SEP	#M+IX
00ECAD  2               ; .A8
00ECAD  2               ; .I8
00ECAD  2               ;; SEC                    ; SWITCH TO EMULATION
00ECAD  2               ;; XCE
00ECAD  2               ;
00ECAD  2               ; LDY #0
00ECAD  2               ;
00ECAD  2               ;@LOOP: LDA LINE,Y       ; LOOP UNTIL STRING TERMINATOR
00ECAD  2               ; BEQ @DONE              ; REACHED
00ECAD  2               ; JSR COUT
00ECAD  2               ; INY
00ECAD  2               ; BRA @LOOP
00ECAD  2               ;
00ECAD  2               ;@DONE:
00ECAD  2               ;; CLC              ; RESTORE NATIVE MODE
00ECAD  2               ;; XCE
00ECAD  2               ;; PLD                    ; RESTORE DIRECT PAGE
00ECAD  2               ; PLP                    ; RESTORE MODE FLAGS
00ECAD  2               ; RTS
00ECAD  2               
00ECAD  2               
00ECAD  2               NBRKIN:					; ENTRY FROM NATIVE MODE FOR TRACER
00ECAD  2  C2 30        		REP	#M+IX
00ECAF  2               		.A16
00ECAF  2               		.I16
00ECAF  2               
00ECAF  2  48           		PHA
00ECB0  2  DA           		PHX
00ECB1  2  5A           		PHY
00ECB2  2  8B           		PHB			; 1-byte, SAVE DATA BANK
00ECB3  2  0B           		PHD			; 2-byte, DIRECT PAGE
00ECB4  2               
00ECB4  2  F4 00 00     		PEA	DPAGE		; SWITCH TO APPLICATION
00ECB7  2  2B           		PLD			; DIRECT PAGE
00ECB8  2               
00ECB8  2               					;STACK: DIRECT L 	1	$1f0
00ECB8  2               					;	DIRECT H	2	$1f1
00ECB8  2               					;	DATA BANK	3
00ECB8  2               					;	Y L		4
00ECB8  2               					;	Y H		5
00ECB8  2               					;	X L		6
00ECB8  2               					;	X H		7
00ECB8  2               					;	A L		8
00ECB8  2               					;	A H		9
00ECB8  2               					;	PREGS		10	pushed by BRK intruction
00ECB8  2               					;	PC L		11	pushed by BRK intruction
00ECB8  2               					;	PC H		12	pushed by BRK intruction
00ECB8  2               					;	PROGRAM BANK	13	pushed by BRK intruction
00ECB8  2               					;	RETURN-1 L 	14	e.g. pushed by JSR
00ECB8  2               					;	RETURN-H H 	15
00ECB8  2               
00ECB8  2  4B           		phk			; data bank = program bank
00ECB9  2  AB           		plb
00ECBA  2               
00ECBA  2  A3 0B        		lda	11,S
00ECBC  2  3A           		dea
00ECBD  2  3A           		dea
00ECBE  2  83 0B        		sta	11,S
00ECC0  2  85 02        		sta	PCREG
00ECC2  2  8D 4E 03     		sta	OPCREG
00ECC5  2               
00ECC5  2               
00ECC5  2  E2 30        		sep	#M+IX
00ECC7  2               		.A8
00ECC7  2               		.I8
00ECC7  2               
00ECC7  2  64 10        		stz	DEVICNO
00ECC9  2               
00ECC9  2  A3 0D        		lda	13,S
00ECCB  2  85 04        		sta	PCREGB
00ECCD  2  8D 50 03     		sta	OPCREGB
00ECD0  2               
00ECD0  2  AD 4D 03     		lda	NCODE
00ECD3  2  D0 09        		bne	NOBRK
00ECD5  2               
00ECD5  2  C2 20        		rep	#M
00ECD7  2  A3 0B        		lda	11,S
00ECD9  2  1A           		ina
00ECDA  2  83 0B        		sta	11,S
00ECDC  2  E2 20        		sep	#M
00ECDE  2               
00ECDE  2  AD 4D 03     NOBRK:		lda	NCODE
00ECE1  2  87 02        		sta	[PCREG]
00ECE3  2  8D 51 03     		sta	CODE
00ECE6  2               
00ECE6  2  20 1B E0     		jsr	jspace
00ECE9  2  20 18 E0     		jsr	jnewline
00ECEC  2  20 39 EC     		jsr	UPDATE		; UPDATE ATTRIBUTE VARIABLES
00ECEF  2  20 AB EA     		jsr	FLIST		; FORM OBJECT CODE, MNEMONIC
00ECF2  2  20 08 EB     		jsr	FRMOPRND
00ECF5  2               
00ECF5  2  A2 28        		ldx	#<BRKSTR
00ECF7  2  A0 EE        		ldy	#>BRKSTR
00ECF9  2  20 09 E0     		jsr	jprint
00ECFC  2               
00ECFC  2               
00ECFC  2  C2 20        		rep	#M
00ECFE  2               		.A16
00ECFE  2               
00ECFE  2               ;		ldy	#40		;print at pos 41
00ECFE  2  A3 08        		lda	8,S		;load accu from stack
00ED00  2  20 15 EE     		jsr	putword
00ED03  2               
00ED03  2  A3 06        		lda	6,S		;load X from stack
00ED05  2  20 15 EE     		jsr	putword
00ED08  2               
00ED08  2  A3 04        		lda	4,S		;load Y from stack
00ED0A  2  20 15 EE     		jsr	putword
00ED0D  2               
00ED0D  2  3B           		tsc			;load stack pointer
00ED0E  2  18           		clc
00ED0F  2  69 0D 00     		adc	#13		;add stuff from BRK routine
00ED12  2  20 15 EE     		jsr	putword
00ED15  2               
00ED15  2  A3 01        		lda	1,S		;load direct page
00ED17  2  20 15 EE     		jsr	putword
00ED1A  2               
00ED1A  2  E2 30        		sep	#M+IX
00ED1C  2               		.A8
00ED1C  2               		.I8
00ED1C  2               
00ED1C  2  A3 03        		lda	3,S		;load data bank
00ED1E  2  20 0C E0     		jsr	jprinthex
00ED21  2  20 1B E0     		jsr	jspace
00ED24  2               
00ED24  2  A2 07        		ldx 	#7
00ED26  2  A3 0A        		lda 	10,S
00ED28  2  85 14        		sta 	PREG
00ED2A  2  0A           IRQBIN:		asl
00ED2B  2  48           		pha
00ED2C  2  A9 30        		lda 	#'0'
00ED2E  2  69 00        		adc 	#0
00ED30  2               ;		iny
00ED30  2               ;		sta	LINE,y
00ED30  2  20 06 E0     		jsr	jchrout
00ED33  2  68           		pla
00ED34  2  CA           		dex
00ED35  2  10 F3        		bpl 	IRQBIN
00ED37  2               
00ED37  2  20 18 E0     		jsr	jnewline
00ED3A  2  20 08 EE     		jsr 	PRTDASH
00ED3D  2               
00ED3D  2  A2 00        		ldx 	#0
00ED3F  2  BD 7B 02     IRQDUMP2:	lda 	MONACT,x
00ED42  2  F0 1C        		beq 	IRQDUMP1
00ED44  2  8A           		txa
00ED45  2  0A           		asl
00ED46  2  0A           		asl
00ED47  2  A8           		tay
00ED48  2  B9 60 03     		lda 	MONTAB,y
00ED4B  2  85 02        		sta 	memptr
00ED4D  2  B9 61 03     		lda 	MONTAB+1,y
00ED50  2  85 03        		sta 	memptr+1
00ED52  2               
00ED52  2  A5 04        		lda	memptr+2
00ED54  2  48           		pha
00ED55  2               
00ED55  2  B9 62 03     		lda	MONTAB+2,y
00ED58  2  85 04        		sta	memptr+2
00ED5A  2  20 4B E0     		jsr 	jmemdump16
00ED5D  2  68           		pla
00ED5E  2  85 04        		sta	memptr+2
00ED60  2  E8           IRQDUMP1:	inx
00ED61  2  E0 04        		cpx 	#4
00ED63  2  D0 DA        		bne 	IRQDUMP2
00ED65  2               
00ED65  2  20 08 EE     		jsr 	PRTDASH
00ED68  2               
00ED68  2  20 18 E0     enterkey:	jsr	jnewline
00ED6B  2  A9 3E        		lda 	#'>'
00ED6D  2  20 06 E0     		jsr 	jchrout
00ED70  2  20 03 E0     		jsr 	jchrin
00ED73  2  20 06 E0     		jsr 	jchrout
00ED76  2               
00ED76  2  C9 31        		cmp	#'1'
00ED78  2  90 09                        bcc	enterm
00ED7A  2  C9 35                        cmp	#'4'+1
00ED7C  2  B0 05                        bcs	enterm
00ED7E  2  20 C9 ED     		jsr	setmonitor
00ED81  2  80 E5        		bra	enterkey
00ED83  2               
00ED83  2  C9 6D        enterm:		cmp	#'m'
00ED85  2  D0 08        		bne	enterr
00ED87  2  20 48 E0     		jsr	jsetaddress
00ED8A  2  20 21 E0     		jsr	jmemdump
00ED8D  2  80 D9        		bra	enterkey
00ED8F  2               
00ED8F  2               enterr:
00ED8F  2               		.IF PLATFORM=0
00ED8F  2  C9 72        		cmp	#'r'
00ED91  2  D0 03        		bne	enterx
00ED93  2  4C A2 E0     		jmp	reset
00ED96  2               		.ENDIF
00ED96  2               
00ED96  2  AE 4E 03     enterx:		ldx	OPCREG
00ED99  2  86 02        		stx	PCREG
00ED9B  2  AE 4F 03     		ldx	OPCREG+1
00ED9E  2  86 03        		stx	PCREG+1
00EDA0  2  C9 78        		cmp	#'x'
00EDA2  2  F0 1B        		beq	NBRKEND
00EDA4  2               
00EDA4  2  85 15        enterend:	sta	gethex_A
00EDA6  2               
00EDA6  2  AD 51 03     		lda	CODE
00EDA9  2  20 39 EC     		jsr	UPDATE
00EDAC  2  20 50 EE     		jsr	CHKSPCL		; CHECK TO SEE IF THIS CAUSES A
00EDAF  2               					; TRANSFER
00EDAF  2               
00EDAF  2  E2 30        		sep	#M+IX
00EDB1  2               		.A8
00EDB1  2               		.I8
00EDB1  2               
00EDB1  2  AD 51 03     		lda	CODE
00EDB4  2  F0 09        		beq	NBRKEND
00EDB6  2               
00EDB6  2  A7 02        		lda	[PCREG]		; GET NEXT OPCODE TO BE EXECUTED
00EDB8  2               					; (ON NEXT LOOP THROUGH)
00EDB8  2  8D 4D 03     		sta	NCODE		; SAVE IT
00EDBB  2  A9 00        		lda	#0		; PUT A BREAK ($00) THERE TO
00EDBD  2               					; REGAIN CONTROL
00EDBD  2  87 02        		sta	[PCREG]
00EDBF  2               
00EDBF  2               
00EDBF  2  E6 10        NBRKEND:	inc	DEVICNO
00EDC1  2               
00EDC1  2  C2 30        		rep	#M+IX
00EDC3  2               		.A16
00EDC3  2               		.I16
00EDC3  2               
00EDC3  2  2B           		pld
00EDC4  2  AB           		plb
00EDC5  2  7A           		ply
00EDC6  2  FA           		plx
00EDC7  2  68           		pla
00EDC8  2  40           		rti
00EDC9  2               
00EDC9  2               
00EDC9  2               setmonitor:	.A8
00EDC9  2               		.I8
00EDC9  2  38           		sec
00EDCA  2  E9 31        		sbc	#'1'
00EDCC  2  AA           		tax
00EDCD  2  BC 7B 02     		ldy	MONACT,x
00EDD0  2  F0 04        		beq	setmonitor1
00EDD2  2  9E 7B 02     		stz	MONACT,x
00EDD5  2  60           		rts
00EDD6  2               
00EDD6  2  48           setmonitor1:	pha
00EDD7  2  0A           		asl
00EDD8  2  0A           		asl
00EDD9  2  AA           		tax
00EDDA  2  20 79 E6     		jsr	inputnibble
00EDDD  2  0A           		asl
00EDDE  2  0A           		asl
00EDDF  2  0A           		asl
00EDE0  2  0A           		asl
00EDE1  2  9D 62 03     		sta	MONTAB+2,x
00EDE4  2  20 79 E6     		jsr	inputnibble
00EDE7  2  1D 62 03     		ora	MONTAB+2,x
00EDEA  2  9D 62 03     		sta	MONTAB+2,x
00EDED  2  20 FD E4     		jsr	setaddress
00EDF0  2  C9 78        		cmp	#'x'
00EDF2  2  F0 13        		beq	setmonitor9
00EDF4  2               
00EDF4  2  FA           		plx
00EDF5  2  1A           		ina
00EDF6  2  9D 7B 02     		sta	MONACT,x
00EDF9  2  8A           		txa
00EDFA  2  0A           		asl
00EDFB  2  0A           		asl
00EDFC  2  AA           		tax
00EDFD  2  A5 02        		lda	memptr
00EDFF  2  9D 60 03     		sta	MONTAB,x
00EE02  2  A5 03        		lda	memptr+1
00EE04  2  9D 61 03     		sta	MONTAB+1,x
00EE07  2  60           setmonitor9:	rts
00EE08  2               
00EE08  2               
00EE08  2  A2 4A        PRTDASH:	ldx	#74
00EE0A  2  A9 2D        		lda	#'-'
00EE0C  2  20 06 E0     prtdash1:	jsr	jchrout
00EE0F  2  CA           		dex
00EE10  2  10 FA        		bpl	prtdash1
00EE12  2  4C 18 E0     		jmp	jnewline
00EE15  2               
00EE15  2               
00EE15  2  08           putword:	php
00EE16  2  E2 30        		sep	#M+IX
00EE18  2  EB           		xba
00EE19  2  20 0C E0     		jsr	jprinthex
00EE1C  2  EB           		xba
00EE1D  2  20 22 EE     		jsr	puthexc
00EE20  2  28           		plp
00EE21  2  60           		rts
00EE22  2               
00EE22  2  20 0C E0     puthexc:	jsr 	jprinthex
00EE25  2  4C 1B E0     		jmp	jspace
00EE28  2               
00EE28  2  0A 0A        BRKSTR:		.byte	EOL, EOL
00EE2A  2               ;                                 1         2         3         4         5         6         7
00EE2A  2               ;                        1234567890123456789012345678901234567890123456789012345678901234567890123456
00EE2A  2  41 20 20 20  		.byte	"A    X    Y    SP   DIR  DB NVMXDIZC"
00EE2E  2  20 58 20 20  
00EE32  2  20 20 59 20  
00EE4E  2  0A 00        		.byte	EOL,0
00EE50  2               
00EE50  2               ;LINE:
00EE50  2               ;                                 1         2         3         4         5         6         7         8
00EE50  2               ;       	         12345678901234567890123456789012345678901234567890123456789012345678901234567890
00EE50  2               ;		.byte	"                                                                            "
00EE50  2               ;		.byte	EOL, $00
00EE50  2               
00EE50  2               ; --------------------------------------------L
00EE50  2               ; CHKSPCL
00EE50  2               ;
00EE50  2               ; CHECK CURRENT OPCODE (IN CODE) FOR SPECIAL CASES
00EE50  2               ; INSTRUCTIONS WHICH TRANSFER CONTROL (JMP, BRA, ETC.)
00EE50  2               ;
00EE50  2               ; ASSUMES SHORTA, LONGI CALLED BY EBRKIN
00EE50  2               ; --------------------------------------------L
00EE50  2               ;
00EE50  2               
00EE50  2               CHKSPCL:;	sep	#M
00EE50  2               		.A8
00EE50  2  C2 10        		rep	#IX
00EE52  2               		.I16
00EE52  2               
00EE52  2  A2 16 00     		ldx	#SCX-SCODES
00EE55  2  8A           		txa			; clear B (SCX-SCODES < 256)
00EE56  2  AD 51 03     		lda	CODE
00EE59  2               
00EE59  2  DD 1B EF     @LOOP:		cmp	SCODES,X	; CHECK TO SEE IF CURRENT OPCODE
00EE5C  2  F0 04        		beq	HIT		; IS IN EXCEPTION TABLE
00EE5E  2  CA           		dex
00EE5F  2  10 F8        		bpl	@LOOP
00EE61  2  60           		rts			; EXIT IF NOT
00EE62  2               
00EE62  2  8A           HIT:		txa			; IF INDEX WAS LESS THAN 9, IT'S
00EE63  2  C9 09        		cmp	#9		; A BRANCH
00EE65  2  B0 0F        		bcs	NOTBR
00EE67  2               
00EE67  2  4A           		lsr	A		; SEE IF ‘ODD OR EVEN'
00EE68  2  AA           		tax
00EE69  2  BD 16 EF     		lda	PMASK,X		; GET MASK TO SELECT CORRECT
00EE6C  2               					; PREG BIT
00EE6C  2  25 14        		and	PREG		; IS IT SET?
00EE6E  2               
00EE6E  2  B0 03        		bcs	BBS		; IF INDEX WAS ODD, BRANCH IF
00EE70  2               					; PREG BIT IS SET
00EE70  2  F0 09        		beq	DOBRANCH	; ELSE IF EVEN, BRANCH IF CLEAR
00EE72  2  60           		rts
00EE73  2               
00EE73  2  D0 06        BBS:		bne	DOBRANCH	; "BRANCH IF BIT SET"
00EE75  2  60           		rts
00EE76  2               
00EE76  2  0A           NOTBR:		asl	A		; NOT A BRANCH INSTRUCTION;
00EE77  2               					; MULTIPLY BY TWO
00EE77  2  AA           		tax			; AND INDEX INTO HANDLER JUMP
00EE78  2               					; TABLE
00EE78  2               ;		rep	#IX
00EE78  2  7C E8 EE     		jmp	(SPJMP-18,X)	; BIAS JUMP TABLE BY 9
00EE7B  2               
00EE7B  2               DOBRANCH:
00EE7B  2  A9 FF        		lda	#$FF		; SET ACCUMULATOR BYTE HIGH
00EE7D  2               					; (ANTICIPATE NEGATIVE)
00EE7D  2  EB           		xba			; AND SIGN EXTEND INTO X
00EE7E  2               
00EE7E  2  AD 52 03     		lda	OPRNDL
00EE81  2               ;		jsr	jprinthex
00EE81  2               
00EE81  2  C2 31        		rep	#M+IX+C		; MAKE REGS LONG; CLEAR CARRY
00EE83  2               		.A16			; (ANTICIPATE ADC)
00EE83  2               		.I16
00EE83  2               
00EE83  2  30 03        		bmi	@OK		; NUMBER WAS NEGATIVE; ALL IS OK
00EE85  2               
00EE85  2  29 7F 00     		and	#$7F		; CLEAR HIGH BYTE OF ACCUM
00EE88  2               					; (POSITIVE NUMBER)
00EE88  2               @OK:
00EE88  2  65 02        		adc	PCREG
00EE8A  2  85 02        		sta	PCREG
00EE8C  2               
00EE8C  2  E2 30        		SEP	#M+IX
00EE8E  2               		.A8
00EE8E  2               		.I8
00EE8E  2               
00EE8E  2               ;		jsr	jprinthex
00EE8E  2               ;		xba
00EE8E  2               ;		jsr	jprinthex
00EE8E  2               
00EE8E  2  E2 20        		SEP	#M		; RETURN WITH ACCUM SHORT
00EE90  2  60           		rts
00EE91  2               
00EE91  2               		.A8
00EE91  2               		.I16
00EE91  2               SBRK:					; THESE ARE NOT IMPLEMENTED!
00EE91  2               SRTI:					; (AN EXERCISE FOR READER)
00EE91  2               SCOP:
00EE91  2  60           		rts
00EE92  2               
00EE92  2               SJSRABS:;	php
00EE92  2               	;	pla
00EE92  2               	;	jsr	jprinthex
00EE92  2               	;	lda	OPRNDL+1
00EE92  2               	;	jsr	jprinthex
00EE92  2               	;	lda	OPRNDL
00EE92  2               	;	jsr	jprinthex
00EE92  2               
00EE92  2  A5 15        		lda	gethex_A	; ABSOLUTES
00EE94  2  C9 73        		cmp	#'s'
00EE96  2  F0 05        		beq	SJMPABSEX
00EE98  2               SJMPABS:
00EE98  2  AE 52 03     		ldx	OPRNDL		; MOVE OPERAND TO PC
00EE9B  2  86 02        		stx	PCREG
00EE9D  2               
00EE9D  2               ;		rep	#M
00EE9D  2               ;		txa
00EE9D  2               ;		sep	#M
00EE9D  2               ;		xba
00EE9D  2               ;		jsr	jprinthex
00EE9D  2               ;		xba
00EE9D  2               ;		jsr	jprinthex
00EE9D  2               ;		lda	PCREG+1
00EE9D  2               ;		jsr	jprinthex
00EE9D  2               ;		lda	PCREG
00EE9D  2               ;		jsr	jprinthex
00EE9D  2  60           SJMPABSEX:	rts
00EE9E  2               
00EE9E  2               SBRL:                   		; LONG BRANCH
00EE9E  2  C2 21        		REP	#M+C		; LONG ACCUM AND CLEAR CARRY
00EEA0  2               		.A16
00EEA0  2  AD 52 03     		LDA	OPRNDL		; ADD DISPLACMENT TO
00EEA3  2  65 02        		ADC	PCREG		; PROGRAM COUNTER
00EEA5  2  85 02        		STA	PCREG
00EEA7  2               ;		SEP	#M
00EEA7  2               		.A8
00EEA7  2  60           		RTS
00EEA8  2               
00EEA8  2  A5 15        SJSRABSL: 	lda	gethex_A	; ABSOLUTES
00EEAA  2  C9 73        		cmp	#'s'
00EEAC  2  F0 0A        		beq	SJMPABSLEX	; ABSOLUTE LONGS
00EEAE  2               SJMPABSL:
00EEAE  2  AE 52 03     		LDX	OPRNDL		; MOVE OPERAND, INCLUDING BANK,
00EEB1  2  86 02        		STX	PCREG		; TO PROGRAM COUNTER
00EEB3  2  AD 54 03     		LDA	OPRNDB
00EEB6  2  85 04        		STA	PCREGB
00EEB8  2  60           SJMPABSLEX:	RTS
00EEB9  2               
00EEB9  2  C2 30        SRTS:		REP	#M+IX		; RETURN
00EEBB  2               		.A16
00EEBB  2               		.I16
00EEBB  2               
00EEBB  2  A3 10        		LDA	16,S		; PEEK ON STACK
00EEBD  2  1A           		INA			; ADD ONE TO GET TRUE RETURN
00EEBE  2  85 02        		STA	PCREG		; VALUE
00EEC0  2               
00EEC0  2               ;		SEP	#M+IX
00EEC0  2               ;		.A8
00EEC0  2               ;		.I8
00EEC0  2               ;		xba
00EEC0  2               ;		jsr	jprinthex
00EEC0  2               ;		xba
00EEC0  2               ;		jsr	jprinthex
00EEC0  2               
00EEC0  2  60           		RTS
00EEC1  2               
00EEC1  2  C2 30        SRTL:		REP	#M+IX		;
00EEC3  2               		.A16
00EEC3  2               		.I16
00EEC3  2  A3 10        		LDA	16,S		; PEEK ON STACK
00EEC5  2  1A           		INA			; ADD ONE TO GET TRUE RETURN
00EEC6  2  85 02        		STA	PCREG		; VALUE
00EEC8  2               
00EEC8  2  E2 20        		SEP	#M
00EECA  2  A3 12        		LDA	18,S
00EECC  2  85 04        		STA	PCREGB
00EECE  2  60           		RTS
00EECF  2               
00EECF  2               SJMPIND:				; INDIRECT
00EECF  2  AE 52 03     		LDX	OPRNDL		; GET OPERAND
00EED2  2               
00EED2  2  C2 20        		REP	#M
00EED4  2               		.A16
00EED4  2  B5 00        		LDA	0,X		; JMP IND ALWAYS IN BANK ZERO
00EED6  2  85 02        		STA	PCREG
00EED8  2               ;		SEP	#M
00EED8  2               ;		.A8
00EED8  2  60           		RTS
00EED9  2               
00EED9  2               SJMPINDL:
00EED9  2  20 CF EE     		JSR	SJMPIND		; SAME AS JMP INDIRECT,
00EEDC  2  E8           		INX			; PLUS BANK BYTE
00EEDD  2  E8           		INX
00EEDE  2  B5 00        		LDA	0,X		; ACCUM IS SHORT NOW
00EEE0  2  85 04        		STA	PCREGB
00EEE2  2  60           		RTS
00EEE3  2               
00EEE3  2               SJMPINDX:				; INDEX JUMPS
00EEE3  2  C2 20        SJSRINDX:	REP	#M
00EEE5  2               		.A16
00EEE5  2               
00EEE5  2  18           		CLC
00EEE6  2  A3 08        		LDA	8,S		; GET X-reg (index = 6+2), LET CPU DO ADDITION
00EEE8  2  6D 52 03     		ADC	OPRNDL		; GET INSIRECT POINTER
00EEEB  2  85 11        		STA	TEMP
00EEED  2               
00EEED  2  E2 20        		SEP	#M
00EEEF  2  A5 04        		LDA	PCREGB		; INDEXED JUMPS ARE IN PROGRAM
00EEF1  2  85 13        		STA	TEMP+2		; BANK
00EEF3  2               
00EEF3  2               ;		lda	TEMP+1
00EEF3  2               ;		jsr	jprinthex
00EEF3  2               ;		lda	TEMP
00EEF3  2               ;		jsr	jprinthex
00EEF3  2               
00EEF3  2  C2 20        		REP	#M
00EEF5  2  A7 11        		LDA	[TEMP]
00EEF7  2  85 02        		STA	PCREG
00EEF9  2               ;		SEP	#M
00EEF9  2               
00EEF9  2  60           		RTS
00EEFA  2               
00EEFA  2               ;
00EEFA  2               ;
00EEFA  2               ; SP JMP
00EEFA  2               ; JUMP TABLE FOR ‘SPECIAL' OPCODE HANDLERS
00EEFA  2               ; -----------------------------------------------
00EEFA  2               ;
00EEFA  2               
00EEFA  2               SPJMP:					; JUMP TABLE FOR
00EEFA  2  91 EE        		.word SBRK		; NON-BRANCH HANDLERS
00EEFC  2  92 EE        		.word SJSRABS
00EEFE  2  91 EE        		.word SRTI
00EF00  2  B9 EE        		.word SRTS
00EF02  2  91 EE        		.word SCOP
00EF04  2  A8 EE        		.word SJSRABSL
00EF06  2  9E EE        		.word SBRL
00EF08  2  C1 EE        		.word SRTL
00EF0A  2  98 EE        		.word SJMPABS
00EF0C  2  AE EE        		.word SJMPABSL
00EF0E  2  CF EE        		.word SJMPIND
00EF10  2  E3 EE        		.word SJMPINDX
00EF12  2  D9 EE        		.word SJMPINDL
00EF14  2  E3 EE        		.word SJSRINDX
00EF16  2               
00EF16  2               ; -----------------------------------------------
00EF16  2               ;
00EF16  2               ; PMASK
00EF16  2               ; STATUS REGISTER MASKS FOR BRANCH HANDLING CODE
00EF16  2               ; -----------------------------------------------
00EF16  2               ;
00EF16  2               
00EF16  2               PMASK:                  ; MASKS FOR STATUS REGISTER
00EF16  2  80            .byte $80     ; N FLAG
00EF17  2  40            .byte $40     ; V FLAG
00EF18  2  01            .byte $01     ; C FLAG
00EF19  2  02            .byte $02     ; Z FLAG
00EF1A  2  00            .byte $00     ; BRA
00EF1B  2               
00EF1B  2               SCODES: ; SPECIAL OPCODES
00EF1B  2               
00EF1B  2  10            .byte $10     ; BPL
00EF1C  2  30            .byte $30     ; BMI
00EF1D  2  50            .byte $50     ; BVC
00EF1E  2  70            .byte $70     ; BVS
00EF1F  2  90            .byte $90     ; BCC
00EF20  2  B0            .byte $B0     ; BCS
00EF21  2  D0            .byte $D0     ; BNE
00EF22  2  F0            .byte $F0     ; BEQ
00EF23  2  80            .byte $80     ; BRA
00EF24  2  00            .byte $00     ; BRK
00EF25  2  20            .byte $20     ; JSR
00EF26  2  40            .byte $40     ; RTI
00EF27  2  60            .byte $60     ; RTS
00EF28  2  02            .byte $02     ; COP
00EF29  2  22            .byte $22     ; JSR ABSL
00EF2A  2  82            .byte $82     ; BRL
00EF2B  2  6B            .byte $6B     ; RTL
00EF2C  2  4C            .byte $4C     ; JMP ABS
00EF2D  2  5C            .byte $5C     ; JMP ABSL
00EF2E  2  6C            .byte $6C     ; JMP ()
00EF2F  2  7C            .byte $7C     ; JMP (,X)
00EF30  2  DC            .byte $DC     ; JMP [ ]
00EF31  2               SCX:
00EF31  2  FC            .byte $FC     ; JSR (,X)
00EF32  2               
00EF32  2               
00EF32  2               ;	.ENDIF
00EF32  2               
00EF32  2               
00EF32  2               MN:
00EF32  2  00 00 00      .byte $00,$00,$00
00EF35  2  41 44 43      .byte "ADC" ; 1
00EF38  2  41 4E 44      .byte "AND" ; 2
00EF3B  2  41 53 4C      .byte "ASL" ; 3
00EF3E  2  42 43 43      .byte "BCC" ; 4
00EF41  2  42 43 53      .byte "BCS" ; 5
00EF44  2  42 45 51      .byte "BEQ" ; 6
00EF47  2  42 49 54      .byte "BIT" ; 7
00EF4A  2  42 4D 49      .byte "BMI" ; 8
00EF4D  2  42 4E 45      .byte "BNE" ; 9
00EF50  2  42 50 4C      .byte "BPL" ; 10
00EF53  2  42 52 4B      .byte "BRK" ; 11
00EF56  2  42 56 43      .byte "BVC" ; 12
00EF59  2  42 56 53      .byte "BVS" ; 13
00EF5C  2  43 4C 43      .byte "CLC" ; 14
00EF5F  2  43 4C 44      .byte "CLD" ; 15
00EF62  2  43 4C 49      .byte "CLI" ; 16
00EF65  2  43 4C 56      .byte "CLV" ; 17
00EF68  2  43 4D 50      .byte "CMP" ; 18
00EF6B  2  43 50 58      .byte "CPX" ; 19
00EF6E  2  43 50 59      .byte "CPY" ; 20
00EF71  2  44 45 43      .byte "DEC" ; 21
00EF74  2  44 45 58      .byte "DEX" ; 22
00EF77  2  44 45 59      .byte "DEY" ; 23
00EF7A  2  45 4F 52      .byte "EOR" ; 24
00EF7D  2  49 4E 43      .byte "INC" ; 25
00EF80  2  49 4E 58      .byte "INX" ; 26
00EF83  2  49 4E 59      .byte "INY" ; 27
00EF86  2  4A 4D 50      .byte "JMP" ; 28
00EF89  2  4A 53 52      .byte "JSR" ; 29
00EF8C  2  4C 44 41      .byte "LDA" ; 30
00EF8F  2  4C 44 58      .byte "LDX" ; 31
00EF92  2  4C 44 59      .byte "LDY" ; 32
00EF95  2  4C 53 52      .byte "LSR" ; 33
00EF98  2  4E 4F 50      .byte "NOP" ; 34
00EF9B  2  4F 52 41      .byte "ORA" ; 35
00EF9E  2  50 48 41      .byte "PHA" ; 36
00EFA1  2  50 48 50      .byte "PHP" ; 37
00EFA4  2  50 4C 41      .byte "PLA" ; 38
00EFA7  2  50 4C 50      .byte "PLP" ; 39
00EFAA  2  52 4F 4C      .byte "ROL" ; 40
00EFAD  2  52 4F 52      .byte "ROR" ; 41
00EFB0  2  52 54 49      .byte "RTI" ; 42
00EFB3  2  52 54 53      .byte "RTS" ; 43
00EFB6  2  53 42 43      .byte "SBC" ; 44
00EFB9  2  53 45 43      .byte "SEC" ; 45
00EFBC  2  53 45 44      .byte "SED" ; 46
00EFBF  2  53 45 49      .byte "SEI" ; 47
00EFC2  2  53 54 41      .byte "STA" ; 48
00EFC5  2  53 54 58      .byte "STX" ; 49
00EFC8  2  53 54 59      .byte "STY" ; 50
00EFCB  2  54 41 58      .byte "TAX" ; 51
00EFCE  2  54 41 59      .byte "TAY" ; 52
00EFD1  2  54 53 58      .byte "TSX" ; 53
00EFD4  2  54 58 41      .byte "TXA" ; 54
00EFD7  2  54 58 53      .byte "TXS" ; 55
00EFDA  2  54 59 41      .byte "TYA" ; 56
00EFDD  2  42 52 41      .byte "BRA" ; 57
00EFE0  2  50 4C 58      .byte "PLX" ; 58
00EFE3  2  50 4C 59      .byte "PLY" ; 59
00EFE6  2  50 48 58      .byte "PHX" ; 60
00EFE9  2  50 48 59      .byte "PHY" ; 61
00EFEC  2  53 54 5A      .byte "STZ" ; 62
00EFEF  2  54 52 42      .byte "TRB" ; 63
00EFF2  2  54 53 42      .byte "TSB" ; 64
00EFF5  2               
00EFF5  2  50 45 41      .byte "PEA" ; 65
00EFF8  2  50 45 49      .byte "PEI" ; 66
00EFFB  2  50 45 52      .byte "PER" ; 67
00EFFE  2  50 4C 42      .byte "PLB" ; 68
00F001  2  50 4C 44      .byte "PLD" ; 69
00F004  2  50 48 42      .byte "PHB" ; 70
00F007  2  50 48 44      .byte "PHD" ; 71
00F00A  2  50 48 4B      .byte "PHK" ; 72
00F00D  2               
00F00D  2  52 45 50      .byte "REP" ; 73
00F010  2  53 45 50      .byte "SEP" ; 74
00F013  2               
00F013  2  54 43 44      .byte "TCD" ; 75
00F016  2  54 44 43      .byte "TDC" ; 76
00F019  2  54 43 53      .byte "TCS" ; 77
00F01C  2  54 53 43      .byte "TSC" ; 78
00F01F  2  54 58 59      .byte "TXY" ; 79
00F022  2  54 59 58      .byte "TYX" ; 80
00F025  2  58 42 41      .byte "XBA" ; 81
00F028  2  58 43 45      .byte "XCE" ; 82
00F02B  2               
00F02B  2  42 52 4C      .byte "BRL" ; 83
00F02E  2  4A 53 4C      .byte "JSL" ; 84
00F031  2  52 54 4C      .byte "RTL" ; 85
00F034  2  4D 56 4E      .byte "MVN" ; 86
00F037  2  4D 56 50      .byte "MVP" ; 87
00F03A  2  43 4F 50      .byte "COP" ; 88
00F03D  2  57 41 49      .byte "WAI" ; 89
00F040  2  53 54 50      .byte "STP" ; 90
00F043  2  57 44 4D      .byte "WDM" ; 91
00F046  2               
00F046  2               MODES:
00F046  2  xx xx         .res 2
00F048  2  14 EB         .word FIMM ; 1
00F04A  2  26 EB         .word FABS ; 2
00F04C  2  29 EB         .word FABSL ; 3
00F04E  2  2C EB         .word FDIR ; 4
00F050  2  2F EB         .word FACC ; 5
00F052  2  34 EB         .word FIMP ; 6
00F054  2  35 EB         .word FINDINX ; 7
00F056  2  42 EB         .word FINDINXL ; 8
00F058  2  48 EB         .word FINXIND ; 9
00F05A  2  58 EB         .word FDIRINXX ; 10
00F05C  2  5E EB         .word FDIRINXY ; 11
00F05E  2  6E EB         .word FABSX ; 12
00F060  2  74 EB         .word FABSLX ; 13
00F062  2  7A EB         .word FABSY ; 14
00F064  2  80 EB         .word FPCR ; 15
00F066  2  80 EB         .word FPCRL ; 16
00F068  2  AE EB         .word FABSIND ; 17
00F06A  2  BB EB         .word FIND ; 18
00F06C  2  C8 EB         .word FINDL ; 19
00F06E  2  D5 EB         .word FABSINXIND ; 20
00F070  2  E2 EB         .word FSTACK ; 21
00F072  2  E3 EB         .word FSTACKREL ; 22
00F074  2  F0 EB         .word FSRINDINX ; 23
00F076  2  00 EC         .word FBLOCK ; 24
00F078  2               
00F078  2               LENS:
00F078  2  02            .byte $02 ; IMM
00F079  2  03            .byte $03 ; ABS
00F07A  2  04            .byte $04 ; ABS LONG
00F07B  2  02            .byte $02 ; DIRECT
00F07C  2  01            .byte $01 ; ACC
00F07D  2  01            .byte $01 ; IMPLIED
00F07E  2  02            .byte $02 ; DIR IND INX
00F07F  2  02            .byte $02 ; DIR IND INX L
00F080  2  02            .byte $02 ; DIR INX IND
00F081  2  02            .byte $02 ; DIR INX X
00F082  2  02            .byte $02 ; DIR INX Y
00F083  2  03            .byte $03 ; ABS X
00F084  2  04            .byte $04 ; ABS L X
00F085  2  03            .byte $03 ; ABS Y
00F086  2  02            .byte $02 ; PCR
00F087  2  03            .byte $03 ; PCR L
00F088  2  03            .byte $03 ; ABS IND
00F089  2  02            .byte $02 ; DIR IND
00F08A  2  02            .byte $02 ; DIR IND L
00F08B  2  03            .byte $03 ; ABS INX IND
00F08C  2  01            .byte $01 ; STACK
00F08D  2  02            .byte $02 ; SR
00F08E  2  02            .byte $02 ; SR INX
00F08F  2  03            .byte $03 ; MOV
00F090  2               
00F090  2               ATRIBL:
00F090  2  0B 04         .byte 11,4  ; BRK 00
00F092  2  23 09         .byte 35,9  ; ORA D,X 01
00F094  2  58 04         .byte 88,4  ; COP (REALLY 2) 02
00F096  2  23 16         .byte 35,22 ; ORA-,X 03
00F098  2  40 04         .byte 64,4  ; TSB D 04
00F09A  2  23 04         .byte 35,4  ; ORA D 05
00F09C  2  03 04         .byte 3,4   ; ASL D 06
00F09E  2  23 13         .byte 35,19 ; ORA [D] 07
00F0A0  2  25 15         .byte 37,21 ; PHP 08
00F0A2  2  23 01         .byte 35,1  ; ORA IMM 09
00F0A4  2  03 05         .byte 3,5   ; ASL ACC 0A
00F0A6  2  47 15         .byte 71,21 ; PHD 0B
00F0A8  2  40 02         .byte 64,2  ; TSB ABS 0C
00F0AA  2  23 02         .byte 35,2  ; ORA ABS 0D
00F0AC  2  03 02         .byte 3,2   ; ASL ABS 0E
00F0AE  2  23 03         .byte 35,3  ; ORA ABS L 0F
00F0B0  2  0A 0F         .byte 10,15 ; BPL 10
00F0B2  2  23 07         .byte 35,7  ; ORA (D),Y 11
00F0B4  2  23 12         .byte 35,18 ; ORA (D) 12
00F0B6  2  23 17         .byte 35,23 ; ORA S,Y 13
00F0B8  2  3F 04         .byte 63,4  ; TRB D 14
00F0BA  2  23 0A         .byte 35,10 ; ORA D,X 15
00F0BC  2  03 0A         .byte 3,10  ; ASL D,X 16
00F0BE  2  23 08         .byte 35,8  ; ORA (DL),Y 17
00F0C0  2  0E 06         .byte 14,6  ; CLC 18
00F0C2  2  23 0E         .byte 35,14 ; ORA ABS,Y 19
00F0C4  2  19 05         .byte 25,5  ; NC ACC 1A
00F0C6  2  4D 06         .byte 77,6  ; TCS 1B
00F0C8  2  3F 02         .byte 63,2  ; TRB ABS,X 1C
00F0CA  2  23 0C         .byte 35,12 ; ORA ABS,X 1D
00F0CC  2  03 0C         .byte 3,12  ; ASL ABS,X 1E
00F0CE  2  23 0D         .byte 35,13 ; ORA ABSL,X 1F
00F0D0  2  1D 02         .byte 29,2  ; JSR ABS 20
00F0D2  2  02 07         .byte 2,7   ; AND (D, X) 21
00F0D4  2  1D 03         .byte 29,3  ; JSL ABS L 22
00F0D6  2  02 16         .byte 2,22  ; AND SR 23
00F0D8  2  07 04         .byte 7,4   ; BIT D 24
00F0DA  2  02 04         .byte 2,4   ; AND D 25
00F0DC  2  28 04         .byte 40,4  ; ROL D 26
00F0DE  2  02 13         .byte 2,19  ; AND (DL) 27
00F0E0  2  27 06         .byte 39,6  ; PLP 28
00F0E2  2  02 01         .byte 2,1   ; AND IMM 29
00F0E4  2  28 05         .byte 40,5  ; ROL ACC 2A
00F0E6  2  45 15         .byte 69,21 ; PLD 2B
00F0E8  2  07 02         .byte 7,2   ; BIT ABS 2C
00F0EA  2  02 02         .byte 2,2   ; AND ABS 2D
00F0EC  2               ; .byte 40,5  ; ROL A 2E
00F0EC  2  28 02         .byte 40,2  ; ROL ABS 2E
00F0EE  2  02 03         .byte 2,3   ; AND ABS L 2F
00F0F0  2  08 0F         .byte 8,15  ; BMI 30
00F0F2  2  02 0B         .byte 2,11  ; AND D,Y 31
00F0F4  2  02 12         .byte 2,18  ; AND (D) 32
00F0F6  2  02 17         .byte 2,23  ; AND (SR),Y 33
00F0F8  2  07 0A         .byte 7,10  ; BIT D,X 34
00F0FA  2  02 0A         .byte 2,10  ; AND D,X 35
00F0FC  2  28 0A         .byte 40,10 ; ROL D,X 36
00F0FE  2  02 08         .byte 2,8   ; AND (DL),Y 37
00F100  2  2D 06         .byte 45,6  ; SEC 38
00F102  2  19 0E         .byte 25,14 ; AND ABS,Y 39
00F104  2  15 05         .byte 21,5  ; DEC 3A
00F106  2  4E 06         .byte 78,6  ; TSC 3B
00F108  2  07 0C         .byte 7,12  ; BIT A,X 3C
00F10A  2  02 0C         .byte 2,12  ; AND ABS,X 3D
00F10C  2  28 0C         .byte 40,12 ; ROL A,X 3E
00F10E  2  02 0D         .byte 2,13  ; AND AL,X 3F
00F110  2  2A 06         .byte 42,6  ; RTI 40
00F112  2  18 09         .byte 24,9  ; EOR (D,X) 41
00F114  2  5B 04         .byte 91,4  ; WDM 42
00F116  2  18 16         .byte 24,22 ; EOR (D,X) 43
00F118  2  57 18         .byte 87,24 ; MVP 44
00F11A  2  18 04         .byte 24,4  ; EOR D 45
00F11C  2  21 04         .byte 33,4  ; LSR D 46
00F11E  2  18 13         .byte 24,19 ; EOR (DL) 47
00F120  2  24 06         .byte 36,6  ; PHA 48
00F122  2  18 01         .byte 24,1  ; EOR IMM 49
00F124  2  21 05         .byte 33,5  ; LSR ABS L 4A
00F126  2  48 06         .byte 72,6  ; PHK 4B
00F128  2  1C 02         .byte 28,2  ; JMP ABS 4C
00F12A  2  18 02         .byte 24,2  ; EOR ABS 4D
00F12C  2  21 02         .byte 33,2  ; LSR ABS 4E
00F12E  2  18 05         .byte 24,5  ; EOR ABS L 4F
00F130  2  0C 0F         .byte 12,15 ; BVC 50
00F132  2  18 07         .byte 24,7  ; EOR (D),Y 51
00F134  2  18 12         .byte 24,18 ; EOR (D) 52
00F136  2  18 17         .byte 24,23 ; EOR (SR),Y 53
00F138  2  56 18         .byte 86,24 ; MVN 54
00F13A  2  18 0A         .byte 24,10 ; EOR D,X 55
00F13C  2  21 0A         .byte 33,10 ; LSR D,X 56
00F13E  2  18 08         .byte 24,8  ; EOR (DL),Y 57
00F140  2  10 06         .byte 16,6  ; CLI 58
00F142  2  18 0E         .byte 24,14 ; EOR 59
00F144  2  3D 15         .byte 61,21 ; PHY 5A
00F146  2  4B 06         .byte 75,6  ; TCD 5B
00F148  2  1C 03         .byte 28,3  ; JMP ABSL 5C
00F14A  2  18 0C         .byte 24,12 ; EOR ABS,X 5D
00F14C  2  21 0C         .byte 33,12 ; LSR ABS,X 5E
00F14E  2  18 0D         .byte 24,13 ; EOR ABSL,X 5F
00F150  2  2B 06         .byte 43,6  ; RTS 60
00F152  2  01 09         .byte 1,9   ; ADC (D, X) 61
00F154  2  43 10         .byte 67,16 ; PER 62
00F156  2  01 16         .byte 1,22  ; ADC SR 63
00F158  2  3E 04         .byte 62,4  ; STZ D 64
00F15A  2  01 04         .byte 1,4   ; ADC D 65
00F15C  2  29 04         .byte 41,4  ; ROR D 66
00F15E  2  01 13         .byte 1,19  ; ADC (DL) 67
00F160  2  26 15         .byte 38,21 ; PLA 68
00F162  2  01 01         .byte 1,1   ; ADC 69
00F164  2  29 05         .byte 41,5  ; ROR ABSL 6A
00F166  2  55 06         .byte 85,6  ; RTL 6B
00F168  2  1C 11         .byte 28,17 ; JMP (A) 6C
00F16A  2  01 02         .byte 1,2   ; ADC ABS 6D
00F16C  2  29 02         .byte 41,2  ; ROR ABS 6E
00F16E  2  01 03         .byte 1,3   ; ADC ABSL 6F
00F170  2  0D 0F         .byte 13,15 ; BVS 70
00F172  2  01 08         .byte 1,8   ; ADC (D),Y 71
00F174  2  01 12         .byte 1,18  ; ADC (D) 72
00F176  2  01 17         .byte 1,23  ; ADC (SR),Y 73
00F178  2  3E 0A         .byte 62,10 ; STZ D,X 74
00F17A  2  01 0A         .byte 1,10  ; ADC D,X 75
00F17C  2  29 0A         .byte 41,10 ; ROR D,X 76
00F17E  2  01 08         .byte 1,8   ; ADC (DL),Y 77
00F180  2  2F 06         .byte 47,6  ; SEI 78
00F182  2  01 0E         .byte 1,14  ; ADC ABS,Y 79
00F184  2  3B 15         .byte 59,21 ; PLY 7A
00F186  2  4C 06         .byte 76,6  ; TDC 7B
00F188  2  1C 14         .byte 28,20 ; JMP (A, X) 7C
00F18A  2  01 0C         .byte 1,12  ; ADC ABS,X 7D
00F18C  2  29 0C         .byte 41,12 ; ROR ABS,X 7E
00F18E  2  01 0D         .byte 1,13  ; ADC ABSL,X 7F
00F190  2               
00F190  2               ATRIBH:
00F190  2  39 0F         .byte 57,15 ; BRA 80
00F192  2  30 09         .byte 48,9  ; STA (D, X) 81
00F194  2  53 10         .byte 83,16 ; BRL 82
00F196  2  30 16         .byte 48,22 ; STA-,S 83
00F198  2  32 04         .byte 50,4  ; STY D 84
00F19A  2  30 04         .byte 48,4  ; STA D 85
00F19C  2  31 04         .byte 49,4  ; STX D 86
00F19E  2  30 13         .byte 48,19 ; STA [ D ] 87
00F1A0  2  17 06         .byte 23,6  ; DEY 88
00F1A2  2  07 01         .byte 7,1   ; BIT IMM 89
00F1A4  2  36 06         .byte 54,6  ; TXA 8A
00F1A6  2  46 15         .byte 70,21 ; PHB 8B
00F1A8  2  32 02         .byte 50,2  ; STY ABS 8C
00F1AA  2  30 02         .byte 48,2  ; STA ABS 8D
00F1AC  2  31 02         .byte 49,2  ; STX ABS 8E
00F1AE  2  30 03         .byte 48,3  ; STA ABS L 8F
00F1B0  2  04 0F         .byte 4,15  ; BC 90
00F1B2  2  30 07         .byte 48,7  ; STA (D),Y 91
00F1B4  2  30 12         .byte 48,18 ; STA (D) 92
00F1B6  2  30 17         .byte 48,23 ; STA (SR),Y 93
00F1B8  2  32 0A         .byte 50,10 ; STY D,X 94
00F1BA  2  30 0A         .byte 48,10 ; STA D,X 95
00F1BC  2  31 0B         .byte 49,11 ; STX D,Y 96
00F1BE  2  30 08         .byte 48,8  ; STA (DL),Y 97
00F1C0  2  38 06         .byte 56,6  ; TYA 98
00F1C2  2  30 0E         .byte 48,14 ; STA ABS,Y 99
00F1C4  2  37 06         .byte 55,6  ; TXS D 9A
00F1C6  2  4F 06         .byte 79,6  ; TXY 9B
00F1C8  2  3E 02         .byte 62,2  ; STZ ABS 9C
00F1CA  2  30 0C         .byte 48,12 ; STA ABS,X 9D
00F1CC  2  3E 0C         .byte 62,12 ; STZ ABS,X 9E
00F1CE  2  30 0D         .byte 48,13 ; STA ABSL,X 9F
00F1D0  2  20 01         .byte 32,1  ; LDY IMM A0
00F1D2  2  1E 09         .byte 30,9  ; LDA (D,X) A1
00F1D4  2  1F 01         .byte 31,1  ; LDX IMM A2
00F1D6  2  1E 16         .byte 30,22 ; LDA SR A3
00F1D8  2  20 04         .byte 32,4  ; LDY D A4
00F1DA  2  1E 04         .byte 30,4  ; LDA D A5
00F1DC  2  1F 04         .byte 31,4  ; LDX D A6
00F1DE  2  1E 13         .byte 30,19 ; LDA (DL) A7
00F1E0  2  34 06         .byte 52,6  ; TAY A8
00F1E2  2  1E 01         .byte 30,1  ; LDA IMM A9
00F1E4  2  33 06         .byte 51,6  ; TAX AA
00F1E6  2  44 15         .byte 68,21 ; PLB AB
00F1E8  2  20 02         .byte 32,2  ; LDY ABS AC
00F1EA  2  1E 02         .byte 30,2  ; LDA ABS AD
00F1EC  2  1F 02         .byte 31,2  ; LDX ABS AE
00F1EE  2  1E 03         .byte 30,3  ; LDA ABS L AF
00F1F0  2  05 0F         .byte 5,15  ; BCS B0
00F1F2  2  1E 07         .byte 30,7  ; LDA (D),Y B1
00F1F4  2  1E 12         .byte 30,18 ; LDA (D) B2
00F1F6  2  1E 17         .byte 30,23 ; LDA (SR),Y B3
00F1F8  2  20 0A         .byte 32,10 ; LDY D,X B4
00F1FA  2  1E 0A         .byte 30,10 ; LDA D,X B5
00F1FC  2  1E 0B         .byte 30,11 ; LDX D,Y B6
00F1FE  2  1E 08         .byte 30,8  ; LDA (DL),Y B7
00F200  2  11 06         .byte 17,6  ; CLV B8
00F202  2  1E 0E         .byte 30,14 ; LDA ABS,Y B9
00F204  2  35 06         .byte 53,6  ; TSX BA
00F206  2  50 06         .byte 80,6  ; TYX BB
00F208  2  20 0C         .byte 32,12 ; LDY ABS,X BC
00F20A  2  1E 0C         .byte 30,12 ; LDA ABS,X BD
00F20C  2  1F 0E         .byte 31,14 ; LDX ABS,Y BE
00F20E  2  1E 0D         .byte 30,13 ; LDA ABSL,X BF
00F210  2  14 01         .byte 20,1  ; CPY C0
00F212  2  12 09         .byte 18,9  ; CMP (D,X) C1
00F214  2  49 01         .byte 73,1  ; REP C2
00F216  2  12 16         .byte 18,22 ; CMP C3
00F218  2  14 04         .byte 20,4  ; CPY D C4
00F21A  2  12 04         .byte 18,4  ; CMP D C5
00F21C  2  15 04         .byte 21,4  ; DEC D C6
00F21E  2  12 13         .byte 18,19 ; CMP (DL) C7
00F220  2  1B 06         .byte 27,6  ; INY C8
00F222  2  12 01         .byte 18,1  ; CMP IMM C9
00F224  2  16 06         .byte 22,6  ; DEX CA
00F226  2  59 06         .byte 89,6  ; WAI CB
00F228  2  14 02         .byte 20,2  ; CPY ABS CC
00F22A  2  12 02         .byte 18,2  ; CMP ABS CD
00F22C  2  15 02         .byte 21,2  ; DEC ABS CE
00F22E  2  12 03         .byte 18,3  ; CMP ABSL CF
00F230  2  09 0F         .byte 9,15  ; BNE D0
00F232  2  12 07         .byte 18,7  ; CMP (D0,Y D1
00F234  2  12 12         .byte 18,18 ; CMP (D) D2
00F236  2  12 17         .byte 18,23 ; CMP D3
00F238  2  42 04         .byte 66,4  ; PEI D D4
00F23A  2  12 0A         .byte 18,10 ; CMP D,X D5
00F23C  2  15 0A         .byte 21,10 ; DEC D,X D6
00F23E  2  12 08         .byte 18,8  ; CMP (DL),Y D7
00F240  2  0F 06         .byte 15,6  ; CLD D8
00F242  2  12 0E         .byte 18,14 ; CMP ABS,Y D9
00F244  2  3C 15         .byte 60,21 ; PHX DA
00F246  2  64 06         .byte 100,6 ; STP DB
00F248  2  1C 11         .byte 28,17 ; JMP (A) DC
00F24A  2  12 0C         .byte 18,12 ; CMP ABS,X DD
00F24C  2  15 0C         .byte 21,12 ; DEC ABS,X DE
00F24E  2  12 0D         .byte 18,13 ; CMP ABSL,X DF
00F250  2  13 01         .byte 19,1  ; CPX IMM E0
00F252  2  2C 09         .byte 44,9  ; SBC (D,X) E1
00F254  2  4A 01         .byte 74,1  ; SEP IMM E2
00F256  2  2C 16         .byte 44,22 ; SBC SR E3
00F258  2  13 04         .byte 19,4  ; CPX D E4
00F25A  2  2C 04         .byte 44,4  ; SBC D E5
00F25C  2  19 04         .byte 25,4  ; INC D E6
00F25E  2  2C 13         .byte 44,19 ; SBD (DL) E7
00F260  2  1A 06         .byte 26,6  ; INX D E8
00F262  2  2C 01         .byte 44,1  ; SBC IMM E9
00F264  2  22 06         .byte 34,6  ; NOP EA
00F266  2  51 06         .byte 81,6  ; XBA EB
00F268  2  13 02         .byte 19,2  ; CPX ABS EC
00F26A  2  2C 02         .byte 44,2  ; SBC ABS ED
00F26C  2  19 02         .byte 25,2  ; INC ABS EE
00F26E  2  2C 03         .byte 44,3  ; SBC ABSL EF
00F270  2  06 0F         .byte 6,15  ; BEQ F0
00F272  2  2C 07         .byte 44,7  ; SBC (D),Y F1
00F274  2  2C 12         .byte 44,18 ; SBC (D) F2
00F276  2  2C 17         .byte 44,23 ; SBC (SR),Y F3
00F278  2  41 02         .byte 65,2  ; PEA F4
00F27A  2  2C 0A         .byte 44,10 ; SBC D,X F5
00F27C  2  19 0A         .byte 25,10 ; INC D,X F6
00F27E  2  2C 08         .byte 44,8  ; SBC (DL),Y F7
00F280  2  2E 06         .byte 46,6  ; SED F8
00F282  2  2C 0E         .byte 44,14 ; SBC ABS,Y F9
00F284  2  3A 15         .byte 58,21 ; PLX FA
00F286  2  52 06         .byte 82,6  ; XCE FB
00F288  2  1D 14         .byte 29,20 ; JSR (A,X) FC
00F28A  2  2C 0C         .byte 44,12 ; SBC ABS,X FD
00F28C  2  19 0C         .byte 25,12 ; INC ABS,X FE
00F28E  2  2C 0D         .byte 44,13 ; SBC ABSL,X FF
00F290  2               
00F290  1               		.include "dup.a65"
00F290  2               	.IF PLATFORM  <= 1
00F290  2               		.A8
00F290  2               		.I8
00F290  2               	.ENDIF
00F290  2               
00F290  2               	.IF PLATFORM=2
00F290  2               		.include "fat16.inc"
00F290  2               		.include "atarixl.inc"
00F290  2               
00F290  2               FNAME		= $500
00F290  2               FVEC		= $2E0
00F290  2               FINIT		= $2E2
00F290  2               
00F290  2               		.ORG DUPCODE
00F290  2               	.ENDIF
00F290  2               
00F290  2               	.IF PLATFORM=3
00F290  2               		.include "fat16.inc"
00F290  2               		.include "homebrew.inc"
00F290  2               		.include "myos.inc"
00F290  2               
00F290  2               		DUPCODE		= $0A00
00F290  2               		.ORG DUPCODE
00F290  2               	.ENDIF
00F290  2               ;
00F290  2               ;
00F290  2               ;
00F290  2  4C 96 F2     		JMP	DUPINIT
00F293  2  4C 75 F3     		JMP	LOADFIL
00F296  2               
00F296  2  A9 00        DUPINIT:	LDA	#0
00F298  2  A2 1F        		LDX	#31
00F29A  2  9D 80 03     DUPINIT1:	STA	FNAME,x
00F29D  2  CA           		DEX
00F29E  2  10 FA        		BPL	DUPINIT1
00F2A0  2  A9 4C        		LDA	#$4C
00F2A2  2  8D 7C 04     		STA	JMPIND
00F2A5  2               
00F2A5  2               	.IF PLATFORM=2
00F2A5  2               		LDX	#$70
00F2A5  2               		LDA	#OPEN
00F2A5  2               		STA 	ICCOM,X
00F2A5  2               		LDA 	#4
00F2A5  2               		STA 	ICAX1,X
00F2A5  2               		STA 	ICBLH,X
00F2A5  2               		LDA 	#<KBDNAME
00F2A5  2               		STA 	ICBAL,X
00F2A5  2               		LDA 	#>KBDNAME
00F2A5  2               		STA 	ICBAH,X
00F2A5  2               		LDA 	#0
00F2A5  2               		STA 	ICBLL,X
00F2A5  2               		STA 	ICAX2,X
00F2A5  2               		JSR 	CIOV
00F2A5  2               	.ENDIF
00F2A5  2               
00F2A5  2  18           MENU:		CLC
00F2A6  2  A2 B1        		LDX	#<DUPMENU
00F2A8  2  A9 F6        		LDA	#>DUPMENU
00F2AA  2  20 1B C0     		JSR	JPRINTSTR
00F2AD  2               
00F2AD  2  20 91 F6     		JSR 	GETCHAR
00F2B0  2  20 15 C0     		JSR	JPRINT
00F2B3  2               
00F2B3  2  A2 08        		LDX	#8
00F2B5  2  DD 62 F7     FINDCMD:	CMP	CMDTABXIO,X
00F2B8  2  F0 05        		BEQ	DOCMD
00F2BA  2  CA           		DEX
00F2BB  2  10 F8        		BPL	FINDCMD
00F2BD  2  30 E6        		BMI	MENU
00F2BF  2               
00F2BF  2  E0 04        DOCMD:		CPX	#4
00F2C1  2  90 0E        		BCC	DOXIO
00F2C3  2  8A           		TXA
00F2C4  2  E9 04        		SBC	#4		;carry set = 4
00F2C6  2  0A           		ASL
00F2C7  2  AA           		TAX
00F2C8  2  BD 70 F7     		LDA	JMPTAB+1,X
00F2CB  2  48           		PHA
00F2CC  2  BD 6F F7     		LDA	JMPTAB,X
00F2CF  2  48           		PHA
00F2D0  2  60           		RTS
00F2D1  2               
00F2D1  2  BD 6B F7     DOXIO:		LDA	XIOCMD,X
00F2D4  2  A2 10        		LDX	#$10
00F2D6  2  9D 82 02     		STA	ICCOM,X
00F2D9  2               
00F2D9  2  20 F3 F2     		JSR 	PRINTSPEC
00F2DC  2               
00F2DC  2  20 F2 F5     		JSR 	GETSTR
00F2DF  2  30 6D        		BMI 	ERR
00F2E1  2               
00F2E1  2  20 2E F5     		JSR 	CORRNAME
00F2E4  2               
00F2E4  2  A2 10        		LDX	#$10
00F2E6  2  20 07 F6     		JSR 	FOPEN3
00F2E9  2  30 63        		BMI 	ERR
00F2EB  2  10 B8        		BPL 	MENU
00F2ED  2               
00F2ED  2               
00F2ED  2               
00F2ED  2  BA           EXIT:		TSX
00F2EE  2  E0 FF        		CPX	#$FF
00F2F0  2  F0 B3        		BEQ	MENU
00F2F2  2  60           EXIT1:		RTS
00F2F3  2               
00F2F3  2               
00F2F3  2  18           PRINTSPEC:	CLC
00F2F4  2  A2 88        		LDX	#<SPECSTR
00F2F6  2  A9 F7        		LDA	#>SPECSTR
00F2F8  2  4C 1B C0     		JMP	JPRINTSTR
00F2FB  2               
00F2FB  2               
00F2FB  2  18           GOTOADR:	CLC
00F2FC  2  A2 CA        		LDX	#<GOTOSTR
00F2FE  2  A9 F7        		LDA	#>GOTOSTR
00F300  2  20 1B C0     		JSR	JPRINTSTR
00F303  2               
00F303  2  20 45 F6     		JSR 	ENTERADR
00F306  2  C9 58        		CMP 	#'X'
00F308  2  F0 9B        		BEQ 	MENU
00F30A  2  20 10 F3     		JSR 	GOTOADR1
00F30D  2  4C A5 F2     		JMP 	MENU
00F310  2  6C 6B 04     GOTOADR1:	JMP 	(ASTART)
00F313  2               
00F313  2  20 F3 F2     DIR:		JSR 	PRINTSPEC
00F316  2               
00F316  2  20 F2 F5     		JSR 	GETSTR
00F319  2  30 33        		BMI 	ERR
00F31B  2               
00F31B  2  AD 80 03     		LDA 	FNAME		;only EOL entered?
00F31E  2  C9 0A        		CMP 	#EOL
00F320  2  D0 0B        		BNE 	DIR4		;no
00F322  2               
00F322  2  A2 05        		LDX 	#5		;replace with D:*.*
00F324  2  BD 9D F7     DIR3:		LDA 	DEFSPEC,X
00F327  2  9D 80 03     		STA 	FNAME,X
00F32A  2  CA           		DEX
00F32B  2  10 F7        		BPL 	DIR3
00F32D  2               
00F32D  2  20 2E F5     DIR4:		JSR 	CORRNAME
00F330  2               
00F330  2  20 27 F6     		JSR 	FOPENDIR
00F333  2  30 19        		BMI 	ERR
00F335  2               
00F335  2  20 BA F5     DIR1:		JSR 	FGETDIR
00F338  2  30 0B        		BMI 	DIR2
00F33A  2               
00F33A  2  18           		CLC
00F33B  2  A2 80        		LDX 	#<FNAME
00F33D  2  A9 03        		LDA 	#>FNAME
00F33F  2  20 1B C0     		JSR 	JPRINTSTR
00F342  2  4C 35 F3     		JMP 	DIR1
00F345  2               
00F345  2  20 3B F6     DIR2:		JSR 	FCLOSE
00F348  2  20 91 F6     		JSR 	GETCHAR
00F34B  2  4C A5 F2     		JMP 	MENU
00F34E  2               
00F34E  2  98           ERR:		TYA
00F34F  2  48           		PHA
00F350  2  20 3B F6     		JSR 	FCLOSE
00F353  2               
00F353  2  18           		CLC
00F354  2  A2 95        		LDX	#<ERRSTR
00F356  2  A9 F7        		LDA	#>ERRSTR
00F358  2  20 1B C0     		JSR	JPRINTSTR
00F35B  2               
00F35B  2  68           		PLA
00F35C  2  20 18 C0     ERRPRT:		JSR 	JPUTHEX
00F35F  2  20 91 F6     		JSR 	GETCHAR
00F362  2  4C A5 F2     		JMP 	MENU
00F365  2               
00F365  2  20 F3 F2     LOAD:		JSR 	PRINTSPEC
00F368  2               
00F368  2  20 F2 F5     		JSR 	GETSTR
00F36B  2  30 E1        		BMI 	ERR
00F36D  2  20 75 F3     		JSR 	LOADFIL
00F370  2  30 EA        		BMI 	ERRPRT
00F372  2  4C A5 F2     		JMP 	MENU
00F375  2               
00F375  2               
00F375  2  A9 2D        LOADFIL:	LDA 	#<LABRTS
00F377  2  8D 5A 02     		STA 	FVEC
00F37A  2  A9 F5        		LDA 	#>LABRTS
00F37C  2  8D 5B 02     		STA 	FVEC+1
00F37F  2               
00F37F  2  20 2E F5     		JSR 	CORRNAME
00F382  2               
00F382  2  20 FB F5     		JSR 	FOPEN
00F385  2  30 47        		BMI 	ERR1
00F387  2               
00F387  2  20 C4 F5     		JSR 	FGETST
00F38A  2  30 42        		BMI 	ERR1
00F38C  2               
00F38C  2  A9 FF        		LDA 	#$FF		;check if first 2-bytes are $FF
00F38E  2  CD 6B 04     		CMP 	ASTART		;if not, close and exit
00F391  2  D0 43        		BNE 	MCLOSE
00F393  2  CD 6C 04     		CMP 	ASTART+1
00F396  2  D0 3E        		BNE 	MCLOSE
00F398  2               
00F398  2  20 C4 F5     LOADCHU1:	JSR 	FGETST		;get start address
00F39B  2  30 31        		BMI 	ERR1
00F39D  2  20 D3 F5     LOADCHU:	JSR 	FGETEND		;get end address
00F3A0  2  30 2C        		BMI 	ERR1
00F3A2  2  20 5A F5     		JSR 	FGETCHUN	;read chunk of data
00F3A5  2  30 27        		BMI 	ERR1
00F3A7  2               
00F3A7  2  AD 5C 02     		LDA 	FINIT		;init this chunk
00F3AA  2  8D 7D 04     		STA 	JMPPTR
00F3AD  2  AD 5D 02     		LDA 	FINIT+1
00F3B0  2  8D 7E 04     		STA 	JMPPTR+1
00F3B3  2  20 7C 04     		JSR 	JMPIND
00F3B6  2               
00F3B6  2  20 C4 F5     		JSR 	FGETST		;read next 2-bytes
00F3B9  2  C0 88        		CPY 	#EOFERR		;EOF?
00F3BB  2  F0 1C        		BEQ 	FGOTO		;yes, try to start the file
00F3BD  2  98           		TYA
00F3BE  2  30 0E        		BMI 	ERR1		;error?
00F3C0  2               
00F3C0  2  A9 FF        		LDA 	#$FF		;skip if $FF $FF
00F3C2  2  CD 6B 04     		CMP 	ASTART
00F3C5  2  D0 D6        		BNE 	LOADCHU
00F3C7  2  CD 6C 04     		CMP 	ASTART+1
00F3CA  2  D0 D1        		BNE 	LOADCHU
00F3CC  2  F0 CA        		BEQ 	LOADCHU1
00F3CE  2               
00F3CE  2  98           ERR1:		TYA
00F3CF  2  48           		PHA
00F3D0  2  20 3B F6     		JSR 	FCLOSE
00F3D3  2  68           		PLA
00F3D4  2  A8           		TAY
00F3D5  2  60           		RTS
00F3D6  2               
00F3D6  2  4C 3B F6     MCLOSE:		JMP 	FCLOSE
00F3D9  2               
00F3D9  2               
00F3D9  2  20 3B F6     FGOTO:		JSR 	FCLOSE
00F3DC  2  38           		SEC
00F3DD  2  A2 79        		LDX	#<READYSTR
00F3DF  2  A9 F7        		LDA	#>READYSTR
00F3E1  2  20 1B C0     		JSR	JPRINTSTR
00F3E4  2               
00F3E4  2  20 91 F6     		JSR	GETCHAR
00F3E7  2  AD 5A 02     		LDA 	FVEC
00F3EA  2  8D 7D 04     		STA 	JMPPTR
00F3ED  2  AD 5B 02     		LDA 	FVEC+1
00F3F0  2  8D 7E 04     		STA 	JMPPTR+1
00F3F3  2  20 7C 04     		JSR 	JMPIND
00F3F6  2  A9 01        		LDA	#SUCCES
00F3F8  2  60           		RTS
00F3F9  2               
00F3F9  2  A2 A3        SAVE:		LDX	#<FROMSTR
00F3FB  2  A9 F7        		LDA	#>FROMSTR
00F3FD  2  20 1B C0     		JSR	JPRINTSTR
00F400  2  20 45 F6     		JSR 	ENTERADR
00F403  2  C9 58        		CMP 	#'X'
00F405  2  D0 03        		BNE	SAVE1
00F407  2  4C A5 F2     		JMP 	MENU
00F40A  2               
00F40A  2  AD 6B 04     SAVE1:		LDA	ASTART
00F40D  2  8D 76 04     		STA	FSTARTS
00F410  2  AD 6C 04     		LDA	ASTART+1
00F413  2  8D 77 04     		STA	FSTARTS+1
00F416  2               
00F416  2               	.IF PLATFORM <= 1
00F416  2  38           		SEC
00F417  2               	.ELSE
00F417  2               		CLC
00F417  2               	.ENDIF
00F417  2  A2 AC        		LDX	#<TOSTR
00F419  2  A9 F7        		LDA	#>TOSTR
00F41B  2  20 1B C0     		JSR	JPRINTSTR
00F41E  2  20 45 F6     		JSR 	ENTERADR
00F421  2  C9 58        		CMP 	#'X'
00F423  2  D0 03        		BNE	SAVE2
00F425  2  4C A5 F2     		JMP 	MENU
00F428  2               
00F428  2  AD 6B 04     SAVE2:		LDA	ASTART
00F42B  2  8D 78 04     		STA	FENDS
00F42E  2  AD 6C 04     		LDA	ASTART+1
00F431  2  8D 79 04     		STA	FENDS+1
00F434  2               
00F434  2  AD 79 04     		LDA	FENDS+1
00F437  2  CD 77 04     		CMP	FSTARTS+1
00F43A  2  B0 03        		BCS	SAVE8
00F43C  2  4C A5 F2     		JMP	MENU
00F43F  2  AD 78 04     SAVE8:		LDA	FENDS
00F442  2  CD 76 04     		CMP	FSTARTS
00F445  2  B0 03        		BCS	SAVE9
00F447  2  4C A5 F2     		JMP	MENU
00F44A  2               
00F44A  2  A2 FF        SAVE9:		LDX	#$FF
00F44C  2  8E 70 04     		STX	FHEADER
00F44F  2  8E 71 04     		STX	FHEADER+1
00F452  2  E8           		INX
00F453  2  8E 7A 04     		STX	FDIFF
00F456  2  8E 7B 04     		STX	FDIFF+1
00F459  2               
00F459  2  18           		CLC
00F45A  2  A2 B6        		LDX	#<INTOSTR
00F45C  2  A9 F7        		LDA	#>INTOSTR
00F45E  2  20 1B C0     		JSR	JPRINTSTR
00F461  2  20 45 F6     		JSR 	ENTERADR
00F464  2  C9 58        		CMP	#'X'
00F466  2  F0 13        		BEQ	SAVE10
00F468  2               
00F468  2  38           		SEC
00F469  2  AD 76 04     		LDA	FSTARTS
00F46C  2  ED 6B 04     		SBC	ASTART
00F46F  2  8D 7A 04     		STA	FDIFF
00F472  2  AD 77 04     		LDA	FSTARTS+1
00F475  2  ED 6C 04     		SBC	ASTART+1
00F478  2  8D 7B 04     		STA	FDIFF+1
00F47B  2               
00F47B  2  38           SAVE10:		SEC
00F47C  2  AD 76 04     		LDA	FSTARTS
00F47F  2  ED 7A 04     		SBC	FDIFF
00F482  2  8D 72 04     		STA	FSTART
00F485  2  AD 77 04     		LDA	FSTARTS+1
00F488  2  ED 7B 04     		SBC	FDIFF+1
00F48B  2  8D 73 04     		STA	FSTART+1
00F48E  2               
00F48E  2  38           		SEC
00F48F  2  AD 78 04     		LDA	FENDS
00F492  2  ED 7A 04     		SBC	FDIFF
00F495  2  8D 74 04     		STA	FEND
00F498  2  AD 79 04     		LDA	FENDS+1
00F49B  2  ED 7B 04     		SBC	FDIFF+1
00F49E  2  8D 75 04     		STA	FEND+1
00F4A1  2               
00F4A1  2               	.IF PLATFORM <= 1
00F4A1  2  38           		SEC
00F4A2  2               	.ELSE
00F4A2  2               		CLC
00F4A2  2               	.ENDIF
00F4A2  2  A2 8B        		LDX	#<(SPECSTR+3)
00F4A4  2  A9 F7        		LDA	#>(SPECSTR+3)
00F4A6  2  20 1B C0     		JSR	JPRINTSTR
00F4A9  2               
00F4A9  2  20 F2 F5     		JSR 	GETSTR
00F4AC  2  10 03        		BPL	SAVE3
00F4AE  2  4C 4E F3     		JMP 	ERR
00F4B1  2  20 2E F5     SAVE3:		JSR 	CORRNAME
00F4B4  2               
00F4B4  2  18           		CLC
00F4B5  2  A2 C0        		LDX	#<APPENDSTR
00F4B7  2  A9 F7        		LDA	#>APPENDSTR
00F4B9  2  20 1B C0     		JSR	JPRINTSTR
00F4BC  2               
00F4BC  2  20 91 F6     		JSR 	GETCHAR
00F4BF  2  A8           		TAY
00F4C0  2  20 15 C0     		JSR	JPRINT
00F4C3  2               
00F4C3  2  A2 10        		LDX 	#$10
00F4C5  2  A9 03        		LDA 	#OPEN
00F4C7  2  9D 82 02     		STA 	ICCOM,X
00F4CA  2  A9 08        		LDA	#8
00F4CC  2  C0 59        		CPY	#'Y'
00F4CE  2  D0 02        		BNE	SAVE7
00F4D0  2  09 01        		ORA	#1
00F4D2  2  20 04 F6     SAVE7:		JSR	FOPEN2
00F4D5  2  10 03        		BPL	SAVE4
00F4D7  2  4C 4E F3     		JMP	ERR
00F4DA  2               
00F4DA  2  A9 0B        SAVE4:		LDA	#PUTCHR
00F4DC  2  9D 82 02     		STA	ICCOM,X
00F4DF  2  A9 06        		LDA	#6
00F4E1  2  9D 87 02     		STA	ICBLL,X
00F4E4  2  A9 00        		LDA	#0
00F4E6  2               	.IF PLATFORM  <= 1
00F4E6  2  9D 86 02     		STA	ICBAB,X
00F4E9  2  9D 89 02     		STA	ICBLB,X
00F4EC  2               	.ENDIF
00F4EC  2  9D 88 02     		STA	ICBLH,X
00F4EF  2  A9 70        		LDA	#<FHEADER
00F4F1  2  9D 84 02     		STA	ICBAL,X
00F4F4  2  A9 04        		LDA	#>FHEADER
00F4F6  2  9D 85 02     		STA	ICBAH,X
00F4F9  2  20 0F C0     		JSR	CIOV
00F4FC  2  30 29        		BMI	SAVECLOSE
00F4FE  2               
00F4FE  2  AD 76 04     SAVE6:		LDA	FSTARTS
00F501  2  9D 84 02     		STA	ICBAL,X
00F504  2  AD 77 04     		LDA	FSTARTS+1
00F507  2  9D 85 02     		STA	ICBAH,X
00F50A  2  AD 78 04     		LDA	FENDS
00F50D  2  ED 76 04     		SBC	FSTARTS
00F510  2  9D 87 02     		STA	ICBLL,X
00F513  2  AD 79 04     		LDA	FENDS+1
00F516  2  ED 77 04     		SBC	FSTARTS+1
00F519  2  9D 88 02     		STA	ICBLH,X
00F51C  2  FE 87 02     		INC	ICBLL,X
00F51F  2  D0 03        		BNE	SAVE5
00F521  2  FE 88 02     		INC	ICBLH,X
00F524  2  20 0F C0     SAVE5:		JSR	CIOV
00F527  2  20 3B F6     SAVECLOSE:	JSR	FCLOSE
00F52A  2  4C A5 F2     		JMP	MENU
00F52D  2               
00F52D  2  60           LABRTS:		RTS
00F52E  2               
00F52E  2               	.IF PLATFORM=99
00F52E  2               DEBUG:		LDA	ASTART
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	ASTART+1
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	AEND
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	AEND+1
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	FVEC
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	FVEC+1
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	FINIT
00F52E  2               		JSR	JPUTHEX
00F52E  2               		LDA	FINIT+1
00F52E  2               		JSR	JPUTHEX
00F52E  2               		RTS
00F52E  2               	.ENDIF
00F52E  2               
00F52E  2  A9 3A        CORRNAME:	LDA 	#':'
00F530  2  CD 81 03     		CMP 	FNAME+1
00F533  2  F0 F8        		BEQ 	LABRTS
00F535  2  CD 82 03     		CMP 	FNAME+2
00F538  2  F0 F3        		BEQ 	LABRTS
00F53A  2               
00F53A  2  A2 00        		LDX 	#0
00F53C  2  BD 80 03     CORRNAM2:	LDA 	FNAME,X
00F53F  2  C9 0A        		CMP 	#EOL
00F541  2  F0 03        		BEQ 	CORRNAM1
00F543  2  E8           		INX
00F544  2  D0 F6        		BNE 	CORRNAM2
00F546  2               
00F546  2  BD 80 03     CORRNAM1:	LDA 	FNAME,X
00F549  2  9D 82 03     		STA 	FNAME+2,X
00F54C  2  CA           		DEX
00F54D  2  10 F7        		BPL 	CORRNAM1
00F54F  2  A9 44        		LDA 	#DRVCHAR
00F551  2  8D 80 03     		STA 	FNAME
00F554  2  A9 3A        		LDA 	#':'
00F556  2  8D 81 03     		STA 	FNAME+1
00F559  2  60           		RTS
00F55A  2               
00F55A  2  AD 6C 04     FGETCHUN:	LDA 	ASTART+1
00F55D  2  20 18 C0     		JSR 	JPUTHEX
00F560  2  AD 6B 04     		LDA 	ASTART
00F563  2  20 18 C0     		JSR 	JPUTHEX
00F566  2  A9 2D        		LDA 	#'-'
00F568  2  20 15 C0     		JSR 	JPRINT
00F56B  2  AD 6E 04     		LDA 	AEND+1
00F56E  2  20 18 C0     		JSR 	JPUTHEX
00F571  2  AD 6D 04     		LDA 	AEND
00F574  2  20 18 C0     		JSR 	JPUTHEX
00F577  2  A9 0A        		LDA 	#EOL
00F579  2  20 15 C0     		JSR 	JPRINT
00F57C  2               
00F57C  2  A9 2D        		LDA 	#<LABRTS
00F57E  2  8D 5C 02     		STA 	FINIT
00F581  2  A9 F5        		LDA 	#>LABRTS
00F583  2  8D 5D 02     		STA 	FINIT+1
00F586  2               
00F586  2  A2 10        		LDX 	#$10
00F588  2  38           		SEC
00F589  2               	.IF PLATFORM  <= 1
00F589  2  A9 00        		LDA	#0
00F58B  2  9D 86 02     		STA	ICBAB,X
00F58E  2  9D 89 02     		STA	ICBLB,X
00F591  2               	.ENDIF
00F591  2               
00F591  2  AD 6D 04     		LDA 	AEND
00F594  2  ED 6B 04     		SBC 	ASTART
00F597  2  9D 87 02     		STA 	ICBLL,X
00F59A  2  AD 6E 04     		LDA 	AEND+1
00F59D  2  ED 6C 04     		SBC 	ASTART+1
00F5A0  2  9D 88 02     		STA 	ICBLH,X
00F5A3  2  FE 87 02     		INC 	ICBLL,X
00F5A6  2  D0 03        		BNE 	FGETCHU1
00F5A8  2  FE 88 02     		INC 	ICBLH,X
00F5AB  2               
00F5AB  2  AD 6B 04     FGETCHU1:	LDA 	ASTART
00F5AE  2  9D 84 02     		STA 	ICBAL,X
00F5B1  2  AD 6C 04     		LDA 	ASTART+1
00F5B4  2  9D 85 02     		STA 	ICBAH,X
00F5B7  2               
00F5B7  2  4C 33 F6     		JMP 	FGET
00F5BA  2               ;
00F5BA  2               ;
00F5BA  2               ;
00F5BA  2  A2 10        FGETDIR:	LDX 	#$10
00F5BC  2  A9 05        		LDA 	#GETREC
00F5BE  2  9D 82 02     		STA 	ICCOM,X
00F5C1  2  4C 07 F6     		JMP 	FOPEN3
00F5C4  2               
00F5C4  2  A2 10        FGETST:		LDX 	#$10
00F5C6  2  A9 6B        		LDA 	#<ASTART
00F5C8  2  9D 84 02     		STA 	ICBAL,X
00F5CB  2  A9 04        		LDA 	#>ASTART
00F5CD  2  9D 85 02     		STA 	ICBAH,X
00F5D0  2  4C DF F5     		JMP 	FGET2
00F5D3  2               
00F5D3  2  A2 10        FGETEND:	LDX 	#$10
00F5D5  2  A9 6D        		LDA 	#<AEND
00F5D7  2  9D 84 02     		STA 	ICBAL,X
00F5DA  2  A9 04        		LDA 	#>AEND
00F5DC  2  9D 85 02     		STA 	ICBAH,X
00F5DF  2               
00F5DF  2  A9 02        FGET2:		LDA 	#2
00F5E1  2  9D 87 02     		STA 	ICBLL,X
00F5E4  2  A9 00        		LDA 	#0
00F5E6  2  9D 88 02     		STA 	ICBLH,X
00F5E9  2               	.IF PLATFORM  <= 1
00F5E9  2  9D 86 02     		STA	ICBAB,X
00F5EC  2  9D 89 02     		STA	ICBLB,X
00F5EF  2               	.ENDIF
00F5EF  2               
00F5EF  2  4C 33 F6     		JMP 	FGET
00F5F2  2               
00F5F2  2  A2 00        GETSTR:		LDX 	#0
00F5F4  2  A9 05        		LDA 	#GETREC
00F5F6  2  9D 82 02     		STA 	ICCOM,X
00F5F9  2  D0 0C        		BNE 	FOPEN3
00F5FB  2               
00F5FB  2  A2 10        FOPEN:		LDX 	#$10
00F5FD  2  A9 03        		LDA 	#OPEN
00F5FF  2  9D 82 02     		STA 	ICCOM,X
00F602  2  A9 04        FOPEN1:		LDA 	#4
00F604  2  9D 8A 02     FOPEN2:		STA 	ICAX1,X
00F607  2  A9 80        FOPEN3:		LDA 	#<FNAME
00F609  2  9D 84 02     		STA 	ICBAL,X
00F60C  2  A9 03        		LDA 	#>FNAME
00F60E  2  9D 85 02     		STA 	ICBAH,X
00F611  2  A9 00        		LDA 	#0
00F613  2               	.IF PLATFORM  <= 1
00F613  2  9D 86 02     		STA	ICBAB,X
00F616  2  9D 89 02     		STA	ICBLB,X
00F619  2               	.ENDIF
00F619  2  9D 87 02     		STA 	ICBLL,X
00F61C  2  9D 8B 02     		STA 	ICAX2,X
00F61F  2  A9 01        		LDA 	#1
00F621  2  9D 88 02     		STA 	ICBLH,X
00F624  2  4C 0F C0     		JMP 	CIOV
00F627  2               
00F627  2  A2 10        FOPENDIR:	LDX 	#$10
00F629  2  A9 03        		LDA 	#OPEN
00F62B  2  9D 82 02     		STA 	ICCOM,X
00F62E  2  A9 06        		LDA 	#6
00F630  2  4C 04 F6     		JMP 	FOPEN2
00F633  2               
00F633  2  A9 07        FGET:		LDA 	#GETCHR
00F635  2  9D 82 02     		STA 	ICCOM,X
00F638  2  4C 0F C0     		JMP 	CIOV
00F63B  2               
00F63B  2  A2 10        FCLOSE:		LDX 	#$10
00F63D  2  A9 0C        FCLOSE1:	LDA 	#CLOSE
00F63F  2  9D 82 02     		STA 	ICCOM,X
00F642  2  4C 0F C0     		JMP 	CIOV
00F645  2               
00F645  2  A9 00        ENTERADR:	LDA	#0
00F647  2  8D 6B 04     		STA	ASTART
00F64A  2  8D 6C 04     		STA	ASTART+1
00F64D  2  A9 04        		LDA	#4
00F64F  2  8D 6F 04     		STA	CNT
00F652  2               
00F652  2  20 91 F6     ENTERADRC:	JSR	GETCHAR
00F655  2  C9 0A        		CMP	#EOL
00F657  2  F0 33        		BEQ	ENTERADREND
00F659  2               
00F659  2  C9 58        		CMP	#'X'
00F65B  2  D0 01        		BNE	ENTERADRD
00F65D  2  60           		RTS
00F65E  2               
00F65E  2  20 15 C0     ENTERADRD:	JSR	JPRINT
00F661  2  C9 3A        		CMP	#':'
00F663  2  B0 08        		BCS	ENTERADRE
00F665  2  C9 30        		CMP	#'0'
00F667  2  90 E9        		BCC	ENTERADRC
00F669  2               
00F669  2  29 0F        		AND	#%00001111
00F66B  2  B0 0A        		BCS	ENTERADRF
00F66D  2               
00F66D  2  C9 47        ENTERADRE:	CMP	#'G'
00F66F  2  B0 E1        		BCS	ENTERADRC
00F671  2  C9 41        		CMP	#'A'
00F673  2  90 DD        		BCC	ENTERADRC
00F675  2               
00F675  2  E9 37        		SBC	#'7'
00F677  2  0A           ENTERADRF:	ASL
00F678  2  0A           		ASL
00F679  2  0A           		ASL
00F67A  2  0A           		ASL
00F67B  2  A2 04        		LDX	#4
00F67D  2  0A           ENTERADRG:	ASL
00F67E  2  2E 6B 04     		ROL	ASTART
00F681  2  2E 6C 04     		ROL	ASTART+1
00F684  2  CA           		DEX
00F685  2  D0 F6        		BNE	ENTERADRG
00F687  2               
00F687  2  CE 6F 04     		DEC	CNT
00F68A  2  D0 C6        		BNE	ENTERADRC
00F68C  2  A9 0A        ENTERADREND:	LDA	#EOL
00F68E  2  4C 15 C0     		JMP	JPRINT
00F691  2               
00F691  2  A2 70        GETCHAR:	LDX	#$70
00F693  2  A9 07        		LDA	#GETCHR
00F695  2  9D 82 02     		STA 	ICCOM,X
00F698  2  A9 00        		LDA 	#0
00F69A  2  9D 87 02     		STA 	ICBLL,X
00F69D  2  9D 88 02     		STA 	ICBLH,X
00F6A0  2               	.IF PLATFORM <= 1
00F6A0  2  9D 89 02     		STA 	ICBLB,X
00F6A3  2               	.ENDIF
00F6A3  2  20 0F C0     		JSR 	CIOV
00F6A6  2               
00F6A6  2  C9 61        UPPER:		cmp	#'a'
00F6A8  2  90 06        		bcc	UPPEREND
00F6AA  2  C9 7B        		cmp	#'z'+1
00F6AC  2  B0 02        		bcs	UPPEREND
00F6AE  2  E9 1F        		sbc	#$1F
00F6B0  2  60           UPPEREND:	rts
00F6B1  2               
00F6B1  2               
00F6B1  2               ;
00F6B1  2  01           DUPMENU:	.byte CLS
00F6B2  2  46 41 54 2D  		.byte "FAT-16 DOS (c) by "
00F6B6  2  31 36 20 44  
00F6BA  2  4F 53 20 28  
00F6C4  2  52 2E 20 53  		.byte "R. Scholz"
00F6C8  2  63 68 6F 6C  
00F6CC  2  7A           
00F6CD  2  0A 0A        		.byte EOL,EOL
00F6CF  2  41 20 2D 20  		.byte "A - Display Dir"
00F6D3  2  44 69 73 70  
00F6D7  2  6C 61 79 20  
00F6DE  2  0A           		.byte EOL
00F6DF  2  43 20 2D 20  		.byte "C - Change  Dir"
00F6E3  2  43 68 61 6E  
00F6E7  2  67 65 20 20  
00F6EE  2  0A           		.byte EOL
00F6EF  2  44 20 2D 20  		.byte "D - Delete  File"
00F6F3  2  44 65 6C 65  
00F6F7  2  74 65 20 20  
00F6FF  2  0A           		.byte EOL
00F700  2  47 20 2D 20  		.byte "G - Goto    Address"
00F704  2  47 6F 74 6F  
00F708  2  20 20 20 20  
00F713  2  0A           		.byte EOL
00F714  2  4C 20 2D 20  		.byte "L - Load    File"
00F718  2  4C 6F 61 64  
00F71C  2  20 20 20 20  
00F724  2  0A           		.byte EOL
00F725  2  4D 20 2D 20  		.byte "M - Create  Dir"
00F729  2  43 72 65 61  
00F72D  2  74 65 20 20  
00F734  2  0A           		.byte EOL
00F735  2  52 20 2D 20  		.byte "R - Rename  File"
00F739  2  52 65 6E 61  
00F73D  2  6D 65 20 20  
00F745  2  0A           		.byte EOL
00F746  2  53 20 2D 20  		.byte "S - Save    File"
00F74A  2  53 61 76 65  
00F74E  2  20 20 20 20  
00F756  2  0A           		.byte EOL
00F757  2  58 20 2D 20  		.byte "X - Exit"
00F75B  2  45 78 69 74  
00F75F  2  0A 0A        		.byte EOL,EOL
00F761  2  00           		.byte 0
00F762  2               
00F762  2  43 44 4D 52  CMDTABXIO:	.byte "CDMR"
00F766  2  41 47 4C 53  CMDTAB:		.byte "AGLSX"
00F76A  2  58           
00F76B  2  29 21 22 20  XIOCMD:		.byte CCHADIR, CDELETE, CCREDIR, CRENAME
00F76F  2  12 F3 FA F2  JMPTAB:		.word DIR-1, GOTOADR-1, LOAD-1, SAVE-1, EXIT-1
00F773  2  64 F3 F8 F3  
00F777  2  EC F2        
00F779  2               
00F779  2  70 72 65 73  READYSTR:	.byte "press any key.",0
00F77D  2  73 20 61 6E  
00F781  2  79 20 6B 65  
00F788  2  20 2D 20 46  SPECSTR:	.byte " - FILESPEC:"
00F78C  2  49 4C 45 53  
00F790  2  50 45 43 3A  
00F794  2  00           		.byte 0
00F795  2  45 52 52 4F  ERRSTR:		.byte "ERROR: "
00F799  2  52 3A 20     
00F79C  2  00           		.byte 0
00F79D  2  44 3A 2A 2E  DEFSPEC:	.byte DRVCHAR, ":*.*"
00F7A1  2  2A           
00F7A2  2  0A           		.byte EOL
00F7A3  2               
00F7A3  2  20 2D 20 46  FROMSTR:	.byte " - FROM:",0
00F7A7  2  52 4F 4D 3A  
00F7AB  2  00           
00F7AC  2  20 20 20 20  TOSTR:		.byte "      TO:",0
00F7B0  2  20 20 54 4F  
00F7B4  2  3A 00        
00F7B6  2  20 20 20 20  INTOSTR:	.byte "    INTO:",0
00F7BA  2  49 4E 54 4F  
00F7BE  2  3A 00        
00F7C0  2  20 20 41 50  APPENDSTR:	.byte "  APPEND:",0
00F7C4  2  50 45 4E 44  
00F7C8  2  3A 00        
00F7CA  2  20 2D 20 41  GOTOSTR:	.byte " - ADDRESS:"
00F7CE  2  44 44 52 45  
00F7D2  2  53 53 3A     
00F7D5  2  00           		.byte 0
00F7D6  2               
00F7D6  2  4B 3A 0A     KBDNAME:	.byte	"K:",EOL
00F7D9  2               
00F7D9  1               		.include "rs232.a65"
00F7D9  2               	.IF PLATFORM <= 1
00F7D9  2               		.A8
00F7D9  2               		.I8
00F7D9  2               	.ENDIF
00F7D9  2               
00F7D9  2               RS232V:
00F7D9  2  15 F8        		.word ROPEN-1		;OPEN
00F7DB  2  15 F8        		.word ROPEN-1		;CLOSE
00F7DD  2  1C F8        		.word RGET-1		;GET
00F7DF  2  2E F8        		.word RPUT-1		;PUT
00F7E1  2  42 F8        		.word RSTATUS-1		;STATUS
00F7E3  2  5C F8        		.word RSPECIAL-1	;SPECIAL
00F7E5  2  60           		RTS
00F7E6  2               
00F7E6  2               SERINIT:
00F7E6  2               	.IF PLATFORM = 0
00F7E6  2  A9 83        		lda #$83
00F7E8  2  8F E3 FF FF  		sta LCR0
00F7EC  2               
00F7EC  2  A9 00        		lda #0
00F7EE  2  8F E1 FF FF  		sta DLM0
00F7F2  2  A9 01        		lda #1
00F7F4  2  8F E0 FF FF  		sta DLL0
00F7F8  2               
00F7F8  2  A9 03        		lda #$03
00F7FA  2  8F E3 FF FF  		sta LCR0
00F7FE  2  60           		rts
00F7FF  2               	.ENDIF
00F7FF  2               
00F7FF  2               	.IF PLATFORM = 1
00F7FF  2               		LDA #$4A		;RX+TX AUS
00F7FF  2               		STA SB+COMMA		;RESET ERROR
00F7FF  2               		STA SB+COMMB
00F7FF  2               
00F7FF  2               		LDA #$30		;RESET TRANS
00F7FF  2               		STA SB+COMMA
00F7FF  2               		STA SB+COMMB
00F7FF  2               
00F7FF  2               		LDA #$20		;RESET RECV
00F7FF  2               		STA SB+COMMA
00F7FF  2               		STA SB+COMMB
00F7FF  2               
00F7FF  2               		LDA #$10		;RESET MODE
00F7FF  2               		STA SB+COMMA
00F7FF  2               		STA SB+COMMB
00F7FF  2               
00F7FF  2               		LDA #$E0
00F7FF  2               		STA SB+AUXCTRL
00F7FF  2               
00F7FF  2               		LDA #0			;load timer with
00F7FF  2               		STA SB+CNTMSB		;
00F7FF  2               		LDA #2			;57600 BAUD
00F7FF  2               		STA SB+CNTLSB
00F7FF  2               
00F7FF  2               		LDA SB+COMMA		;Switch to test baudrates
00F7FF  2               
00F7FF  2               		LDA #$66		;115200 BAUD
00F7FF  2               		STA SB+CLOCKA
00F7FF  2               ;		LDA #$66		;
00F7FF  2               		STA SB+CLOCKB
00F7FF  2               
00F7FF  2               
00F7FF  2               		LDA #$93		;RTS handshake + 8bits no parity
00F7FF  2               		STA SB+MODEA
00F7FF  2               ;		LDA #$93		;RTS handshake + 8bits no parity
00F7FF  2               		STA SB+MODEB
00F7FF  2               
00F7FF  2               		LDA #$17		;CTS handshake + 1 stopbit
00F7FF  2               		STA SB+MODEA
00F7FF  2               		STA SB+MODEB
00F7FF  2               
00F7FF  2               		LDA #0
00F7FF  2               		STA SB+OPCTRL
00F7FF  2               
00F7FF  2               		LDA #%11111111
00F7FF  2               		STA SB+OPSET
00F7FF  2               
00F7FF  2               		LDA #%11111100
00F7FF  2               		STA SB+OPRES
00F7FF  2               
00F7FF  2               		LDA #0			;IRQS AUS
00F7FF  2               		STA SB+IMR
00F7FF  2               
00F7FF  2               		LDA #5			;RX+TX AN
00F7FF  2               		STA SB+COMMA
00F7FF  2               		STA SB+COMMB
00F7FF  2               
00F7FF  2               		RTS
00F7FF  2               	.ENDIF
00F7FF  2               
00F7FF  2  A6 20        ISRDEV:		LDX ICHIDZ
00F801  2  BD 00 03     		LDA HATABS,X
00F804  2  C9 52        		CMP #RS232D		;'R'
00F806  2  D0 08        		BNE ISRDEVNO
00F808  2  A5 21        		LDA ICDNOZ
00F80A  2  F0 04        		BEQ ISRDEVNO
00F80C  2  C9 03        		CMP #3
00F80E  2  90 05        		BCC ISRDEVEX
00F810  2  68           ISRDEVNO:	PLA
00F811  2  68           		PLA
00F812  2  18           		CLC
00F813  2  A0 82        		LDY #NONDEV
00F815  2  60           ISRDEVEX:	RTS
00F816  2               
00F816  2               
00F816  2  20 FF F7     ROPEN:		JSR ISRDEV
00F819  2  A0 01        ROK:		LDY #SUCCES
00F81B  2  38           		SEC
00F81C  2  60           		RTS
00F81D  2               
00F81D  2               
00F81D  2               	.IF PLATFORM = 0
00F81D  2  20 FF F7     RGET:		JSR ISRDEV
00F820  2               ;		LDA #1
00F820  2               ;		LDX ICDNOZ
00F820  2               ;		DEX
00F820  2               ;		BNE RGET2
00F820  2               
00F820  2  AF E5 FF FF  RGET1:		LDA LSR0
00F824  2  29 01        		AND #1
00F826  2  F0 F8        		BEQ RGET1
00F828  2  AF E0 FF FF  		LDA RBR0
00F82C  2  4C 19 F8     		JMP ROK
00F82F  2               
00F82F  2               ;RGET2:		BIT SB+STATB
00F82F  2               ;		BEQ RGET2
00F82F  2               ;		LDA SB+RECB
00F82F  2               ;		JMP ROK
00F82F  2               
00F82F  2  A8           RPUT:		TAY
00F830  2  20 FF F7     		JSR ISRDEV
00F833  2               
00F833  2               ;		LDA #64
00F833  2               ;		LDX ICDNOZ
00F833  2               ;		DEX
00F833  2               ;		BNE RPUT2
00F833  2               
00F833  2  AF E5 FF FF  RPUT1:		LDA LSR0
00F837  2  29 40        		AND #64
00F839  2  F0 F8        		BEQ RPUT1
00F83B  2  98           		TYA
00F83C  2  8F E0 FF FF  		STA THR0
00F840  2  4C 19 F8     RPUT1EX:	JMP ROK
00F843  2               
00F843  2               ;RPUT2:		BIT SB+STATB
00F843  2               ;		BEQ RPUT2
00F843  2               ;		STY SB+TRANSB
00F843  2               ;RPUT2EX:	JMP ROK
00F843  2               	.ENDIF
00F843  2               
00F843  2               
00F843  2               	.IF PLATFORM = 1
00F843  2               RGET:		JSR ISRDEV
00F843  2               		LDA #1
00F843  2               		LDX ICDNOZ
00F843  2               		DEX
00F843  2               		BNE RGET2
00F843  2               
00F843  2               RGET1:		BIT SB+STATA
00F843  2               		BEQ RGET1
00F843  2               		LDA SB+RECA
00F843  2               		JMP ROK
00F843  2               
00F843  2               RGET2:		BIT SB+STATB
00F843  2               		BEQ RGET2
00F843  2               		LDA SB+RECB
00F843  2               		JMP ROK
00F843  2               
00F843  2               RPUT:		TAY
00F843  2               		JSR ISRDEV
00F843  2               
00F843  2               		LDA #4
00F843  2               		LDX ICDNOZ
00F843  2               		DEX
00F843  2               		BNE RPUT2
00F843  2               
00F843  2               RPUT1:		BIT SB+STATA
00F843  2               		BEQ RPUT1
00F843  2               		STY SB+TRANSA
00F843  2               RPUT1EX:	JMP ROK
00F843  2               
00F843  2               RPUT2:		BIT SB+STATB
00F843  2               		BEQ RPUT2
00F843  2               		STY SB+TRANSB
00F843  2               RPUT2EX:	JMP ROK
00F843  2               
00F843  2               	.ENDIF
00F843  2               
00F843  2               
00F843  2  20 FF F7     RSTATUS:	JSR ISRDEV
00F846  2  A9 00        		LDA #0
00F848  2  8D 69 02     		STA DEVSTAT
00F84B  2  8D 6B 02     		STA DEVSTAT+2
00F84E  2  8D 6C 02     		STA DEVSTAT+3
00F851  2               
00F851  2               	.IF PLATFORM = 0
00F851  2  AF E5 FF FF  		LDA LSR0
00F855  2  29 01        		AND #1
00F857  2  8D 6A 02     		STA DEVSTAT+1
00F85A  2  4C 19 F8     		JMP ROK
00F85D  2               	.ENDIF
00F85D  2               
00F85D  2               	.IF PLATFORM = 1
00F85D  2               		LDX ICDNOZ
00F85D  2               		DEX
00F85D  2               		BNE RSTATUS2
00F85D  2               
00F85D  2               		LDA SB+STATA
00F85D  2               RSTATUS3:	AND #1
00F85D  2               		STA DEVSTAT+1
00F85D  2               		JMP ROK
00F85D  2               
00F85D  2               RSTATUS2:	LDA SB+STATB
00F85D  2               		JMP RSTATUS3
00F85D  2               	.ENDIF
00F85D  2               
00F85D  2               
00F85D  2  20 FF F7     RSPECIAL:	JSR ISRDEV
00F860  2  A5 22        		LDA ICCOMZ
00F862  2  C9 24        		CMP #CXIO36
00F864  2  F0 03        		BEQ RBAUD
00F866  2               ;		CMP #CXIO38
00F866  2               ;		BEQ RTRANSL
00F866  2  4C 19 F8     		JMP ROK
00F869  2               
00F869  2               ;RTRANSL:	LDX ICDNOZ
00F869  2               ;		DEX
00F869  2               ;		LDA ICAX1Z
00F869  2               ;		STA SERCNT0,X
00F869  2               ;		JMP ROK
00F869  2               
00F869  2               
00F869  2  A5 2A        RBAUD:		LDA ICAX1Z		;BAUD
00F86B  2  29 07        		AND #%00000111
00F86D  2  AA           		TAX
00F86E  2  BD 8C F8     		LDA BAUDTAB,X
00F871  2  AA           		TAX
00F872  2               					;CLOCK
00F872  2               
00F872  2               	.IF PLATFORM = 0
00F872  2  A9 83        		LDA #$83
00F874  2  8F E3 FF FF  		STA LCR0
00F878  2               
00F878  2  A9 00        		LDA #0
00F87A  2  8F E1 FF FF  		STA DLM0
00F87E  2  8A           		TXA
00F87F  2  8F E0 FF FF  		STA DLL0
00F883  2               
00F883  2  A9 03        		LDA #$03
00F885  2  8F E3 FF FF  		STA LCR0
00F889  2               
00F889  2  4C 19 F8     		JMP ROK
00F88C  2               
00F88C  2  18 00        BAUDTAB:	.word 24		;4800
00F88E  2  0C           		.byte 12		;9600
00F88F  2  06           		.byte 6			;19200
00F890  2  03           		.byte 3			;38400
00F891  2  02           		.byte 2			;57600
00F892  2  01           		.byte 1			;115200
00F893  2  01           		.byte 1			;
00F894  2  01           		.byte 1			;
00F895  2               	.ENDIF
00F895  2               
00F895  2               	.IF PLATFORM = 1
00F895  2               		PHA
00F895  2               		LDA ICAX1Z
00F895  2               		LSR
00F895  2               		LSR
00F895  2               		LSR
00F895  2               		LSR
00F895  2               		AND #7
00F895  2               		EOR #%10010111
00F895  2               		TAY
00F895  2               
00F895  2               		LDA #16+7
00F895  2               		LDX ICAX1Z
00F895  2               		BPL RBAUD1
00F895  2               		ORA #8
00F895  2               RBAUD1:		LDX ICDNOZ
00F895  2               		DEX
00F895  2               		BNE RBAUD2
00F895  2               
00F895  2               		LDX #$4A		;RX+TX AUS
00F895  2               		STX SB+COMMA
00F895  2               		LDX #$10		;RES MODE
00F895  2               		STX SB+COMMA
00F895  2               
00F895  2               		STY SB+MODEA
00F895  2               		STA SB+MODEA
00F895  2               		PLA
00F895  2               		STA SB+CLOCKA
00F895  2               
00F895  2               		LDA #5
00F895  2               		STA SB+COMMA
00F895  2               		JMP ROK
00F895  2               
00F895  2               RBAUD2:		LDX #$4A		;RX+TX AUS
00F895  2               		STX SB+COMMB
00F895  2               		LDX #$10
00F895  2               		STX SB+COMMB
00F895  2               
00F895  2               		STY SB+MODEB
00F895  2               		STA SB+MODEB
00F895  2               		PLA
00F895  2               		STA SB+CLOCKB
00F895  2               
00F895  2               		LDX #5			;RX+TX AUS
00F895  2               		STX SB+COMMB
00F895  2               
00F895  2               		JMP ROK
00F895  2               
00F895  2               BAUDTAB:	.word $00		;4800
00F895  2               		.byte $BB		;9600
00F895  2               		.byte $33		;19200
00F895  2               		.byte $CC		;38400
00F895  2               		.byte $88		;57600
00F895  2               		.byte $66		;115200
00F895  2               		.byte $66		;
00F895  2               		.byte $66		;
00F895  2               	.ENDIF
00F895  2               
00F895  2               
00F895  1               		.include "vtl02c.a65"
00F895  2               	.IF PLATFORM > 1
00F895  2               		.include "homebrew.inc"
00F895  2               		.include "myos.inc"
00F895  2               		.org  $a00
00F895  2               	.ENDIF
00F895  2               
00F895  2               ;234567890123456789012345678901234567890123456789012345
00F895  2               ;
00F895  2               ; In the Kingswood AS65 assembler some of the options
00F895  2               ; below must be set manually.
00F895  2               ;
00F895  2               ;    .lf  vtl02ca2.lst      (set -l in commandline)
00F895  2               ;    .cr  6502              (is default)
00F895  2               ;    .tf  vtl02ca2.obj,ap1  (set -s2 in commandline)
00F895  2               ;-----------------------------------------------------;
00F895  2               ;             VTL-2 for the 6502 (VTL02C)             ;
00F895  2               ;           Original Altair 680b version by           ;
00F895  2               ;          Frank McCoy and Gary Shannon 1977          ;
00F895  2               ;    2012: Adapted to the 6502 by Michael T. Barry    ;
00F895  2               ; Thanks to sbprojects.com for a very nice assembler! ;
00F895  2               ;-----------------------------------------------------;
00F895  2               ;        Copyright (c) 2012, Michael T. Barry
00F895  2               ;       Revision B (c) 2015, Michael T. Barry
00F895  2               ;       Revision C (c) 2015, Michael T. Barry
00F895  2               ;               All rights reserved.
00F895  2               ;
00F895  2               ; Redistribution and use in source and binary forms,
00F895  2               ;   with or without modification, are permitted,
00F895  2               ;   provided that the following conditions are met:
00F895  2               ;
00F895  2               ; 1. Redistributions of source code must retain the
00F895  2               ;    above copyright notice, this list of conditions
00F895  2               ;    and the following disclaimer.
00F895  2               ; 2. Redistributions in binary form must reproduce the
00F895  2               ;    above copyright notice, this list of conditions
00F895  2               ;    and the following disclaimer in the documentation
00F895  2               ;    and/or other materials provided with the
00F895  2               ;    distribution.
00F895  2               ;
00F895  2               ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
00F895  2               ; AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
00F895  2               ; WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
00F895  2               ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
00F895  2               ; FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
00F895  2               ; SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
00F895  2               ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
00F895  2               ; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
00F895  2               ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
00F895  2               ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
00F895  2               ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
00F895  2               ; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
00F895  2               ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
00F895  2               ; IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
00F895  2               ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
00F895  2               ;-----------------------------------------------------;
00F895  2               ; Except for the differences discussed below, VTL02 was
00F895  2               ;   designed to duplicate the OFFICIALLY DOCUMENTED
00F895  2               ;   behavior of Frank's 680b version, detailed here:
00F895  2               ;     http://www.altair680kit.com/manuals/Altair_
00F895  2               ;     680-VTL-2%20Manual-05-Beta_1-Searchable.pdf
00F895  2               ;   These versions ignore all syntax errors and plow
00F895  2               ;   through VTL-2 programs with the assumption that
00F895  2               ;   they are "correct", but in their own unique ways,
00F895  2               ;   so any claims of compatibility are null and void
00F895  2               ;   for VTL-2 code brave (or stupid) enough to stray
00F895  2               ;   from the beaten path.
00F895  2               ;
00F895  2               ; Differences between the 680b and 6502 versions:
00F895  2               ; * {&} and {*} are initialized on entry.
00F895  2               ; * Division by zero returns 65535 for the quotient and
00F895  2               ;     the dividend for the remainder (the original 6800
00F895  2               ;     version froze).
00F895  2               ; * The 6502 has NO 16-bit registers (other than PC)
00F895  2               ;     and less overall register space than the 6800,
00F895  2               ;     so the interpreter reserves some obscure VTL02C
00F895  2               ;     variables {@ $ ( ) 0 1 2 3 4 5 6 7 8 9 < > : ?}
00F895  2               ;     for its internal use (the 680b version used a
00F895  2               ;     similar tactic, but differed in the details).
00F895  2               ;     The deep nesting of parentheses also puts {; < =}
00F895  2               ;     in danger of corruption.  For example, executing
00F895  2               ;     the statement A=((((((((1)))))))) sets both {A}
00F895  2               ;     and {;} to the value 1.
00F895  2               ; * Users wishing to call a machine language subroutine
00F895  2               ;     via the system variable {>} must first set the
00F895  2               ;     system variable {"} to the proper address vector
00F895  2               ;     (for example, "=768).
00F895  2               ; * The x register is used to point to a simple VTL02C
00F895  2               ;     variable (it can't point explicitly to an array
00F895  2               ;     element like the 680b version because it's only
00F895  2               ;     8-bits).  In the comments, var[x] refers to the
00F895  2               ;     16-bit contents of the zero-page variable pointed
00F895  2               ;     to by register x (residing at addresses x, x+1).
00F895  2               ; * The y register is used as a pointer offset inside
00F895  2               ;     a VTL02C statement (easily handling the maximum
00F895  2               ;     statement length of about 128 bytes).  In the
00F895  2               ;     comments, @[y] refers to the 16-bit address
00F895  2               ;     formed by adding register y to the value in {@}.
00F895  2               ; * The structure and flow of this interpreter are
00F895  2               ;     similar to the 680b version, but have been
00F895  2               ;     reorganized in a more 6502-friendly format (the
00F895  2               ;     6502 has no 'bsr' instruction, so the 'stuffing'
00F895  2               ;     of subroutines within 128 bytes of the caller is
00F895  2               ;     only advantageous for conditional branches).
00F895  2               ; * This version is based on the original port, which
00F895  2               ;     was wound rather tightly, in a failed attempt to
00F895  2               ;     fit it into 768 bytes like the 680b version; many
00F895  2               ;     structured programming principles were sacrificed
00F895  2               ;     in that effort.  The 6502 simply requires more
00F895  2               ;     instructions than the 6800 does to manipulate 16-
00F895  2               ;     bit quantities, but the overall execution speed
00F895  2               ;     should be comparable due to the 6502's slightly
00F895  2               ;     lower average clocks/instruction ratio.  As it is
00F895  2               ;     now, it fits into 1KB with just a few bytes to
00F895  2               ;     spare, but is more feature-laden than the 680b
00F895  2               ;     interpreter whence it came.  Beginning with
00F895  2               ;     Revision C, I tried to strike a tasteful balance
00F895  2               ;     between execution speed and code size, but I
00F895  2               ;     stubbornly kept it under 1024 ROMable bytes and
00F895  2               ;     used only documented op-codes that were supported
00F895  2               ;     by the original NMOS 6502 (without the ROR bug).
00F895  2               ;     I may have missed a few optimizations -- further
00F895  2               ;     suggestions are welcome.
00F895  2               ; * VTL02C is my free gift (?) to the world.  It may be
00F895  2               ;     freely copied, shared, and/or modified by anyone
00F895  2               ;     interested in doing so, with only the stipulation
00F895  2               ;     that any liabilities arising from its use are
00F895  2               ;     limited to the price of VTL02C (nothing).
00F895  2               ;-----------------------------------------------------;
00F895  2               ; 2015: Revision B included some space optimizations
00F895  2               ;         (suggested by dclxvi) and enhancements
00F895  2               ;         (suggested by mkl0815 and Klaus2m5):
00F895  2               ;
00F895  2               ; * Bit-wise operators & | ^ (and, or, xor)
00F895  2               ;   Example:  A=$|128) Get a char and set hi-bit
00F895  2               ;
00F895  2               ; * Absolute addressed 8-bit memory load and store
00F895  2               ;   via the {< @} facility:
00F895  2               ;   Example:  <=P) Point to the I/O port at P
00F895  2               ;             @=@&254^128) Clear low-bit & flip hi-bit
00F895  2               ;
00F895  2               ; * Starting with VTL02B, the space character is no
00F895  2               ;     longer a valid user variable nor a "valid" binary
00F895  2               ;     operator.  It's now only significant as a numeric
00F895  2               ;     constant terminator and as a place-holder in
00F895  2               ;     strings and program listings, where it may be
00F895  2               ;     used to improve human readability (at a slight
00F895  2               ;     cost in execution speed and memory consumption).
00F895  2               ;   Example:
00F895  2               ;   *              (VTL-2)
00F895  2               ;       1000 A=1)         Init loop index
00F895  2               ;       1010 ?=A)           Print index
00F895  2               ;       1020 ?="")          Newline
00F895  2               ;       1030 A=A+1)         Update index
00F895  2               ;       1040 #=A<10*1010) Loop until done
00F895  2               ;
00F895  2               ;   *              (VTL02B)
00F895  2               ;       1000 A = 1             ) Init loop index
00F895  2               ;       1010     ? = A         )   Print index
00F895  2               ;       1020     ? = ""        )   Newline
00F895  2               ;       1030     A = A + 1     )   Update index
00F895  2               ;       1040 # = A < 10 * 1010 ) Loop until done
00F895  2               ;
00F895  2               ; 2015: Revision C includes further enhancements
00F895  2               ;   (suggested by Klaus2m5):
00F895  2               ;
00F895  2               ; * "THEN" and "ELSE" operators [ ]
00F895  2               ;     A[B returns 0 if A is 0, otherwise returns B.
00F895  2               ;     A]B returns B if A is 0, otherwise returns 0.
00F895  2               ;
00F895  2               ; * Some effort was made to balance interpreter code
00F895  2               ;     density with interpreter performance, while
00F895  2               ;     remaining within the 1KB constraint.  Structured
00F895  2               ;     programming principles remained at low priority.
00F895  2               ;-----------------------------------------------------;
00F895  2               ; VTL02C variables occupy RAM addresses $0080 to $00ff,
00F895  2               ;   and are little-endian, in the 6502 tradition.
00F895  2               ; The use of lower-case and some control characters for
00F895  2               ;   variable names is allowed, but not recommended; any
00F895  2               ;   attempts to do so would likely result in chaos, due
00F895  2               ;   to aliasing with upper-case and system variables.
00F895  2               ; Variables tagged with an asterisk are used internally
00F895  2               ;   by the interpreter and may change without warning.
00F895  2               ;   {@ $ ( ) 0..9 : > ?} are (usually) intercepted by
00F895  2               ;   the interpreter, so their internal use by VTL02C is
00F895  2               ;   "safe".  The same cannot be said for {; < =}, so be
00F895  2               ;   careful!
00F895  2               ; VTL02C system variable space
00F895  2               spacevar   = $80      ; { }  Starting with VTL02B:  the
00F895  2               ;                       space character is no longer a
00F895  2               ;                       valid user variable nor a
00F895  2               ;                       "valid" binary operator.
00F895  2               ;                       It is now only significant as a
00F895  2               ;                       numeric constant terminator and
00F895  2               ;                       as a place-holder in strings
00F895  2               ;                       and program listings.
00F895  2               bang     = $82      ; {!}  return line number
00F895  2               quote    = $84      ; {"}  user ml subroutine vector
00F895  2               pound    = $86      ; {#}  current line number
00F895  2               dolr     = $88      ; {$}* temp storage / char i/o
00F895  2               remn     = $8A      ; {%}  remainder of last division
00F895  2               ampr     = $8C      ; {&}  pointer to start of array
00F895  2               tick     = $8E      ; {'}  pseudo-random number
00F895  2               lparen   = $90      ; {(}* old line # / begin sub-exp
00F895  2               rparen   = $92      ; {)}* temp storage / end sub-exp
00F895  2               star     = $94      ; {*}  pointer to end of free mem
00F895  2               ;          $96      ; {+ , - . /}  valid variables
00F895  2               ; Interpreter argument stack space
00F895  2               arg      = $A0      ; {0 1 2 3 4 5 6 7 8 9 :}*
00F895  2               ; Rarely used variables and argument stack overflow
00F895  2               ;          $B6      ; {;}* valid user variable
00F895  2               lthan    = $B8      ; {<}* user memory byte pointer
00F895  2               equal    = $BA      ; {=}* valid user variable (now used as 24-bit pointer)
00F895  2               gthan    = $BC      ; {>}* temp / call ML subroutine
00F895  2               ques     = $BE      ; {?}* temp / terminal i/o
00F895  2               at       = $C0      ; {@}* internal pointer / mem byte
00F895  2               ; VTL02C standard user variable space
00F895  2               ;                     {A B C .. X Y Z [ \ ] ^ _}
00F895  2               
00F895  2               ;
00F895  2               nulstk   = $01ff    ; system stack resides in page 1
00F895  2               ;-----------------------------------------------------;
00F895  2               ; Equates for a 48K+ Apple 2 (original, +, e, c, gs)
00F895  2               ;ESC      = 27       ; "Cancel current input line" key
00F895  2               ;BS       = 8        ; "Delete last keypress" key
00F895  2               ;OP_OR    = '!'      ; Bit-wise OR operator
00F895  2               ;linbuf   = $0200    ; input line buffer
00F895  2               ;prgm     = $0800    ; VTL02B program grows from here
00F895  2               ;himem    = $8000    ;   ... up to the top of user RAM
00F895  2               ;vtl02c   = $8000    ; interpreter cold entry point
00F895  2               ;                     (warm entry point is startok)
00F895  2               ;KBD      = $c000    ; 128 + keypress if waiting
00F895  2               ;KEYIN    = $fd0c    ; apple monitor keyin routine
00F895  2               ;COUT     = $fded    ; apple monitor charout routine
00F895  2               ;-----------------------------------------------------;
00F895  2               ; Equates for the 2m5 SBC emulator
00F895  2               ;ESC      = 27       ; "Cancel current input line" key
00F895  2               BS       = 8        ; "Delete last keypress" key
00F895  2               OP_OR    = '|'      ; Bit-wise OR operator
00F895  2               linbuf   = $0380    ; input line buffer
00F895  2               prgm     = $1000    ; VTL02B program grows from here
00F895  2               himem    = $C000    ;   ... up to the top of user RAM
00F895  2               ;vtl02c   = $fb00    ; interpreter cold entry point
00F895  2               ;                     (warm entry point is startok)
00F895  2               ;io_area  = $bf00      ;configure emulator terminal I/O
00F895  2               ;acia_tx  = io_area+$f0  ;acia tx data register
00F895  2               ;acia_rx  = io_area+$f0  ;acia rx data register
00F895  2               ;acia_st  = io_area+$ff  ;bit 0 = 10ms tick
00F895  2               ;=====================================================;
00F895  2               ;		.org  $a00
00F895  2               ;-----------------------------------------------------;
00F895  2               ; T E S T code
00F895  2               ;tloop:
00F895  2               ;	jsr	jchrin
00F895  2               ;	jsr	jprinthex
00F895  2               ;	jmp tloop
00F895  2               
00F895  2               ;-----------------------------------------------------;
00F895  2               ; Initialize program area pointers and start VTL02C
00F895  2               ; 17 bytes
00F895  2               
00F895  2               VTL02C:
00F895  2  A9 00        		lda	#<(prgm)
00F897  2  85 8C        		sta	ampr       ; {&} -> empty program
00F899  2  A9 10        		lda	#>(prgm)
00F89B  2  85 8D        		sta	ampr+1
00F89D  2  A9 00        		lda	#<(himem)
00F89F  2  85 94        		sta	star       ; {*} -> top of user RAM
00F8A1  2  A9 C0        		lda	#>(himem)
00F8A3  2  85 95        		sta	star+1
00F8A5  2               
00F8A5  2  3B           		tsc		   ; save stack-pointer
00F8A6  2  85 80        		sta	spacevar
00F8A8  2  EB           		xba
00F8A9  2  85 81        		sta	spacevar+1
00F8AB  2               
00F8AB  2               startok:
00F8AB  2  38           		sec                ; request "OK" message
00F8AC  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00F8AC  2               ; Start/restart VTL02C command line with program intact
00F8AC  2               ; 32 bytes
00F8AC  2               start:
00F8AC  2               
00F8AC  2               ;		cld             ; a sensible precaution
00F8AC  2               ;		ldx  <(nulstk)
00F8AC  2               ;		txs             ; drop whatever is on the stack
00F8AC  2               
00F8AC  2  A5 81        		lda	spacevar+1
00F8AE  2  EB           		xba
00F8AF  2  A5 80        		lda	spacevar
00F8B1  2  1B           		tcs
00F8B2  2               
00F8B2  2  90 10        		bcc	user       ; skip "OK" if carry clear
00F8B4  2  20 D4 FA     		jsr	outnl
00F8B7  2  A9 4F        		lda	#'O'       ; output \nOK\n to terminal
00F8B9  2  20 90 FD     		jsr	outch
00F8BC  2  A9 4B        		lda	#'K'
00F8BE  2  20 90 FD     		jsr	outch
00F8C1  2  20 D4 FA     		jsr	outnl
00F8C4  2               user:
00F8C4  2  20 F9 FC     		jsr	inln       ; input a line from the user
00F8C7  2  B2 C0        		lda	(at)
00F8C9  2  C9 58        		cmp	#'X'
00F8CB  2  D0 01        		bne	user1
00F8CD  2  6B           		rtl
00F8CE  2               user1:
00F8CE  2  A2 86        		ldx	#pound     ; cvbin destination = {#}
00F8D0  2  20 D0 FC     		jsr	cvbin      ; does line start with a number?
00F8D3  2  F0 39        		beq	direct     ;   no: execute direct statement
00F8D5  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00F8D5  2               ; Delete/insert/replace program line or list program
00F8D5  2               ; 7 bytes
00F8D5  2               stmnt:
00F8D5  2  18           		clc
00F8D6  2  A5 86        		lda	pound
00F8D8  2  05 87        		ora	pound+1    ; {#} = 0?
00F8DA  2  D0 4D        		bne	skp2       ;   no: delete/insert/replace line
00F8DC  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00F8DC  2               ; List program to terminal and restart "OK" prompt
00F8DC  2               ; entry:  Carry must be clear
00F8DC  2               ; uses:   findln:, outch:, prnum:, prstr:, {@ ( )}
00F8DC  2               ; exit:   to command line via findln:
00F8DC  2               ; 20 bytes
00F8DC  2               list_:
00F8DC  2  20 C0 F9     		jsr	findln     ; find program line >= {#}
00F8DF  2  A2 90        		ldx	#lparen    ; line number for prnum
00F8E1  2  20 2F FB     		jsr	prnum      ; print the line number
00F8E4  2  A9 20        		lda	#' '       ; print a space instead of the
00F8E6  2  20 90 FD     		jsr	outch      ;   line length byte
00F8E9  2  A9 00        		lda	#0         ; zero for delimiter
00F8EB  2  20 A1 FA     		jsr	prstr      ; print the rest of the line
00F8EE  2  B0 EC        		bcs	list_      ; (always taken)
00F8F0  2               ;-----------------------------------------------------;
00F8F0  2               ; The main program execution loop
00F8F0  2               ; entry:  with (cs) via "beq direct" in user:
00F8F0  2               ; exit:   to command line via findln: or "beq start"
00F8F0  2               ; 45 bytes
00F8F0  2               progr:
00F8F0  2  F0 14        		beq	eloop0     ; if {#} = 0 then ignore and
00F8F2  2  A4 91        		ldy	lparen+1   ;   continue (false branch)
00F8F4  2  A6 90        		ldx	lparen     ; else did {#} change?
00F8F6  2  C4 87        		cpy	pound+1    ;   yes: perform a branch, with
00F8F8  2  D0 04        		bne	branch     ;     carry flag conditioned for
00F8FA  2  E4 86        		cpx	pound      ;     the appropriate direction.
00F8FC  2  F0 0C        		beq	eloop      ;   no: execute next line (cs)
00F8FE  2               branch:
00F8FE  2  E8           		inx                ;   execute a VTL02B branch
00F8FF  2  D0 01        		bne	branch2
00F901  2  C8           		iny
00F902  2               branch2:
00F902  2  86 82        		stx	bang       ;   {!} = {(} + 1 (return ptr)
00F904  2  84 83        		sty	bang+1
00F906  2               eloop0:
00F906  2  2A           		rol	a
00F907  2  49 01        		eor	#1         ; complement carry flag
00F909  2  6A           		ror	a
00F90A  2               eloop:
00F90A  2  20 C0 F9     		jsr	findln     ; find first/next line >= {#}
00F90D  2  C8           		iny		   ; skip over the length byte
00F90E  2               direct:
00F90E  2  08           		php            	   ; (cc: program, cs: direct)
00F90F  2  AD 2D 03     		lda	IRQPS2S
00F912  2  D0 07        		bne	direct1
00F914  2  20 88 FD     		jsr	inch
00F917  2  C9 03        		cmp	#3
00F919  2  F0 91        		beq	start
00F91B  2               direct1:
00F91B  2  20 D9 FA     		jsr	exec       ; execute one VTL02B statement
00F91E  2  28           		plp
00F91F  2  A5 86        		lda	pound      ; update Z for {#}
00F921  2  05 87        		ora	pound+1    ; if program mode then continue
00F923  2  90 CB        		bcc	progr      ; if direct mode, did {#} change?
00F925  2  F0 85        		beq	start      ;   no: restart "OK" prompt
00F927  2  D0 DD        		bne	eloop0     ;   yes: execute program from {#}
00F929  2               ;-----------------------------------------------------;
00F929  2               ; Delete/insert/replace program line and restart the
00F929  2               ;   command prompt (no "OK" means success)
00F929  2               ; entry:  Carry must be clear
00F929  2               ; uses:   find:, start:, linbuf, {@ > # & * (}
00F929  2               ; 151 bytes
00F929  2               skp2:
00F929  2  98           		tya                ; save linbuf offset pointer
00F92A  2  48           		pha
00F92B  2  20 31 FD     		jsr	find       ; point {@} to first line >= {#}
00F92E  2  B0 34        		bcs	insrt
00F930  2  45 86        		eor	pound      ; if line doesn't already exist
00F932  2  D0 30        		bne	insrt      ; then skip deletion process
00F934  2  E4 87        		cpx	pound+1
00F936  2  D0 2C        		bne	insrt
00F938  2  AA           		tax	           ; x = 0
00F939  2  B1 C0        		lda	(at),y
00F93B  2  A8           		tay	           ; y = length of line to delete
00F93C  2  49 FF        		eor	#$ff
00F93E  2  65 8C        		adc	ampr       ; {&} = {&} - y
00F940  2  85 8C        		sta	ampr
00F942  2  B0 02        		bcs	delt
00F944  2  C6 8D        		dec	ampr+1
00F946  2               delt:
00F946  2  A5 C0        		lda	at
00F948  2  85 BC        		sta	gthan      ; {>} = {@}
00F94A  2  A5 C1        		lda	at+1
00F94C  2  85 BD        		sta	gthan+1
00F94E  2               delt2:
00F94E  2  A5 BC        		lda	gthan
00F950  2  C5 8C        		cmp	ampr       ; delete the line
00F952  2  A5 BD        		lda	gthan+1
00F954  2  E5 8D        		sbc	ampr+1
00F956  2  B0 0C        		bcs	insrt
00F958  2  B1 BC        		lda	(gthan),y
00F95A  2  81 BC        		sta	(gthan,x)
00F95C  2  E6 BC        		inc	gthan
00F95E  2  D0 EE        		bne	delt2
00F960  2  E6 BD        		inc	gthan+1
00F962  2  90 EA        		bcc	delt2      ; (always taken)
00F964  2               insrt:
00F964  2  68           		pla
00F965  2  AA           		tax	           ; x = linbuf offset pointer
00F966  2  A5 86        		lda	pound
00F968  2  48           		pha	           ; push the new line number on
00F969  2  A5 87        		lda	pound+1    ;   the system stack
00F96B  2  48           		pha
00F96C  2  A0 02        		ldy	#2
00F96E  2               cntln:
00F96E  2  E8           		inx
00F96F  2  C8           		iny	           ; determine new line length in y
00F970  2  BD 7F 03     		lda	linbuf-1,x ;   and push statement string on
00F973  2  48           		pha	           ;   the system stack
00F974  2  D0 F8        		bne	cntln
00F976  2  C0 04        		cpy	#4         ; if empty line then skip the
00F978  2  90 43        		bcc	jstart     ;   insertion process
00F97A  2  AA           		tax	           ; x = 0
00F97B  2  98           		tya
00F97C  2  18           		clc
00F97D  2  65 8C        		adc	ampr       ; calculate new program end
00F97F  2  85 BC        		sta	gthan      ; {>} = {&} + y
00F981  2  8A           		txa
00F982  2  65 8D        		adc	ampr+1
00F984  2  85 BD        		sta	gthan+1
00F986  2  A5 BC        		lda	gthan
00F988  2  C5 94        		cmp	star       ; if {>} >= {*} then the program
00F98A  2  A5 BD        		lda	gthan+1    ;   won't fit in available RAM,
00F98C  2  E5 95        		sbc	star+1     ;   so drop the stack and abort
00F98E  2  B0 2D        		bcs	jstart     ;   to the "OK" prompt
00F990  2               slide:
00F990  2  A5 8C        		lda	ampr
00F992  2  D0 02        		bne	slide2
00F994  2  C6 8D        		dec	ampr+1
00F996  2               slide2:
00F996  2  C6 8C        		dec	ampr
00F998  2  A5 8C        		lda	ampr
00F99A  2  C5 C0        		cmp	at
00F99C  2  A5 8D        		lda	ampr+1
00F99E  2  E5 C1        		sbc	at+1
00F9A0  2  90 06        		bcc	move       ; slide open a gap inside the
00F9A2  2  A1 8C        		lda	(ampr,x)   ;   program just big enough to
00F9A4  2  91 8C        		sta	(ampr),y   ;   hold the new line
00F9A6  2  B0 E8        		bcs	slide      ; (always taken)
00F9A8  2               move:
00F9A8  2  98           		tya
00F9A9  2  AA           		tax	           ; x = new line length
00F9AA  2               move2:
00F9AA  2  68           		pla	           ; pull the statement string and
00F9AB  2  88           		dey	           ;   the new line number and store
00F9AC  2  91 C0        		sta	(at),y     ;   them in the program gap
00F9AE  2  D0 FA        		bne	move2
00F9B0  2  A0 02        		ldy	#2
00F9B2  2  8A           		txa
00F9B3  2  91 C0        		sta	(at),y     ; store length after line number
00F9B5  2  A5 BC        		lda	gthan
00F9B7  2  85 8C        		sta	ampr       ; {&} = {>}
00F9B9  2  A5 BD        		lda	gthan+1
00F9BB  2  85 8D        		sta	ampr+1
00F9BD  2               jstart:
00F9BD  2  4C AC F8     		jmp	start      ; drop stack, restart cmd prompt
00F9C0  2               ;-----------------------------------------------------;
00F9C0  2               ; Point @[y] to the first/next program line >= {#}
00F9C0  2               ; entry:   (cc): start search at beginning of program
00F9C0  2               ;          (cs): start search at next line
00F9C0  2               ;          ({@} -> beginning of current line)
00F9C0  2               ; used by: list_:, progr:
00F9C0  2               ; uses:    find:, jstart:, prgm, {@ # & (}
00F9C0  2               ; exit:    if line not found then abort to "OK" prompt
00F9C0  2               ;          else {@} -> found line, x:a = {#} = {(} =
00F9C0  2               ;            actual line number, y = 2, (cc)
00F9C0  2               ; 10 bytes
00F9C0  2               findln:
00F9C0  2  20 31 FD     		jsr	find       ; find first/next line >= {#}
00F9C3  2  B0 F8        		bcs	jstart     ; if end then restart "OK" prompt
00F9C5  2  85 86        		sta	pound      ; {#} = {(}
00F9C7  2  86 87        		stx	pound+1
00F9C9  2  60           		rts
00F9CA  2               ;
00F9CA  2               ;
00F9CA  2               ;
00F9CA  2               loadsave:
00F9CA  2  A2 10        		ldx	#$10
00F9CC  2  29 08        		and	#$08	  	 ; 8=save, 0=load
00F9CE  2  D0 02        		bne	loadsave8
00F9D0  2  A9 04        		lda	#4
00F9D2  2  9D 8A 02     loadsave8:	sta	ICAX1,x
00F9D5  2  68           		pla
00F9D6  2               
00F9D6  2               loadsave5:
00F9D6  2  B1 C0        		lda	(at),y
00F9D8  2  F0 0A        		beq	loadsave1
00F9DA  2  C9 22        		cmp	#'"'
00F9DC  2  F0 06        		beq	loadsave1
00F9DE  2  99 7D 03     		sta	FNAME-3,y
00F9E1  2  C8           		iny
00F9E2  2  10 F2        		bpl	loadsave5
00F9E4  2               
00F9E4  2  A9 0A        loadsave1:	lda	#EOL
00F9E6  2  99 7D 03     		sta	FNAME-3,y
00F9E9  2               
00F9E9  2  20 99 FA     		jsr	close
00F9EC  2               
00F9EC  2  A9 03        		lda	#OPEN
00F9EE  2  9D 82 02     		sta	ICCOM,x
00F9F1  2  A9 00        		lda	#0
00F9F3  2  9D 8B 02     		sta	ICAX2,x
00F9F6  2  9D 86 02     		sta	ICBAB,x
00F9F9  2  9D 88 02     		sta	ICBLH,x
00F9FC  2  9D 89 02     		sta	ICBLB,x
00F9FF  2  A9 80        		lda	#<FNAME
00FA01  2  9D 84 02     		sta	ICBAL,x
00FA04  2  A9 03        		lda	#>FNAME
00FA06  2  9D 85 02     		sta	ICBAH,x
00FA09  2  8A           		txa
00FA0A  2  9D 87 02     		sta	ICBLL,x
00FA0D  2  20 0F C0     		jsr	CIOV
00FA10  2  30 6C        		bmi	error
00FA12  2               
00FA12  2  A9 FF        		lda	#$FF
00FA14  2  8D 80 03     		sta	FNAME
00FA17  2  8D 81 03     		sta	FNAME+1
00FA1A  2  A9 00        		lda	#<prgm
00FA1C  2  8D 82 03     		sta	FNAME+2
00FA1F  2  A9 10        		lda	#>prgm
00FA21  2  8D 83 03     		sta	FNAME+3
00FA24  2               
00FA24  2  38           		sec
00FA25  2  A5 8C        		lda	ampr
00FA27  2  E9 01        		sbc	#1
00FA29  2  8D 84 03     		sta	FNAME+4
00FA2C  2  A5 8D        		lda	ampr+1
00FA2E  2  E9 00        		sbc	#0
00FA30  2  8D 85 03     		sta	FNAME+5
00FA33  2               
00FA33  2  A9 0B        		lda	#PUTCHR
00FA35  2  BC 8A 02     		ldy	ICAX1,x
00FA38  2  C0 08        		cpy	#8
00FA3A  2  F0 02        		beq	loadsave4
00FA3C  2  A9 07        		lda	#GETCHR
00FA3E  2  9D 82 02     loadsave4:	sta	ICCOM,x
00FA41  2  A9 06        		lda	#6
00FA43  2  9D 87 02     		sta	ICBLL,x
00FA46  2  20 0F C0     		jsr	CIOV
00FA49  2  30 33        		bmi	error
00FA4B  2               
00FA4B  2  A9 00        		lda	#<prgm
00FA4D  2  9D 84 02     		sta	ICBAL,x
00FA50  2  A9 10        		lda	#>prgm
00FA52  2  9D 85 02     		sta	ICBAH,x
00FA55  2               
00FA55  2  BD 82 02     		lda	ICCOM,x
00FA58  2  C9 0B        		cmp	#PUTCHR
00FA5A  2  F0 29        		beq	save
00FA5C  2               
00FA5C  2  EE 84 03     		inc	FNAME+4
00FA5F  2  D0 03        		bne	loadsave7
00FA61  2  EE 85 03     		inc	FNAME+5
00FA64  2  38           loadsave7:	sec
00FA65  2  AD 84 03     		lda	FNAME+4
00FA68  2  85 8C        		sta	ampr
00FA6A  2  ED 82 03     		sbc	FNAME+2
00FA6D  2  9D 87 02     		sta	ICBLL,x
00FA70  2  AD 85 03     		lda	FNAME+5
00FA73  2  85 8D        		sta	ampr+1
00FA75  2  ED 83 03     		sbc	FNAME+3
00FA78  2  9D 88 02     		sta	ICBLH,x
00FA7B  2  4C 94 FA     		jmp	loadsave6
00FA7E  2               
00FA7E  2  98           error:		tya
00FA7F  2  20 0C E0     		jsr	jprinthex
00FA82  2  4C 99 FA     		jmp	close
00FA85  2               
00FA85  2               save:
00FA85  2  38           		sec
00FA86  2  A5 8C        		lda	ampr
00FA88  2  E9 00        		sbc	#<prgm
00FA8A  2  9D 87 02     		sta	ICBLL,x
00FA8D  2  A5 8D        		lda	ampr+1
00FA8F  2  E9 10        		sbc	#>prgm
00FA91  2  9D 88 02     		sta	ICBLH,x
00FA94  2               loadsave6:
00FA94  2  20 0F C0     		jsr	CIOV
00FA97  2  30 E5        		bmi	error
00FA99  2               
00FA99  2               close:
00FA99  2  A9 0C        		lda	#CLOSE
00FA9B  2  9D 82 02     		sta	ICCOM,x
00FA9E  2  4C 0F C0     		jmp	CIOV
00FAA1  2               
00FAA1  2               ;-----------------------------------------------------;
00FAA1  2               ; {?="...} handler; called from exec:
00FAA1  2               ; List line handler; called from list_:
00FAA1  2               ; 2 bytes
00FAA1  2               prstr:
00FAA1  2  C8           		iny                ; skip over the " or length byte
00FAA2  2  48           		pha
00FAA3  2  B5 00        		lda	0,x
00FAA5  2  C9 BA        		cmp	#$BA	   ; "}", save
00FAA7  2  F0 04        		beq	prstr2
00FAA9  2  C9 B6        		cmp	#$B6	   ; "{", load
00FAAB  2  D0 03        		bne	prstr1
00FAAD  2  4C CA F9     prstr2:		jmp	loadsave
00FAB0  2               prstr1:
00FAB0  2  68           		pla
00FAB1  2  AA           		tax                ; x = delimiter, fall through
00FAB2  2               ;		ldx	#$22
00FAB2  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FAB2  2               ; Print a string at @[y]
00FAB2  2               ; x holds the delimiter char, which is skipped over,
00FAB2  2               ;   not printed (a null byte is always a delimiter)
00FAB2  2               ; If a key was pressed, it pauses for another keypress
00FAB2  2               ;   before returning.  If either of those keys was a
00FAB2  2               ;   ctrl-C, it drops the stack and restarts the "OK"
00FAB2  2               ;   prompt with the user program intact
00FAB2  2               ; entry:  @[y] -> string, x = delimiter char
00FAB2  2               ; uses:   inch:, inkey:, jstart:, outch:, execrts:
00FAB2  2               ; exit:   (normal) @[y] -> null or byte after delimiter
00FAB2  2               ;         (ctrl-C) drop the stack & restart "OK" prompt
00FAB2  2               ; 39 bytes
00FAB2  2               prmsg:
00FAB2  2  8A           		txa
00FAB3  2  D1 C0        		cmp	(at),y     ; found delimiter or null?
00FAB5  2  F0 0A        		beq	prmsg2     ; yes: finish up
00FAB7  2  B1 C0        		lda	(at),y
00FAB9  2  F0 06        		beq	prmsg2
00FABB  2  20 90 FD     		jsr	outch      ; no: print char to terminal
00FABE  2  C8           		iny	           ;   and loop (with safety escape)
00FABF  2  10 F1        		bpl	prmsg
00FAC1  2               prmsg2:
00FAC1  2  AA           		tax	           ; save closing delimiter
00FAC2  2  20 79 FD     		jsr	inkey      ; any key = pause?
00FAC5  2               ; patch - remove garbage output when halting print
00FAC5  2  90 03        		bcc	prout      ;   no: proceed
00FAC7  2  20 88 FD     		jsr	inch       ;   yes: wait for another key
00FACA  2               prout:
00FACA  2  8A           		txa	           ; retrieve closing delimiter
00FACB  2  F0 07        		beq	outnl      ; always \n after null delimiter
00FACD  2  20 6F FD     		jsr	skpbyte    ; skip over the delimiter
00FAD0  2  C9 3B        		cmp	#';'       ; if trailing char is ';' then
00FAD2  2  F0 4F        		beq	execrts    ;   suppress the \n
00FAD4  2               ;		bne	outnl      ;   suppress the \n
00FAD4  2               ;		rts
00FAD4  2               outnl:
00FAD4  2  A9 0A        		lda	#EOL       ; \n to terminal
00FAD6  2               joutch:
00FAD6  2  4C 90 FD     		jmp	outch
00FAD9  2               
00FAD9  2               
00FAD9  2               ;-----------------------------------------------------;
00FAD9  2               ; Execute a (hopefully) valid VTL02C statement at @[y]
00FAD9  2               ; entry:   @[y] -> left-side of statement
00FAD9  2               ; uses:    nearly everything
00FAD9  2               ; exit:    note to machine language subroutine {>=...}
00FAD9  2               ;            users: no registers or variables are
00FAD9  2               ;            required to be preserved except the system
00FAD9  2               ;            stack pointer, the text base pointer {@},
00FAD9  2               ;            and the original line number {(}
00FAD9  2               ; if there is a {"} directly after the assignment
00FAD9  2               ;   operator, the statement will execute as {?="...},
00FAD9  2               ;   regardless of the variable named on the left side
00FAD9  2               ; 84 bytes
00FAD9  2               exec:
00FAD9  2  20 70 FD     		jsr	getbytevtl    ; fetch left-side variable name
00FADC  2  F0 45        		beq	execrts    ; do nothing with a null statement
00FADE  2  C9 29        		cmp	#')'       ; same for a full-line comment
00FAE0  2  F0 41        		beq	execrts
00FAE2  2  C8           		iny
00FAE3  2  A2 A0        		ldx	#arg       ; initialize argument pointer
00FAE5  2  20 C6 FB     		jsr	convp      ; arg[{0}] -> left-side variable
00FAE8  2  20 70 FD     		jsr	getbytevtl    ; skip over assignment operator
00FAEB  2  20 6F FD     		jsr	skpbyte    ; is right-side a literal string?
00FAEE  2  C9 22        		cmp	#'"'       ;   yes: print the string with
00FAF0  2  F0 AF        		beq	prstr      ;     trailing ';' check & return
00FAF2  2  A2 A2        		ldx	#arg+2     ; point eval to arg[{1}]
00FAF4  2  20 5A FB     		jsr	eval       ; evaluate right-side in arg[{1}]
00FAF7  2  A5 A2        		lda	arg+2
00FAF9  2  A0 00        		ldy	#0
00FAFB  2  A6 A1        		ldx	arg+1      ; was left-side an array element?
00FAFD  2  D0 12        		bne	exec3      ;   yes: skip to default actions
00FAFF  2  A6 A0        		ldx	arg
00FB01  2  E0 C0        		cpx	#at        ; if {@=...} statement then poke
00FB03  2  F0 25        		beq	poke       ;   low half of arg[{1}] to ({<})
00FB05  2  E0 88        		cpx	#dolr      ; if {$=...} statement then print
00FB07  2  F0 CD        		beq	joutch     ;   arg[{1}] as ASCII character
00FB09  2  E0 BE        		cpx	#ques      ; if {?=...} statement then print
00FB0B  2  F0 20        		beq	prnum0     ;   arg[{1}] as unsigned decimal
00FB0D  2  E0 BC        		cpx	#gthan     ; if {>=...} statement then call
00FB0F  2  F0 13        		beq	usr        ;   user-defined ml routine
00FB11  2               exec3:
00FB11  2  91 A0        		sta	(arg),y
00FB13  2  65 8F        		adc	tick+1     ; store arg[{1}] in the left-side
00FB15  2  2A           		rol	a          ;   variable
00FB16  2  AA           		tax
00FB17  2  C8           		iny
00FB18  2  A5 A3        		lda	arg+3
00FB1A  2  91 A0        		sta	(arg),y
00FB1C  2  65 8E        		adc	tick       ; pseudo-randomize {'}
00FB1E  2  2A           		rol	a
00FB1F  2  85 8F        		sta	tick+1
00FB21  2  86 8E        		stx	tick
00FB23  2               execrts:
00FB23  2  60           		rts
00FB24  2               
00FB24  2               usr:
00FB24  2  AA           		tax                ; jump to user ml routine with
00FB25  2  A5 A3        		lda	arg+3      ;   arg[{1}] in a:x (MSB:LSB)
00FB27  2  6C 84 00     		jmp	(quote)    ; {"} must point to valid 6502 code
00FB2A  2               poke:
00FB2A  2  87 B8        		sta	[lthan]
00FB2C  2  60           		rts
00FB2D  2               ;-----------------------------------------------------;
00FB2D  2               ; {?=...} handler; called by exec:
00FB2D  2               ; 2 bytes
00FB2D  2               prnum0:
00FB2D  2  A2 A2        		ldx	#arg+2     ; x -> arg[{1}], fall through
00FB2F  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FB2F  2               ; Print an unsigned decimal number (0..65535) in var[x]
00FB2F  2               ; entry:   var[x] = number to print
00FB2F  2               ; uses:    div:, outch:, var[x+2], saves original {%}
00FB2F  2               ; exit:    var[x] = 0, var[x+2] = 10
00FB2F  2               ; 43 bytes
00FB2F  2               prnum:
00FB2F  2  A5 8A        		lda	remn
00FB31  2  48           		pha                ; save {%}
00FB32  2  A5 8B        		lda	remn+1
00FB34  2  48           		pha
00FB35  2  A9 00        		lda	#0         ; null delimiter for print
00FB37  2  48           		pha
00FB38  2  95 03        		sta	3,x
00FB3A  2  A9 0A        		lda	#10        ; divisor = 10
00FB3C  2  95 02        		sta	2,x        ; repeat {
00FB3E  2               prnum2:
00FB3E  2  20 A5 FC     		jsr	div        ;   divide var[x] by 10
00FB41  2  A5 8A        		lda	remn
00FB43  2  09 30        		ora	#'0'       ;   convert remainder to ASCII
00FB45  2  48           		pha	           ;   stack digits in ascending
00FB46  2  B5 00        		lda	0,x        ;     order ('0' for zero)
00FB48  2  15 01        		ora	1,x
00FB4A  2  D0 F2        		bne	prnum2     ; } until var[x] is 0
00FB4C  2  68           		pla
00FB4D  2               prnum3:
00FB4D  2  20 90 FD     		jsr	outch      ; print digits in descending
00FB50  2  68           		pla	           ;   order until delimiter is
00FB51  2  D0 FA        		bne	prnum3     ;   encountered
00FB53  2  68           		pla
00FB54  2  85 8B        		sta	remn+1     ; restore {%}
00FB56  2  68           		pla
00FB57  2  85 8A        		sta	remn
00FB59  2  60           		rts
00FB5A  2               ;-----------------------------------------------------;
00FB5A  2               ; Evaluate a (hopefully) valid VTL02C expression at
00FB5A  2               ;   @[y] and place its calculated value in arg[x]
00FB5A  2               ; A VTL02C expression is defined as a string of one or
00FB5A  2               ;   more terms, separated by operators and terminated
00FB5A  2               ;   with a null or an unmatched right parenthesis
00FB5A  2               ; A term is defined as a variable name, a decimal
00FB5A  2               ;   constant, or a parenthesized sub-expression; terms
00FB5A  2               ;   are evaluated strictly from left to right
00FB5A  2               ; A variable name is defined as a user variable, an
00FB5A  2               ;   array element expression enclosed in {: )}, or a
00FB5A  2               ;   system variable (which may have side-effects)
00FB5A  2               ; entry:   @[y] -> expression text, x -> argument
00FB5A  2               ; uses:    getval:, oper:, {@}, argument stack area
00FB5A  2               ; exit:    arg[x] = result, @[y] -> next text
00FB5A  2               ; 31 bytes
00FB5A  2               eval:
00FB5A  2  A9 00        		lda	#0
00FB5C  2  95 00        		sta	0,x        ; start evaluation by simulating
00FB5E  2  95 01        		sta	1,x        ;   {0+expression}
00FB60  2  A9 2B        		lda	#'+'
00FB62  2               notdn:
00FB62  2  48           		pha	           ; stack alleged operator
00FB63  2  E8           		inx	           ; advance the argument stack
00FB64  2  E8           		inx	           ;   pointer
00FB65  2  20 79 FB     		jsr	getval     ; arg[x+2] = value of next term
00FB68  2  CA           		dex
00FB69  2  CA           		dex
00FB6A  2  68           		pla	           ; retrieve and apply the operator
00FB6B  2  20 22 FC     		jsr	oper       ;   to arg[x], arg[x+2]
00FB6E  2  20 70 FD     		jsr	getbytevtl    ; end of expression?
00FB71  2  F0 05        		beq	evalrts    ;   (null or right parenthesis)
00FB73  2  C8           		iny
00FB74  2  C9 29        		cmp	#')'       ;   no: skip over the operator
00FB76  2  D0 EA        		bne	notdn      ;     and continue the evaluation
00FB78  2               evalrts:
00FB78  2  60           		rts                ;   yes: return with final result
00FB79  2               ;-----------------------------------------------------;
00FB79  2               ; Get numeric value of the term at @[y] into var[x]
00FB79  2               ; Some examples of valid terms:  123, $, H, (15-:J)/?)
00FB79  2               ; 83 bytes
00FB79  2               getval:
00FB79  2  20 D0 FC     		jsr	cvbin      ; decimal number at @[y]?
00FB7C  2  D0 47        		bne	getrts     ;   yes: return with it in var[x]
00FB7E  2  20 70 FD     		jsr	getbytevtl
00FB81  2  C8           		iny
00FB82  2  C9 3F        		cmp	#'?'       ; user line input?
00FB84  2  D0 17        		bne	getval2
00FB86  2  98           		tya	           ;   yes:
00FB87  2  48           		pha
00FB88  2  A5 C0        		lda	at         ;     save @[y]
00FB8A  2  48           		pha	           ;     (current expression ptr)
00FB8B  2  A5 C1        		lda	at+1
00FB8D  2  48           		pha
00FB8E  2  20 F9 FC     		jsr	inln       ; input expression from user
00FB91  2  20 5A FB     		jsr	eval       ; evaluate, var[x] = result
00FB94  2  68           		pla
00FB95  2  85 C1        		sta	at+1
00FB97  2  68           		pla
00FB98  2  85 C0        		sta	at         ; restore @[y]
00FB9A  2  68           		pla
00FB9B  2  A8           		tay
00FB9C  2  60           		rts                ; skip over "?" and return
00FB9D  2               getval2:
00FB9D  2  C9 24        		cmp	#'$'       ; user char input?
00FB9F  2  D0 05        		bne	getval2a
00FBA1  2  20 88 FD     		jsr	inch       ;   yes: input one char
00FBA4  2  B0 1D        		bcs	getval5    ;     (always taken)
00FBA6  2               getval2a:
00FBA6  2  C9 40        		cmp	#'@'       ; memory access?
00FBA8  2  D0 04        		bne	getval3
00FBAA  2               		;sty	dolr       ;   yes:
00FBAA  2               		;ldy	#0
00FBAA  2  A7 B8        		lda	[lthan]	   ;     access memory byte at ({<})
00FBAC  2               		;ldy	dolr
00FBAC  2               		;bne	getval5    ;     (always taken)
00FBAC  2  80 15        		bra	getval5    ;     (always taken)
00FBAE  2               getval3:
00FBAE  2  C9 28        		cmp	#'('       ; sub-expression?
00FBB0  2  F0 A8        		beq	eval       ;   yes: evaluate it recursively
00FBB2  2  20 C6 FB     		jsr	convp      ;   no: first set var[x] to the
00FBB5  2  A1 00        		lda	(0,x)      ;     named variable's address,
00FBB7  2  48           		pha	           ;     then replace that address
00FBB8  2  F6 00        		inc	0,x        ;     with the variable's actual
00FBBA  2  D0 02        		bne	getval4    ;     value before returning
00FBBC  2  F6 01        		inc	1,x
00FBBE  2               getval4:
00FBBE  2  A1 00        		lda	(0,x)
00FBC0  2  95 01        		sta	1,x        ; store high-byte of term value
00FBC2  2  68           		pla
00FBC3  2               getval5:
00FBC3  2  95 00        		sta	0,x        ; store low-byte of term value
00FBC5  2               getrts:
00FBC5  2  60           		rts
00FBC6  2               ;-----------------------------------------------------;
00FBC6  2               ; Set var[x] to the address of the variable named in a
00FBC6  2               ; entry:   a holds variable name, @[y] -> text holding
00FBC6  2               ;            array index expression (if a = ':')
00FBC6  2               ; uses:    plus, eval, oper8d, {@ &}
00FBC6  2               ; exit:    (eq): var[x] -> variable, @[y] unchanged
00FBC6  2               ;          (ne): var[x] -> array element,
00FBC6  2               ;                @[y] -> following text
00FBC6  2               ; 26 bytes
00FBC6  2               convp:
00FBC6  2  C9 3A        		cmp	#':'       ; array element?
00FBC8  2  D0 11        		bne	simple     ;   no: var[x] -> simple variable
00FBCA  2  20 5A FB     		jsr	eval       ;   yes: evaluate array index at
00FBCD  2  16 00        		asl	0,x        ;     @[y] and advance y
00FBCF  2  36 01        		rol	1,x
00FBD1  2  A5 8C        		lda	ampr       ;     var[x] -> array element
00FBD3  2  95 02        		sta	2,x        ;       at address 2*index+&
00FBD5  2  A5 8D        		lda	ampr+1
00FBD7  2  95 03        		sta	3,x
00FBD9  2  D0 39        		bne	plus       ;     (always taken)
00FBDB  2               ; The following section is designed to translate the
00FBDB  2               ;   named simple variable from its ASCII value to its
00FBDB  2               ;   zero-page address.  In this case, 'A' translates
00FBDB  2               ;   to $82, '!' translates to $c2, etc.  The method
00FBDB  2               ;   employed must correspond to the zero-page equates
00FBDB  2               ;   above, or strange and not-so-wonderful bugs will
00FBDB  2               ;   befall the weary traveller on his or her porting
00FBDB  2               ;   journey.
00FBDB  2               simple:
00FBDB  2               ;		sec
00FBDB  2               ;		sbc	#' '
00FBDB  2  C9 61        		cmp	#'a'
00FBDD  2  90 06        		bcc	simple1
00FBDF  2  C9 7B        		cmp	#'z'+1
00FBE1  2  B0 02        		bcs	simple1
00FBE3  2  E9 1F        		sbc	#31
00FBE5  2               simple1:
00FBE5  2  49 20        		eor	#%00100000
00FBE7  2  0A           		asl	a          ; form simple variable address
00FBE8  2  09 80        		ora	#$80       ; mapping function is (a*2)|128
00FBEA  2  30 72        		bmi	oper8d     ; (always taken)
00FBEC  2               ;-----------------------------------------------------;
00FBEC  2               ; 16-bit unsigned multiply routine: var[x] *= var[x+2]
00FBEC  2               ; exit:    overflow is ignored/discarded, var[x+2] and
00FBEC  2               ;          {>} are modified, a = 0
00FBEC  2               ; 40 bytes
00FBEC  2               mul:
00FBEC  2  B5 00        		lda	0,x
00FBEE  2  85 BC        		sta	gthan
00FBF0  2  B5 01        		lda	1,x        ; {>} = var[x]
00FBF2  2  85 BD        		sta	gthan+1
00FBF4  2  A9 00        		lda	#0
00FBF6  2  95 00        		sta	0,x        ; var[x] = 0
00FBF8  2  95 01        		sta	1,x
00FBFA  2               mul2:
00FBFA  2  A5 BC        		lda	gthan
00FBFC  2  05 BD        		ora	gthan+1
00FBFE  2  F0 13        		beq	mulrts     ; exit early if {>} = 0
00FC00  2  46 BD        		lsr	gthan+1
00FC02  2  66 BC        		ror	gthan      ; {>} /= 2
00FC04  2  90 03        		bcc	mul3
00FC06  2  20 14 FC     		jsr	plus       ; form the product in var[x]
00FC09  2               mul3:
00FC09  2  16 02        		asl	2,x
00FC0B  2  36 03        		rol	3,x        ; left-shift var[x+2]
00FC0D  2  B5 02        		lda	2,x
00FC0F  2  15 03        		ora	3,x        ; loop until var[x+2] = 0
00FC11  2  D0 E7        		bne	mul2
00FC13  2               mulrts:
00FC13  2  60           		rts
00FC14  2               ;-----------------------------------------------------;
00FC14  2               ; var[x] += var[x+2]
00FC14  2               ; 14 bytes
00FC14  2               plus:
00FC14  2  18           		clc
00FC15  2  B5 00        		lda	0,x
00FC17  2  75 02        		adc	2,x
00FC19  2  95 00        		sta	0,x
00FC1B  2  B5 01        		lda	1,x
00FC1D  2  75 03        		adc	3,x
00FC1F  2  95 01        		sta	1,x
00FC21  2  60           		rts
00FC22  2               ;-----------------------------------------------------;
00FC22  2               ; Apply the binary operator in a to var[x] and var[x+2]
00FC22  2               ; Valid VTL02C operators are {* + / [ ] - | ^ & < = >}
00FC22  2               ; {>} is defined as greater than _or_equal_
00FC22  2               ; An undefined operator will be interpreted as one of
00FC22  2               ;   the three comparison operators
00FC22  2               ; 37 bytes
00FC22  2               oper:
00FC22  2  C9 2B        		cmp	#'+'       ; addition operator?
00FC24  2  F0 EE        		beq	plus
00FC26  2  C9 2A        		cmp	#'*'       ; multiplication operator?
00FC28  2  F0 C2        		beq	mul
00FC2A  2  C9 2F        		cmp	#'/'       ; division operator?
00FC2C  2  F0 77        		beq	div
00FC2E  2  C9 5B        		cmp	#'['       ; "then" operator?
00FC30  2  F0 32        		beq	then_
00FC32  2  C9 5D        		cmp	#']'       ; "else" operator?
00FC34  2  F0 3C        		beq	else_
00FC36  2  CA           		dex	           ; (factored from the following ops)
00FC37  2  C9 2D        		cmp	#'-'       ; subtraction operator?
00FC39  2  F0 41        		beq	minus
00FC3B  2  C9 7C        		cmp	#OP_OR     ; bit-wise or operator?
00FC3D  2  F0 52        		beq	or_
00FC3F  2  C9 5E        		cmp	#'^'       ; bit-wise xor operator?
00FC41  2  F0 58        		beq	xor_
00FC43  2  C9 26        		cmp	#'&'       ; bit-wise and operator?
00FC45  2  F0 40        		beq	and_
00FC47  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FC47  2               ; Apply comparison operator in a to var[x] and var[x+2]
00FC47  2               ;   and place result in var[x] (1: true, 0: false)
00FC47  2               ; expects:  (cs), pre-decremented x
00FC47  2               ; 29 bytes
00FC47  2  49 3C        		eor	#'<'       ; 0: '<'  1: '='  2: '>'
00FC49  2  85 BC        		sta	gthan      ; other values in a are undefined,
00FC4B  2  20 7C FC     		jsr	minus      ;   but _will_ produce some result
00FC4E  2  C6 BC        		dec	gthan      ; var[x] -= var[x+2]
00FC50  2  D0 05        		bne	oper8b     ; equality test?
00FC52  2  15 00        		ora	0,x        ;   yes: 'or' high and low bytes
00FC54  2  F0 04        		beq	oper8c     ;     (cs) if 0
00FC56  2  18           		clc             ;     (cc) if not 0
00FC57  2               oper8b:
00FC57  2  A5 BC        		lda	gthan
00FC59  2  2A           		rol	a
00FC5A  2               oper8c:
00FC5A  2  69 00        		adc	#0
00FC5C  2  29 01        		and	#1         ; var[x] = 1 (true), 0 (false)
00FC5E  2               oper8d:
00FC5E  2  95 00        		sta	0,x
00FC60  2  A9 00        		lda	#0
00FC62  2  F0 20        		beq	minus3     ; (always taken)
00FC64  2               ;-----------------------------------------------------;
00FC64  2               ; expects:  (cs)
00FC64  2               ; 14 bytes
00FC64  2               then_:
00FC64  2  B5 00        		lda	0,x
00FC66  2  15 01        		ora	1,x
00FC68  2  F0 1C        		beq	minus4
00FC6A  2  B5 02        		lda	2,x
00FC6C  2  95 00        		sta	0,x
00FC6E  2  B5 03        		lda	3,x
00FC70  2  B0 12        		bcs	minus3     ; (always taken)
00FC72  2               ;-----------------------------------------------------;
00FC72  2               ; expects:  (cs)
00FC72  2               ; 10 bytes
00FC72  2               else_:
00FC72  2  B5 00        		lda	0,x
00FC74  2  15 01        		ora	1,x
00FC76  2  F0 9C        		beq	plus
00FC78  2  A9 00        		lda	#0
00FC7A  2  F0 E2        		beq	oper8d     ; (always taken)
00FC7C  2               ;-----------------------------------------------------;
00FC7C  2               ; var[x] -= var[x+2]
00FC7C  2               ; expects:  (cs), pre-decremented x
00FC7C  2               ; 11 bytes
00FC7C  2               minus:
00FC7C  2  20 80 FC     		jsr	minus2
00FC7F  2  E8           		inx
00FC80  2               minus2:
00FC80  2  B5 01        		lda	1,x
00FC82  2  F5 03        		sbc	3,x
00FC84  2               minus3:
00FC84  2  95 01        		sta	1,x
00FC86  2               minus4:
00FC86  2  60           		rts
00FC87  2               ;-----------------------------------------------------;
00FC87  2               ; var[x] &= var[x+2]
00FC87  2               ; expects:  (cs), pre-decremented x
00FC87  2               ; 10 bytes
00FC87  2               and_:
00FC87  2  20 8B FC     		jsr	and_2
00FC8A  2  E8           		inx
00FC8B  2               and_2:
00FC8B  2  B5 01        		lda	1,x
00FC8D  2  35 03        		and	3,x
00FC8F  2  B0 F3        		bcs	minus3     ; (always taken)
00FC91  2               ;-----------------------------------------------------;
00FC91  2               ; var[x] |= var[x+2]
00FC91  2               ; expects:  (cs), pre-decremented x
00FC91  2               ; 10 bytes
00FC91  2               or_:
00FC91  2  20 95 FC     		jsr	or_2
00FC94  2  E8           		inx
00FC95  2               or_2:
00FC95  2  B5 01        		lda	1,x
00FC97  2  15 03        		ora	3,x
00FC99  2  B0 E9        		bcs	minus3     ; (always taken)
00FC9B  2               ;-----------------------------------------------------;
00FC9B  2               ; var[x] ^= var[x+2]
00FC9B  2               ; expects:  (cs), pre-decremented x
00FC9B  2               ; 10 bytes
00FC9B  2               xor_:
00FC9B  2  20 9F FC     		jsr	xor_2
00FC9E  2  E8           		inx
00FC9F  2               xor_2:
00FC9F  2  B5 01        		lda	1,x
00FCA1  2  55 03        		eor	3,x
00FCA3  2  B0 DF        		bcs	minus3     ; (always taken)
00FCA5  2               ;-----------------------------------------------------;
00FCA5  2               ; 16-bit unsigned division routine
00FCA5  2               ;   var[x] /= var[x+2], {%} = remainder, {>} modified
00FCA5  2               ;   var[x] /= 0 produces {%} = var[x], var[x] = 65535
00FCA5  2               ; 43 bytes
00FCA5  2               div:
00FCA5  2  A9 00        		lda	#0
00FCA7  2  85 8A        		sta	remn       ; {%} = 0
00FCA9  2  85 8B        		sta	remn+1
00FCAB  2  A9 10        		lda	#16
00FCAD  2  85 BC        		sta	gthan      ; {>} = loop counter
00FCAF  2               div1:
00FCAF  2  16 00        		asl	0,x        ; var[x] is gradually replaced
00FCB1  2  36 01        		rol	1,x        ;   with the quotient
00FCB3  2  26 8A        		rol	remn       ; {%} is gradually replaced
00FCB5  2  26 8B        		rol	remn+1     ;   with the remainder
00FCB7  2  A5 8A        		lda	remn
00FCB9  2  D5 02        		cmp	2,x
00FCBB  2  A5 8B        		lda	remn+1     ; partial remainder >= var[x+2]?
00FCBD  2  F5 03        		sbc	3,x
00FCBF  2  90 0A        		bcc	div2
00FCC1  2  85 8B        		sta	remn+1     ;   yes: update the partial
00FCC3  2  A5 8A        		lda	remn       ;     remainder and set the
00FCC5  2  F5 02        		sbc	2,x        ;     low bit in the partial
00FCC7  2  85 8A        		sta	remn       ;     quotient
00FCC9  2  F6 00        		inc	0,x
00FCCB  2               div2:
00FCCB  2  C6 BC        		dec	gthan
00FCCD  2  D0 E0        		bne	div1       ; loop 16 times
00FCCF  2  60           		rts
00FCD0  2               ;-----------------------------------------------------;
00FCD0  2               ; If text at @[y] is a decimal constant, translate it
00FCD0  2               ;   into var[x] (discarding any overflow) and update y
00FCD0  2               ; entry:   @[y] -> text containing possible constant;
00FCD0  2               ;            leading space characters are skipped, but
00FCD0  2               ;            any spaces encountered after a conversion
00FCD0  2               ;            has begun will end the conversion.
00FCD0  2               ; used by: user:, getval:
00FCD0  2               ; uses:    mul:, plus:, var[x], var[x+2], {@ > ?}
00FCD0  2               ; exit:    (ne): var[x] = constant, @[y] -> next text
00FCD0  2               ;          (eq): var[x] = 0, @[y] unchanged
00FCD0  2               ;          (cs): in all but the truly strangest cases
00FCD0  2               ; 43 bytes
00FCD0  2               cvbin:
00FCD0  2               ;		lda	#0
00FCD0  2  74 00        		stz	0,x        ; var[x] = 0
00FCD2  2  74 01        		stz	1,x
00FCD4  2  74 03        		stz	3,x
00FCD6  2               
00FCD6  2  20 70 FD     		jsr	getbytevtl    ; skip any leading spaces
00FCD9  2  84 BE        		sty	ques       ; save pointer
00FCDB  2               cvbin2:
00FCDB  2  B1 C0        		lda	(at),y     ; grab a char
00FCDD  2  49 30        		eor	#'0'       ; if char at @[y] is not a
00FCDF  2  C9 0A        		cmp	#10        ;   decimal digit then stop
00FCE1  2  B0 13        		bcs	cvbin3     ;   the conversion
00FCE3  2  48           		pha	           ; save decimal digit
00FCE4  2  A9 0A        		lda	#10
00FCE6  2  95 02        		sta	2,x
00FCE8  2  20 EC FB     		jsr	mul        ; var[x] *= 10
00FCEB  2  95 03        		sta	3,x
00FCED  2  68           		pla	           ; retrieve decimal digit
00FCEE  2  95 02        		sta	2,x
00FCF0  2  20 14 FC     		jsr	plus       ; var[x] += digit
00FCF3  2  C8           		iny	           ; loop for more digits
00FCF4  2  10 E5        		bpl	cvbin2     ;   (with safety escape)
00FCF6  2               cvbin3:
00FCF6  2  C4 BE        		cpy	ques       ; (ne) if valid, (eq) if not
00FCF8  2  60           		rts
00FCF9  2               ;-----------------------------------------------------;
00FCF9  2               ; Accept input line from user and store it in linbuf,
00FCF9  2               ;   zero-terminated (allows very primitive edit/cancel)
00FCF9  2               ; entry:   (jsr to inln or newln, not inln6)
00FCF9  2               ; used by: user:, getval:
00FCF9  2               ; uses:    inch:, outnl:, linbuf, {@}
00FCF9  2               ; exit:    @[y] -> linbuf
00FCF9  2               ; 42 bytes
00FCF9  2               
00FCF9  2               ;inln6:
00FCF9  2               ;		cmp	#ESC       ; escape?
00FCF9  2               ;		beq	newln      ;   yes: discard entire line
00FCF9  2               ;		iny	           ; line limit exceeded?
00FCF9  2               ;		bpl	inln2      ;   no: keep going
00FCF9  2               ;newln:
00FCF9  2               ;		jsr	outnl      ;   yes: discard entire line
00FCF9  2               ;inln:
00FCF9  2               ;		ldy	#<(linbuf) ; entry point: start a fresh line
00FCF9  2               ;		sty	at         ; {@} -> input line buffer
00FCF9  2               ;		ldy	#>(linbuf)
00FCF9  2               ;		sty	at+1
00FCF9  2               ;		ldy	#1
00FCF9  2               ;inln5:
00FCF9  2               ;		dey
00FCF9  2               ;		bmi	newln
00FCF9  2               ;inln2:
00FCF9  2               ;		jsr	inch       ; get (and echo) one key press
00FCF9  2               ;		cmp	#BS        ; backspace?
00FCF9  2               ;		beq	inln5      ;   yes: delete previous char
00FCF9  2               ;		cmp	#EOL       ; cr?
00FCF9  2               ;		bne	inln3
00FCF9  2               ;		lda	#0         ;   yes: replace with null
00FCF9  2               ;inln3:
00FCF9  2               ;		sta	(at),y     ; put key in linbuf
00FCF9  2               ;		bne	inln6      ; continue if not null
00FCF9  2               ;		tay            	   ; y = 0
00FCF9  2               ;		rts
00FCF9  2               
00FCF9  2               
00FCF9  2               inln:
00FCF9  2  A2 00        		ldx	#0
00FCFB  2  A9 05        		lda	#GETREC
00FCFD  2  9D 82 02     		sta	ICCOM,x
00FD00  2  8A           		txa
00FD01  2  9D 88 02     		sta	ICBLH,x
00FD04  2  A9 50        		lda	#80
00FD06  2  9D 87 02     		sta	ICBLL,x
00FD09  2  A9 80        		lda	#<FNAME
00FD0B  2  9D 84 02     		sta	ICBAL,x
00FD0E  2  85 C0        		sta	at
00FD10  2  A9 03        		lda	#>FNAME
00FD12  2  9D 85 02     		sta	ICBAH,x
00FD15  2  85 C1        		sta	at+1
00FD17  2  20 0F C0     		jsr	CIOV
00FD1A  2  8A           		txa
00FD1B  2  A8           		tay
00FD1C  2  AE 87 02     		ldx	ICBLL
00FD1F  2  9D 7F 03     		sta	FNAME-1,x
00FD22  2               inln1:
00FD22  2  CA           		dex
00FD23  2  BD 7F 03     		lda	FNAME-1,x
00FD26  2  C9 20        		cmp	#' '
00FD28  2  D0 06        		bne	inlnex
00FD2A  2  98           		tya
00FD2B  2  9D 7F 03     		sta	FNAME-1,x
00FD2E  2  F0 F2        		beq	inln1
00FD30  2               inlnex:
00FD30  2  60           		rts
00FD31  2               
00FD31  2               ;-----------------------------------------------------;
00FD31  2               ; Find the first/next stored program line >= {#}
00FD31  2               ; entry:   (cc): start search at program beginning
00FD31  2               ;          (cs): start search at next line
00FD31  2               ;          ({@} -> beginning of current line)
00FD31  2               ; used by: skp2:, findln:
00FD31  2               ; uses:    prgm, {@ # & (}
00FD31  2               ; exit:    (cs): {@}, x:a and {(} undefined, y = 2
00FD31  2               ;          (cc): {@} -> beginning of found line, y = 2,
00FD31  2               ;                x:a = {(} = actual found line number
00FD31  2               ; 62 bytes
00FD31  2               find:
00FD31  2  A2 10        		ldx	#>(prgm)
00FD33  2  A9 00        		lda	#<(prgm)
00FD35  2  90 15        		bcc	find1st    ; cc: search begins at first line
00FD37  2  A6 C1        		ldx	at+1
00FD39  2  A0 02        		ldy	#2
00FD3B  2               findnxt:
00FD3B  2  A5 C0        		lda	at
00FD3D  2  C5 8C        		cmp	ampr
00FD3F  2  A5 C1        		lda	at+1
00FD41  2  E5 8D        		sbc	ampr+1     ; {@} >= {&} (end of program)?
00FD43  2  B0 29        		bcs	findrts    ;   yes: search failed (cs)
00FD45  2               find3:
00FD45  2  A5 C0        		lda	at
00FD47  2  71 C0        		adc	(at),y     ;   no: {@} -> next line
00FD49  2  90 03        		bcc	find5
00FD4B  2  E8           		inx
00FD4C  2               find1st:
00FD4C  2  86 C1        		stx	at+1
00FD4E  2               find5:
00FD4E  2  85 C0        		sta	at
00FD50  2  A0 00        		ldy	#0
00FD52  2  B1 C0        		lda	(at),y
00FD54  2  85 90        		sta	lparen     ; {(} = current line number
00FD56  2  C5 86        		cmp	pound      ;   (invalid if {@} >= {&}, but
00FD58  2  C8           		iny	           ;   we'll catch that later...)
00FD59  2  B1 C0        		lda	(at),y
00FD5B  2  85 91        		sta	lparen+1
00FD5D  2  E5 87        		sbc	pound+1    ; if {(} < {#} then try the next
00FD5F  2  C8           		iny	           ;   program line
00FD60  2  90 D9        		bcc	findnxt
00FD62  2  A5 C0        		lda	at         ; {@} >= {&} (end of program)?
00FD64  2  C5 8C        		cmp	ampr       ;   yes: search failed (cs)
00FD66  2  A5 C1        		lda	at+1       ;   no: search succeeded (cc)
00FD68  2  E5 8D        		sbc	ampr+1
00FD6A  2  A5 90        		lda	lparen
00FD6C  2  A6 91        		ldx	lparen+1
00FD6E  2               findrts:
00FD6E  2  60           		rts
00FD6F  2               ;-----------------------------------------------------;
00FD6F  2               ; Fetch a byte at @[y], ignoring space characters
00FD6F  2               ; 10 bytes
00FD6F  2               skpbyte:
00FD6F  2  C8           		iny             ; skip over current char
00FD70  2               getbytevtl:
00FD70  2  B1 C0        		lda	(at),y
00FD72  2  F0 04        		beq	getbyt2
00FD74  2  C9 20        		cmp	#' '
00FD76  2  F0 F7        		beq	skpbyte    ; skip over any space char(s)
00FD78  2               getbyt2:
00FD78  2  60           		rts
00FD79  2               
00FD79  2               ;============ Original I/O subroutines ===============;
00FD79  2               ;-----------------------------------------------------;
00FD79  2               ; Check for user keypress and return with (cc) if none
00FD79  2               ;   is pending.  Otherwise, fall through to inch
00FD79  2               ;   and return with (cs).
00FD79  2               ; 6 bytes
00FD79  2               ;inkey:
00FD79  2               ;    lda  KBD        ; is there a keypress waiting?
00FD79  2               ;    asl
00FD79  2               ;    bcc  outrts     ;   no: return with (cc)
00FD79  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FD79  2               ; Read key from stdin into a, echo, (cs)
00FD79  2               ; drop stack and abort to "OK" prompt if ctrl-C
00FD79  2               ; 16 bytes
00FD79  2               ;inch:
00FD79  2               ;    sty  dolr       ; save y reg
00FD79  2               ;    jsr  KEYIN      ; get a char from keyboard
00FD79  2               ;    ldy  dolr       ; restore y reg
00FD79  2               ;    and  #$7f       ; strip apple's hi-bit
00FD79  2               ;    cmp  #$03       ; ctrl-C?
00FD79  2               ;    bne  outch      ;   no: echo to terminal
00FD79  2               ;    jmp  start      ;   yes: abort to "OK" prompt
00FD79  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FD79  2               ; Print ASCII char in a to stdout, (cs)
00FD79  2               ; 9 bytes
00FD79  2               ;outch:
00FD79  2               ;    pha             ; save original char
00FD79  2               ;    ora  #$80       ; apples prefer "high" ASCII
00FD79  2               ;    jsr  COUT       ; emit char via apple monitor
00FD79  2               ;    pla             ; restore original char
00FD79  2               ;    sec             ; (by contract with callers)
00FD79  2               ;outrts:
00FD79  2               ;    rts
00FD79  2               ;-----------------------------------------------------;
00FD79  2               ;========== 2m5 SBC emulator I/O subroutines ============;
00FD79  2               ;-----------------------------------------------------;
00FD79  2               ; Check for user keypress and return if none
00FD79  2               ;   is pending.  Otherwise, check for ctrl-C and
00FD79  2               ;   return after next keypress.
00FD79  2               ;
00FD79  2               inkey:
00FD79  2  18           		clc
00FD7A  2  AD 2D 03     		lda	IRQPS2S    ; Is there a character waiting?
00FD7D  2  D0 08        		bne	inkeyr     ;   no: return
00FD7F  2               
00FD7F  2  20 03 E0     		jsr	jchrin
00FD82  2  C9 03        		cmp	#3         ; is ctrl-c
00FD84  2  F0 07        		beq	istart     ;   yes: abort to OK prompt
00FD86  2               ;inkeyp:
00FD86  2               ;		lda	IRQPS2S    ; pause until next key
00FD86  2               ;		bne	inkeyp
00FD86  2               ;		jsr	jchrin
00FD86  2               
00FD86  2               ;		cmp	#3         ; is ctrl-c
00FD86  2               ;		beq	istart     ;   yes: abort to OK prompt
00FD86  2  38           		sec
00FD87  2               inkeyr:
00FD87  2  60           		rts
00FD88  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FD88  2               ; Read key from stdin into a, echo, (cs)
00FD88  2               ; Dump stack and abort to "OK" prompt if ctrl-C
00FD88  2               ;
00FD88  2               inch:
00FD88  2               ;		lda	IRQPS2S    ; get character from rx register
00FD88  2               ;		bne	inch       ; wait for character !=0
00FD88  2  20 03 E0     		jsr	jchrin
00FD8B  2  38           		sec
00FD8C  2  60           		rts
00FD8D  2               
00FD8D  2               ;		sty	dolr       ; save y reg
00FD8D  2               ;		cmp	#127       ; convert delete to backspace
00FD8D  2               ;		bne	conv_bs2del
00FD8D  2               ;		lda	#8
00FD8D  2               ;conv_bs2del:
00FD8D  2               ;		cmp	#27        ; escape?
00FD8D  2               ;		bne	skip_esc_no
00FD8D  2               ;		ldy	#5         ; timer loop - 5*10ms
00FD8D  2               ;skip_esc_next:
00FD8D  2               ;;		lda	#1         ; ack last tick
00FD8D  2               ;;		sta	acia_st
00FD8D  2               ;skip_esc_wait:
00FD8D  2               ;;		lda	acia_st
00FD8D  2               ;;		and	#1         ; next tick
00FD8D  2               ;;		beq	skip_esc_wait
00FD8D  2               ;		dey
00FD8D  2               ;		bne	skip_esc_next
00FD8D  2               ;skip_esc_discard:
00FD8D  2               ;		iny             ; any data = y > 1
00FD8D  2               ;		lda	IRQPS2S
00FD8D  2               ;		bne	skip_esc_discard
00FD8D  2               ;		cpy	#1
00FD8D  2               ;		bne	inch
00FD8D  2               ;skip_esc_esc:       			; escape only - send to vtl
00FD8D  2               ;		lda	#27
00FD8D  2               ;		rts
00FD8D  2               ;skip_esc_no:
00FD8D  2               ;		ldy	dolr       ; restore y reg
00FD8D  2               ;inch2:
00FD8D  2               ;		and	#$7f       ; ensure char is positive ascii
00FD8D  2               ;		cmp	#$03       ; ctrl-C?
00FD8D  2               ;		bne	outch      ;   no: echo to terminal
00FD8D  2               istart:
00FD8D  2  4C AC F8     		jmp	start      ;   yes: abort to "OK" prompt
00FD90  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
00FD90  2               ; Print ascii char in a to stdout, (cs)
00FD90  2               ;
00FD90  2               outch:
00FD90  2               ;		cmp	#13        ; add line feed to carriage return
00FD90  2               ;		bne	skip_cr
00FD90  2               ;		lda	#10
00FD90  2               ;		sta	acia_tx
00FD90  2               ;		jsr	jchrout
00FD90  2               ;		lda	#13
00FD90  2               skip_cr:
00FD90  2               ;		cmp	#8         ; backspace?
00FD90  2               ;		bne	skip_bs;
00FD90  2               ;		sta	acia_tx    ; make erasing backspace
00FD90  2               ;		jsr	jchrout
00FD90  2               ;		lda	#' '
00FD90  2               ;		sta	acia_tx
00FD90  2               ;		jsr	jchrout
00FD90  2               ;		lda	#8
00FD90  2               skip_bs:
00FD90  2  20 06 E0     		jsr	jchrout
00FD93  2               ;		sta	acia_tx    ; emit char via transmit register
00FD93  2  38           		sec          	   ; (by contract with callers)
00FD94  2  60           		rts
00FD95  2               ;-----------------------------------------------------;
00FD95  2               ;   org  $fffc
00FD95  2               ;    dw   vtl02c     ; reset vector -> cold start
00FD95  2               ;   end  vtl02c     ; set start address
00FD95  2               
00FD95  1               	.ENDIF
00FD95  1               
